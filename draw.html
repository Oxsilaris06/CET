<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dessinateur de Plan Simple</title>
    <!-- Inclure Two.js et Hammer.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/two.js/0.8.7/two.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <!-- Icônes Material Symbols -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        /* Variables de couleur et styles de base */
        :root {
            --bg-canvas: #f8fafc; /* Blanc cassé */
            --bg-body: #1f2937;  /* Gris foncé */
            --text-primary: #f3f4f6; /* Texte clair */
            --accent-main: #3b82f6; /* Bleu */
            --accent-active: #1e40af; /* Bleu foncé */
            --grid-line: #e2e8f0; /* Ligne de grille très claire */
            --color-line: #1f2937; /* Noir/Gris foncé par défaut */
            --color-room: #9CA3AF40; /* Gris transparent */
            --color-door: #F87171; /* Rouge */
            --color-window: #60A5FA; /* Bleu clair */
            --color-delete: #c0392b; /* Rouge pour suppression */
            --color-export: #FBBF24; /* Jaune pour export */
            --color-toolbar-button: #4b5563; /* Gris sombre boutons */
            --color-toolbar-hover: #6b7280; /* Gris plus clair hover */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; /* Empêche le flash bleu sur mobile */
        }

        body {
            font-family: sans-serif;
            background: var(--bg-body);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow: hidden; /* Empêche le défilement global pour le dessin */
        }

        .app-container { display: flex; flex-direction: column; height: 100vh; }

        /* Barre d'outils */
        .app-header {
            background: var(--bg-body);
            padding: 0.5rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            flex-wrap: nowrap;
            overflow-x: auto; /* Défilement horizontal si nécessaire */
            z-index: 100; /* Assure que la barre d'outils est au-dessus */
        }

        .toolbar {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-grow: 1; /* Prend l'espace disponible */
        }

        .tool-btn {
            flex-shrink: 0;
            padding: 0.5rem 0.6rem;
            border: none;
            background: var(--color-toolbar-button);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 55px;
            min-width: 60px;
            text-align: center;
            border: 2px solid transparent;
            touch-action: manipulation; /* Important pour Hammer.js */
        }
        .tool-btn .tool-icon { font-size: 1.4rem; margin-bottom: 2px; }
        .tool-btn.active { background: var(--accent-main); border-color: var(--accent-active); }
        .tool-btn:hover:not(.active) { background: var(--color-toolbar-hover); }

        /* Conteneur Export séparé */
        .export-container {
            flex-shrink: 0;
            margin-left: auto;
            padding-left: 0.5rem;
        }

        .export-btn {
            padding: 0.8rem 1rem;
            background: var(--color-export);
            color: #1f2937; /* Texte foncé pour contraste sur jaune */
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
            touch-action: manipulation; /* Permet le clic immédiat sur mobile */
        }
        .export-btn:hover { background: #facc15; } /* Jaune plus clair au survol */

        /* Zone de dessin */
        .canvas-container {
            flex-grow: 1;
            position: relative;
            background: var(--bg-canvas);
            overflow: hidden; /* Empêche le contenu de déborder */
        }
        .grid-background {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-size: 50px 50px; /* Taille de la grille */
            background-image: linear-gradient(to right, var(--grid-line) 1px, transparent 1px),
                              linear-gradient(to bottom, var(--grid-line) 1px, transparent 1px);
            pointer-events: none;
            z-index: 1;
        }
        #drawing-area {
            width: 100%; height: 100%;
            position: relative;
            z-index: 2;
            touch-action: none; /* ESSENTIEL pour Hammer.js et dessin tactile */
            user-select: none;
        }

        /* Toast (Notifications) */
        #toast-message {
            position: fixed; top: 70px; /* Abaissé pour ne pas être caché par le header */
            left: 50%; transform: translateX(-50%);
            background: var(--accent-main); color: white; padding: 0.5rem 1rem;
            border-radius: 8px; font-weight: 600; opacity: 0;
            transition: opacity 0.3s ease, top 0.3s ease;
            z-index: 1000;
            pointer-events: none; /* N'interfère pas avec le dessin */
        }
        #toast-message.show { opacity: 1; top: 80px; }
        #toast-message.error { background: var(--color-delete); }

        /* Styles PC (barre d'outils verticale) */
        @media (min-width: 768px) {
            .app-container { flex-direction: row; }
            .app-header {
                flex-direction: column;
                width: 120px;
                height: 100vh;
                padding: 1rem 0.5rem;
                box-shadow: 2px 0 5px rgba(0,0,0,0.2);
                overflow-y: auto;
                align-items: center;
                flex-wrap: nowrap; /* Assure la verticalité */
                overflow-x: hidden; /* Cache le défilement horizontal */
            }
            .toolbar {
                flex-direction: column;
                width: 100%;
                flex-grow: 0; /* Ne doit pas grandir */
                align-items: stretch; /* Étire les boutons */
            }
            .tool-btn { width: 100%; margin-bottom: 0.75rem; } /* Pleine largeur et espacement */

            .export-container {
                 width: 100%;
                 margin-left: 0;
                 margin-top: auto; /* Pousse en bas */
                 padding: 1rem 0.5rem 0.5rem; /* Espace au-dessus */
                 border-top: 1px solid var(--border-color); /* Séparateur */
            }
            .export-btn { width: 100%; }
            .canvas-container { height: 100vh; }
            #toast-message { top: 10px; } /* Toast en haut sur PC */
            #toast-message.show { top: 20px; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Barre d'outils -->
        <header class="app-header">
            <div class="toolbar">
                <!-- Outils de dessin -->
                <button class="tool-btn active" data-tool="draw_rect">
                    <span class="material-symbols-outlined tool-icon">crop_square</span>
                    <span>Pièce</span>
                </button>
                <button class="tool-btn" data-tool="draw_line">
                    <span class="material-symbols-outlined tool-icon">line_start_square</span>
                    <span>Mur</span>
                </button>
                <!-- Symboles -->
                <button class="tool-btn" data-tool="symbol_door">
                    <span class="material-symbols-outlined tool-icon">door_open</span>
                    <span>Porte</span>
                </button>
                <button class="tool-btn" data-tool="symbol_window">
                    <span class="material-symbols-outlined tool-icon">window</span>
                    <span>Fenêtre</span>
                </button>
                <!-- Interactions -->
                 <button class="tool-btn" data-tool="move">
                     <span class="material-symbols-outlined tool-icon">open_with</span>
                     <span>Déplacer</span>
                 </button>
                 <button class="tool-btn" data-tool="delete">
                     <span class="material-symbols-outlined tool-icon">delete</span>
                     <span>Supprimer</span>
                 </button>
                 <!-- Utilitaires -->
                 <button class="tool-btn" data-tool="reset" style="background-color: var(--color-delete);">
                     <span class="material-symbols-outlined tool-icon">delete_sweep</span>
                     <span>Effacer</span>
                 </button>
            </div>
             <!-- Bouton Export -->
             <div class="export-container">
                 <button class="export-btn" onclick="exportCanvas('png')">Exporter PNG</button>
            </div>
        </header>

        <!-- Zone de dessin -->
        <main class="canvas-container">
            <div class="grid-background"></div>
            <div id="drawing-area"></div>
            <div id="toast-message"></div> <!-- Pour les notifications -->
        </main>
    </div>

    <script>
        // --- Initialisation ---
        const drawingArea = document.getElementById('drawing-area');
        let two; // Initialisé dans initializeApp
        const GRID_SIZE = 50; // Taille de la grille en pixels
        let currentTool = 'draw_rect'; // Outil par défaut
        let elements = []; // Stocke les objets { group, shape, data }
        let isDrawing = false;
        let startX, startY;
        let currentShape = null; // Référence à la forme Two.js en cours de dessin
        let currentGroup = null; // Référence au groupe Two.js en cours de dessin
        let selectedElement = null; // Stocke l'objet { group, shape, data } sélectionné
        let mc; // Hammer Manager

        // --- Initialisation de l'application ---
        function initializeApp() {
             two = new Two({
                width: drawingArea.clientWidth,
                height: drawingArea.clientHeight,
                type: Two.Types.svg // Utiliser SVG pour l'exportation
            }).appendTo(drawingArea);

             // Ajuster la taille initiale
             resizeCanvas();
             window.addEventListener('resize', resizeCanvas); // Ajuster au redimensionnement

             // Configuration Hammer.js pour Pan/Zoom (uniquement si Hammer est chargé)
             if (typeof Hammer !== 'undefined') {
                mc = new Hammer.Manager(drawingArea);
                mc.add([
                    new Hammer.Pan({ threshold: 5, pointers: 2 }), // Pan à deux doigts
                    new Hammer.Pinch({ enable: true }) // Pinch pour zoom
                ]);

                let initialPanX = 0, initialPanY = 0, initialZoom = 1;

                mc.on("panstart", (e) => {
                    // Vérifier si c'est un pan à deux doigts et pas un déplacement d'objet
                    if (e.pointers.length === 2 && currentTool !== 'move') {
                        initialPanX = two.translation.x;
                        initialPanY = two.translation.y;
                        drawingArea.style.cursor = 'grabbing';
                    }
                });
                mc.on("panmove", (e) => {
                     if (e.pointers.length === 2 && currentTool !== 'move') {
                        two.translation.set(initialPanX + e.deltaX, initialPanY + e.deltaY);
                     }
                });
                mc.on("panend", () => {
                     drawingArea.style.cursor = getCursorForTool(currentTool); // Réinitialiser le curseur
                });

                // Zoom (Pinch)
                 mc.on("pinchstart", (e) => { initialZoom = two.scale; });
                 mc.on("pinchmove", (e) => {
                     let newScale = initialZoom * e.scale;
                     // Limiter le zoom
                     newScale = Math.max(0.2, Math.min(5.0, newScale));

                     // Zoom centré sur le point de pincement
                    const pinchCenter = getEventPos(e); // Position dans le monde Two.js
                    const dx = pinchCenter.x - two.translation.x;
                    const dy = pinchCenter.y - two.translation.y;
                    const scaleFactor = newScale / two.scale;

                    two.translation.x -= dx * (scaleFactor - 1);
                    two.translation.y -= dy * (scaleFactor - 1);

                     two.scale = newScale;
                 });
             } else {
                 console.warn("Hammer.js n'est pas chargé. Le Pan/Zoom tactile ne sera pas disponible.");
             }
        }

        function resizeCanvas() {
            if (!two) return;
            two.width = drawingArea.clientWidth;
            two.height = drawingArea.clientHeight;
            two.update();
        }

        // --- Gestion des Outils ---
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.preventDefault();
                const toolName = this.dataset.tool;

                // Si clic sur Reset
                if (toolName === 'reset') {
                    if (confirm("Voulez-vous vraiment tout effacer ?")) {
                        resetCanvas();
                        switchTool('draw_rect'); // Revenir à l'outil par défaut après effacement
                    }
                    return; // Ne pas activer le bouton Reset
                }

                // Logique normale de changement d'outil
                currentTool = toolName;
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                deselectShape(); // Désélectionne en changeant d'outil
                drawingArea.style.cursor = getCursorForTool(currentTool);
            });
        });

        function switchTool(toolName) {
            const targetButton = document.querySelector(`.tool-btn[data-tool="${toolName}"]`);
            if (targetButton && !targetButton.classList.contains('active')) {
                // Simule un clic uniquement s'il n'est pas déjà actif
                targetButton.dispatchEvent(new Event('click'));
            } else if (targetButton) {
                 // Si déjà actif, juste s'assurer que le curseur est correct
                 drawingArea.style.cursor = getCursorForTool(toolName);
            }
        }

        function getCursorForTool(toolName) {
            if (toolName === 'move') return 'grab';
            if (toolName === 'delete') return 'crosshair'; // Ou 'not-allowed' ?
            if (toolName.startsWith('draw') || toolName.startsWith('symbol')) return 'crosshair';
            return 'default';
        }


        // --- Fonctions Utilitaires ---
        function snapValue(value) { return Math.round(value / GRID_SIZE) * GRID_SIZE; }

        /**
         * Correction: Robuste fonction getEventPos pour gérer différents types d'événements.
         */
        function getEventPos(e) {
            if (!two || !two.renderer || !two.renderer.domElement) {
                console.error("Two.js renderer n'est pas prêt.");
                return { x: 0, y: 0 }; // Fallback
            }
            const rect = two.renderer.domElement.getBoundingClientRect();
            let clientX, clientY;

            // Déterminer la source des coordonnées
            const eventSource = e.srcEvent || e; // Utiliser e.srcEvent si c'est un événement Hammer

            // Check if it's a Hammer event with pointers
            if (e.pointers && e.pointers.length > 0) {
                clientX = e.pointers[0].clientX;
                clientY = e.pointers[0].clientY;
            }
            // Check native touch event (touchstart, touchmove)
            else if (eventSource.touches && eventSource.touches.length > 0) {
                clientX = eventSource.touches[0].clientX;
                clientY = eventSource.touches[0].clientY;
            }
             // Check native touch event end (touchend has changedTouches)
            else if (eventSource.changedTouches && eventSource.changedTouches.length > 0) {
                clientX = eventSource.changedTouches[0].clientX;
                clientY = eventSource.changedTouches[0].clientY;
            }
            // Check native mouse event or generic Hammer event center
            else if (eventSource.clientX !== undefined && eventSource.clientY !== undefined) {
                clientX = eventSource.clientX;
                clientY = eventSource.clientY;
            }
             // Fallback for Hammer events that might use 'center'
            else if (e.center && e.center.x !== undefined) {
                 // Hammer center is relative to the element, not the viewport
                 clientX = e.center.x + rect.left;
                 clientY = e.center.y + rect.top;
            }
            else {
                console.error("Impossible de déterminer les coordonnées de l'événement:", e);
                return { x: 0, y: 0 }; // Fallback
            }

            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;
            const scale = two.scale;
            const tx = two.translation.x;
            const ty = two.translation.y;
            // Retourne les coordonnées du monde (Two.js space)
            return { x: (canvasX - tx) / scale, y: (canvasY - ty) / scale };
        }


        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast-message');
            toast.textContent = message;
            toast.className = type === 'error' ? 'error' : ''; // Reset class
            requestAnimationFrame(() => { // Force reflow for transition
                 toast.classList.add('show');
                 if (type === 'error') toast.classList.add('error');
            });
            setTimeout(() => { toast.classList.remove('show'); toast.classList.remove('error'); }, 1500);
        }

        function resetCanvas() {
            elements.forEach(el => two.remove(el.group));
            elements = [];
            selectedElement = null;
            two.update();
            showToast('Toile effacée', 'error');
        }

        // --- Logique de Dessin ---
        function startDrawing(x, y) {
            isDrawing = true;
            startX = snapValue(x);
            startY = snapValue(y);
            currentGroup = two.makeGroup(); // Créer un groupe pour chaque nouvel élément

            if (currentTool === 'draw_rect') {
                // Créer le rectangle à 0,0 DANS le groupe
                currentShape = two.makeRectangle(0, 0, 0, 0);
                currentShape.fill = getComputedStyle(document.documentElement).getPropertyValue('--color-room').trim();
                currentShape.stroke = getComputedStyle(document.documentElement).getPropertyValue('--color-line').trim();
                currentShape.linewidth = 2;
                currentGroup.add(currentShape);
                currentGroup.translation.set(startX, startY); // Positionner le groupe
                currentGroup.data = { type: 'room', id: Date.now() };
            } else if (currentTool === 'draw_line') {
                // Créer la ligne de 0,0 à 0,0 DANS le groupe
                currentShape = two.makeLine(0, 0, 0, 0);
                currentShape.stroke = getComputedStyle(document.documentElement).getPropertyValue('--color-line').trim();
                currentShape.linewidth = 5;
                currentShape.cap = 'round';
                currentGroup.add(currentShape);
                currentGroup.translation.set(startX, startY); // Positionner le groupe
                currentGroup.data = { type: 'wall', id: Date.now() };
            }
             // Ajouter le groupe à la scène Two.js et à notre tableau de suivi
             if (currentGroup && currentShape) {
                elements.push({ group: currentGroup, shape: currentShape, data: currentGroup.data });
                two.add(currentGroup); // Ajouter le groupe à la scène principale
             } else {
                 currentGroup = null; // Nettoyer si la création a échoué
             }
        }

        function updateDrawing(currentX, currentY) {
            if (!currentShape || !isDrawing) return;
            const snappedX = snapValue(currentX);
            const snappedY = snapValue(currentY);

            if (currentShape instanceof Two.Rectangle) { // Vérifier le type Two.js
                const width = snappedX - startX;
                const height = snappedY - startY;
                // Mettre à jour la position et la taille du rectangle RELATIVEMENT au groupe
                currentShape.translation.set(width / 2, height / 2);
                currentShape.width = Math.abs(width);
                currentShape.height = Math.abs(height);
                // La position du GROUPE reste à startX, startY pendant le dessin
                // currentGroup.translation.set(startX, startY); // Déjà fait au start
            } else if (currentShape instanceof Two.Line) { // Vérifier le type Two.js
                // Mettre à jour la position du deuxième point de la ligne RELATIVEMENT au groupe
                currentShape.vertices[1].set(snappedX - startX, snappedY - startY);
                // La position du GROUPE reste à startX, startY
            }
             two.update(); // Mettre à jour l'affichage
        }

        function finishDrawing() {
            if (!currentShape || !currentGroup) return;
            isDrawing = false;

            let isValid = false;
            const MIN_SIZE = GRID_SIZE / 4; // Taille minimale pour valider

            if (currentShape instanceof Two.Rectangle && (currentShape.width >= MIN_SIZE || currentShape.height >= MIN_SIZE)) {
                isValid = true;
            } else if (currentShape instanceof Two.Line) {
                 const endXRelative = currentShape.vertices[1].x;
                 const endYRelative = currentShape.vertices[1].y;
                if (Math.sqrt(endXRelative * endXRelative + endYRelative * endYRelative) >= MIN_SIZE) {
                    isValid = true;
                }
            }

            if (!isValid) {
                const elementToRemove = elements.pop(); // Récupère le dernier élément ajouté
                if (elementToRemove) two.remove(elementToRemove.group); // Supprime le groupe de la scène
                showToast('Dessin trop petit, annulé.', 'error');
            } else {
                 // Finaliser la position du groupe après le dessin
                 if (currentShape instanceof Two.Rectangle) {
                     // Recalculer la position finale du groupe basée sur le centre final du rectangle snappé
                     const finalSnappedX = snapValue(currentShape.vertices[1].x + startX);
                     const finalSnappedY = snapValue(currentShape.vertices[1].y + startY);
                     const finalStartX = Math.min(startX, finalSnappedX);
                     const finalStartY = Math.min(startY, finalSnappedY);
                     const finalWidth = Math.abs(finalSnappedX - startX);
                     const finalHeight = Math.abs(finalSnappedY - startY);

                     currentGroup.translation.set(finalStartX + finalWidth / 2, finalStartY + finalHeight / 2);
                     // Réajuster la translation de la forme à 0,0 et la taille
                     currentShape.translation.set(0, 0);
                     currentShape.width = finalWidth;
                     currentShape.height = finalHeight;

                 } else if (currentShape instanceof Two.Line) {
                      // Finaliser la position du deuxième vertex
                     const finalSnappedX = snapValue(currentShape.vertices[1].x + startX);
                     const finalSnappedY = snapValue(currentShape.vertices[1].y + startY);
                     currentShape.vertices[1].set(finalSnappedX - startX, finalSnappedY - startY);
                     // Le groupe reste à startX, startY.
                 }

                 showToast('Forme ajoutée !');
            }
            currentShape = null;
            currentGroup = null;
            two.update();
        }


        function createSymbol(x, y) {
            const snappedX = snapValue(x);
            const snappedY = snapValue(y);
            const toolType = currentTool.split('_')[1]; // door, window
            const group = two.makeGroup(); // Utiliser un groupe
            let symbolShape;
            let shapeData = { type: toolType, id: Date.now() };

            if (toolType === 'door') {
                symbolShape = two.makeRectangle(0, 0, 15, GRID_SIZE * 0.8); // Dessiné à 0,0
                symbolShape.fill = getComputedStyle(document.documentElement).getPropertyValue('--color-door').trim();
                symbolShape.noStroke();
                shapeData.label = "Porte";
            } else if (toolType === 'window') {
                symbolShape = two.makeRectangle(0, 0, GRID_SIZE * 0.8, 10); // Dessiné à 0,0
                symbolShape.fill = getComputedStyle(document.documentElement).getPropertyValue('--color-window').trim();
                symbolShape.noStroke();
                shapeData.label = "Fenêtre";
            }

            if (symbolShape) {
                group.add(symbolShape);
                group.translation.set(snappedX, snappedY); // Positionner le groupe
                group.data = shapeData; // Attacher les données au groupe
                elements.push({ group: group, shape: symbolShape, data: shapeData });
                two.add(group); // Ajouter le groupe à la scène
                showToast(`${shapeData.label} ajoutée !`);
                two.update();
                // Optionnel: Revenir à l'outil de déplacement
                switchTool('move');
            }
        }

        // --- Sélection, Déplacement, Suppression ---
        let isMovingShape = false;
        let moveOffsetX = 0, moveOffsetY = 0;

        function handleInteractionStart(x, y) {
             const clickedElement = findElementAt(x, y);

             if (currentTool === 'move' || currentTool === 'delete') {
                 if (clickedElement) {
                     if (currentTool === 'delete') {
                         deleteElement(clickedElement);
                         selectedElement = null; // Désélectionner après suppression
                     } else if (currentTool === 'move') {
                         selectedElement = clickedElement; // Stocke l'objet { group, shape, data }
                         highlightSelection(selectedElement.group);
                         isMovingShape = true;
                         // Calculer l'offset par rapport au centre de translation du groupe
                         moveOffsetX = x - selectedElement.group.translation.x;
                         moveOffsetY = y - selectedElement.group.translation.y;
                         drawingArea.style.cursor = 'grabbing';
                     }
                 } else {
                     deselectShape(); // Clic dans le vide désélectionne
                 }
             }
        }


        function handleInteractionMove(x, y) {
             if (isMovingShape && selectedElement) {
                 // Appliquer le déplacement au groupe entier
                 const newX = x - moveOffsetX;
                 const newY = y - moveOffsetY;
                 selectedElement.group.translation.set(newX, newY);
                 two.update(); // Mettre à jour pour voir le déplacement en temps réel
             }
        }

        function handleInteractionEnd() {
            if (isMovingShape && selectedElement) {
                // Appliquer le snap à la position finale du groupe
                selectedElement.group.translation.x = snapValue(selectedElement.group.translation.x);
                selectedElement.group.translation.y = snapValue(selectedElement.group.translation.y);
                drawingArea.style.cursor = 'grab'; // Revenir au curseur de déplacement normal
                isMovingShape = false; // Terminer le déplacement
                two.update(); // Mettre à jour la position finale snappée
            }
        }


        function findElementAt(x, y) {
             // Convertir les coordonnées de l'événement en coordonnées Two.js (correction: pas besoin de re-multiplier par scale ici)
            // const svgPoint = two.renderer.domElement.createSVGPoint();
            // svgPoint.x = x * two.scale + two.translation.x; // Incorrect
            // svgPoint.y = y * two.scale + two.translation.y; // Incorrect

             const tolerance = 10 / two.scale; // Tolérance augmentée, ajustée au zoom

             // Parcourt les éléments à l'envers (les plus récents en premier)
            for (let i = elements.length - 1; i >= 0; i--) {
                const element = elements[i];
                if (!element || !element.group || !element.shape) continue; // Vérifier si l'élément est valide

                 const bbox = element.group.getBoundingClientRect(true); // Obtenir BBox globale du groupe dans l'espace monde Two.js

                 // Vérifier si le point (x, y - déjà dans l'espace monde) est DANS la BBox avec tolérance
                 if (x >= bbox.left - tolerance && x <= bbox.right + tolerance &&
                     y >= bbox.top - tolerance && y <= bbox.bottom + tolerance)
                 {
                      // Vérification plus fine pour les lignes (distance point-segment)
                     if (element.shape instanceof Two.Line) {
                         const p1 = element.group.translation.clone().add(element.shape.vertices[0]); // Coords absolues du point 1
                         const p2 = element.group.translation.clone().add(element.shape.vertices[1]); // Coords absolues du point 2
                         if (pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y) <= tolerance + (element.shape.linewidth / (2 * two.scale))) { // Ajuster linewidth par scale
                             return element;
                         }
                     } else {
                         // Pour rectangles et symboles, la BBox est suffisante pour cette application simple
                         return element;
                     }
                 }
            }
            return null; // Aucun élément trouvé
        }

        // Helper: calcule la distance minimale d'un point à un segment de ligne
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            if (l2 === 0) return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1)); // Segment de longueur nulle
            let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
            t = Math.max(0, Math.min(1, t)); // Clamper t entre 0 et 1
            const projX = x1 + t * (x2 - x1);
            const projY = y1 + t * (y2 - y1);
            return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
        }


        function highlightSelection(group) {
             deselectShape(); // Enlève la surbrillance précédente si elle existe
             if (group) {
                selectedElement = elements.find(el => el.group === group); // Retrouve l'objet élément complet
                if (!selectedElement) return;

                // Applique un style visuel
                group.children.forEach(child => {
                    // Sauvegarde la couleur et l'épaisseur originales si pas déjà fait
                    if (child._originalStroke === undefined) child._originalStroke = child.stroke;
                    if (child._originalLinewidth === undefined) child._originalLinewidth = child.linewidth;
                    if (child._originalFill === undefined) child._originalFill = child.fill; // Sauvegarder aussi le remplissage

                    // Appliquer le style de sélection (contour bleu épais)
                    child.stroke = 'var(--accent-active)';
                    child.linewidth = (child._originalLinewidth || 1) + 3 / two.scale; // Épaissir le trait, ajusté au zoom
                    child.fill = child.fill === 'none' || child.fill === 'transparent' ? 'none' : child.fill + '80'; // Rendre semi-transparent si rempli

                     // Gérer les symboles qui n'ont pas de stroke initial
                     if (!child._originalStroke && child.fill && child.fill !== 'transparent' && child.fill !== 'none') {
                        child.stroke = 'var(--accent-active)';
                        child.linewidth = 3 / two.scale;
                     }
                });
                two.update();
             }
        }

        function deselectShape() {
            if (selectedElement) {
                 // Rétablit le style original en utilisant les valeurs sauvegardées
                 selectedElement.group.children.forEach(child => {
                     // Rétablir stroke
                     if (child._originalStroke !== undefined) {
                         child.stroke = child._originalStroke;
                     } else if (child.fill && child.fill !== 'transparent' && child.fill !== 'none' && (selectedElement.data.type === 'door' || selectedElement.data.type === 'window')) {
                          child.noStroke(); // Rétablir noStroke pour les symboles si pas de contour original
                     } else {
                         child.stroke = getComputedStyle(document.documentElement).getPropertyValue('--color-line').trim(); // Fallback pour les murs/pièces
                     }

                     // Rétablir linewidth
                     if (child._originalLinewidth !== undefined) {
                         child.linewidth = child._originalLinewidth;
                     } else {
                         // Rétablir linewidth par défaut basé sur le type
                         if (selectedElement.data.type === 'wall') child.linewidth = 5;
                         else if (selectedElement.data.type === 'room') child.linewidth = 2;
                         else child.linewidth = 1; // Ou 0 si noStroke était actif
                     }
                    // Rétablir fill
                     if(child._originalFill !== undefined) {
                         child.fill = child._originalFill;
                     }


                     // Nettoyer les propriétés sauvegardées
                     delete child._originalStroke;
                     delete child._originalLinewidth;
                     delete child._originalFill;
                });
                selectedElement = null;
                two.update();
            }
        }


        function deleteElement(elementToDelete) {
            if (!elementToDelete || !elementToDelete.group) return;
            two.remove(elementToDelete.group); // Supprime le groupe de la scène Two.js
            elements = elements.filter(el => el.group !== elementToDelete.group); // Met à jour le tableau
            showToast('Élément supprimé', 'error');
            two.update(); // Met à jour l'affichage
        }

        // --- Exportation ---
        window.exportCanvas = function(format) {
            const svgEl = two.renderer.domElement;
            const filename = "plan_maison_simple";

            // Calculer la BBox de tous les éléments pour cadrer l'export
            two.update(); // Assure que tout est à jour
            const groupBounds = two.scene.getBoundingClientRect(true); // true pour récursif

            if (!groupBounds || groupBounds.width === 0 || groupBounds.height === 0) {
                 showToast("Rien à exporter.", "error");
                 return;
            }

            // Ajouter une marge pour l'exportation
            const margin = GRID_SIZE / 2; // Marge de demi-grille
            const exportX = groupBounds.left - margin;
            const exportY = groupBounds.top - margin;
            const exportWidth = groupBounds.width + margin * 2;
            const exportHeight = groupBounds.height + margin * 2;

            if (format === 'png') {
                 // 1. Cloner le SVG et appliquer la viewBox
                const svgClone = svgEl.cloneNode(true);
                svgClone.setAttribute('viewBox', `${exportX} ${exportY} ${exportWidth} ${exportHeight}`);
                // Définir width/height pour la rastérisation
                svgClone.setAttribute('width', exportWidth);
                svgClone.setAttribute('height', exportHeight);

                 // 2. Créer une URL Blob pour l'image SVG
                const svgString = new XMLSerializer().serializeToString(svgClone);
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                 // 3. Charger l'URL Blob dans une image
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    // Augmenter la résolution pour une meilleure qualité PNG (facteur 2x)
                    const scaleFactor = 2;
                    canvas.width = exportWidth * scaleFactor;
                    canvas.height = exportHeight * scaleFactor;
                    const ctx = canvas.getContext('2d');

                    // Fond blanc pour le PNG
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-canvas').trim(); // Utilise la couleur du fond du canvas
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Dessiner l'image SVG sur le canvas avec la mise à l'échelle
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                    URL.revokeObjectURL(url); // Libérer l'URL blob SVG

                    // 4. Exporter le canvas en PNG
                    canvas.toBlob((pngBlob) => {
                        if (pngBlob) {
                            const pngUrl = URL.createObjectURL(pngBlob);
                            downloadURI(pngUrl, `${filename}.png`);
                            URL.revokeObjectURL(pngUrl); // Libérer l'URL blob PNG
                            showToast('PNG exporté !');
                        } else {
                             showToast("Erreur lors de la création du PNG.", "error");
                        }
                    }, 'image/png');
                };
                img.onerror = () => {
                   URL.revokeObjectURL(url);
                   showToast("Erreur lors du chargement du SVG pour l'export PNG.", "error");
                };
                img.src = url;

            } else { // Fallback pour SVG (ou si format inconnu)
                 const svgClone = svgEl.cloneNode(true);
                 svgClone.setAttribute('viewBox', `${exportX} ${exportY} ${exportWidth} ${exportHeight}`);
                 svgClone.setAttribute('width', exportWidth);
                 svgClone.setAttribute('height', exportHeight);
                 const svgData = new XMLSerializer().serializeToString(svgClone);
                 const blob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
                 const url = URL.createObjectURL(blob);
                 downloadURI(url, `${filename}.svg`);
                 URL.revokeObjectURL(url);
                 showToast('SVG exporté !');
            }
        }

        // Fonction helper pour déclencher le téléchargement
        function downloadURI(uri, name) {
            const link = document.createElement("a");
            link.download = name;
            link.href = uri;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }


        // --- Gestion des événements du Canvas (souris et toucher unique) ---
        let interactionStartX, interactionStartY;
        let isInteracting = false; // Flag général pour mousedown/touchstart

        function handleCanvasDown(e) {
            // Empêcher le comportement par défaut (scroll, zoom natif...)
            if (e.type === 'touchstart') e.preventDefault();

            // Ignorer si interaction à plusieurs doigts (géré par Hammer) ou clic non gauche
            if ((e.touches && e.touches.length > 1) || (e.pointerType === 'touch' && !e.isPrimary) || (e.button && e.button !== 0)) {
                 isInteracting = false; // Assurer que le flag est bien à false
                 return;
            }

            isInteracting = true;
            const pos = getEventPos(e);
            interactionStartX = pos.x;
            interactionStartY = pos.y;

            if (currentTool.startsWith('draw')) {
                // S'assurer qu'on ne déplace pas une forme existante si on clique dessus
                const clickedElement = findElementAt(interactionStartX, interactionStartY);
                 if (clickedElement && currentTool !== 'delete') {
                     // Si on clique sur une forme existante, on initie un déplacement plutôt qu'un dessin
                     switchTool('move'); // Passer en mode déplacement
                     handleInteractionStart(interactionStartX, interactionStartY); // Traiter comme début de déplacement
                 } else {
                    startDrawing(interactionStartX, interactionStartY);
                 }
            } else if (currentTool.startsWith('symbol')) {
                 createSymbol(interactionStartX, interactionStartY);
                 // On reste sur l'outil symbole
            } else {
                handleInteractionStart(interactionStartX, interactionStartY); // Gère sélection/début déplacement/suppression
            }
        }

        function handleCanvasMove(e) {
             if (!isInteracting) return;
             // Empêcher le comportement par défaut si toucher
             if (e.type === 'touchmove') e.preventDefault();

             const pos = getEventPos(e);

             if (isDrawing) {
                 updateDrawing(pos.x, pos.y);
             } else if (isMovingShape) {
                 handleInteractionMove(pos.x, pos.y);
             }
        }

        function handleCanvasUp(e) {
            // Gérer le cas où l'interaction était > 1 doigt (Pan/Zoom) et on relâche
            if (!isInteracting) return;

            if (isDrawing) {
                finishDrawing();
            } else if (isMovingShape) {
                handleInteractionEnd();
            }
            isInteracting = false; // Réinitialiser l'état d'interaction après mouseup/touchend
        }

        // Attacher les écouteurs d'événements
        drawingArea.addEventListener('mousedown', handleCanvasDown);
        drawingArea.addEventListener('mousemove', handleCanvasMove);
        drawingArea.addEventListener('mouseup', handleCanvasUp);
        drawingArea.addEventListener('mouseleave', handleCanvasUp); // Considérer mouseleave comme mouseup pour terminer l'action

        drawingArea.addEventListener('touchstart', handleCanvasDown, { passive: false });
        drawingArea.addEventListener('touchmove', handleCanvasMove, { passive: false });
        drawingArea.addEventListener('touchend', handleCanvasUp);
        drawingArea.addEventListener('touchcancel', handleCanvasUp); // Gérer l'annulation


        // Initialiser l'application après le chargement du DOM
        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>
</body>
</html>

