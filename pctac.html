<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="icon" href="favicon.ico" sizes="any" type="image/png">
    <link rel="icon" href="favicon.ico" type="image/svg+xml">
    <link rel="apple-touch-icon" href="favicon.ico">
    <title>PC Tac</title>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Oswald:wght@300;400;500&family=Saira+Stencil+One&display=swap" rel="stylesheet">
    <!-- Icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />

    <!-- Librairies Externes (QR Code Gen + Scanner + PDF + WebRTC) -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5-qrcode/2.3.8/html5-qrcode.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <style>
        /* --- VARIABLES & THEME MODERNISÉS --- */
        :root {
            /* Base Colors */
            --bg-body: #050505;
            --bg-glass: rgba(22, 22, 25, 0.7);
            --bg-glass-heavy: rgba(15, 15, 20, 0.95);
            --bg-input: rgba(0, 0, 0, 0.4);
            --border-glass: rgba(255, 255, 255, 0.08);
            
            /* Typography */
            --font-ui: 'Oswald', sans-serif;
            --font-data: 'JetBrains Mono', monospace;
            --font-title: 'Saira Stencil One', cursive;

            /* Interactive Colors */
            --accent-blue: #3b82f6;
            --accent-glow: rgba(59, 130, 246, 0.3);
            --text-main: #e0e0e0;
            --text-muted: #94a3b8;

            /* Status Colors (Legacy preserved) */
            --danger-red: #ef4444; 
            --civil-yellow: #eab308;
            --inter-blue: #3b82f6;
            --ao-green: #22c55e;
            --trash-color: #64748b;

            /* Spacing */
            --radius-md: 12px;
            --radius-sm: 6px;
            
            /* WebRTC Status */
            --color-connected: var(--ao-green);
            --color-host: var(--inter-blue);
            --color-disconnected: var(--danger-red);
        }

        body.light-mode {
            --bg-body: #f1f5f9;
            --bg-glass: rgba(255, 255, 255, 0.85);
            --bg-glass-heavy: #ffffff;
            --bg-input: rgba(255, 255, 255, 0.6);
            --border-glass: rgba(0, 0, 0, 0.1);
            --text-main: #1e293b;
            --text-muted: #64748b;
            --accent-blue: #0f4c9c;
        }

        /* --- RESET & LAYOUT --- */
        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            font-family: var(--font-ui);
            background-color: var(--bg-body);
            color: var(--text-main);
            /* Texture tactique en fond */
            background-image: 
                linear-gradient(rgba(59, 130, 246, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(59, 130, 246, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            min-height: 100vh;
            padding: 20px 10px 100px 10px;
            transition: background 0.3s ease;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        /* --- HEADER & TITRES --- */
        h1 {
            font-family: var(--font-title);
            font-size: 2.5em;
            color: var(--accent-blue);
            text-align: center;
            text-shadow: 0 0 20px var(--accent-glow);
            letter-spacing: 2px;
            margin-bottom: 25px;
        }

        /* Input Titre Intervention */
        #intervention-title-container {
            background: var(--bg-glass);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-glass);
            border-radius: var(--radius-md);
            padding: 15px;
            margin-bottom: 20px;
            display: flex; align-items: center; gap: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #intervention-title-container label { margin: 0; white-space: nowrap; color: var(--accent-blue); }
        #intervention_title_input {
            border: none; background: transparent; border-bottom: 1px solid transparent;
            font-size: 1.1em; padding: 5px; color: var(--text-main);
            flex-grow: 1;
        }
        #intervention_title_input:focus { border-bottom-color: var(--accent-blue); box-shadow: none; }
        
        /* WebRTC Status Box - Maintenant cliquable */
        #webrtc-status-box {
            font-size: 0.8rem;
            font-family: var(--font-data);
            padding: 5px 10px;
            border-radius: var(--radius-sm);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
            text-transform: uppercase;
            transition: background 0.3s, transform 0.1s;
            cursor: pointer; /* Indique que c'est un bouton */
        }
        #webrtc-status-box:active { transform: scale(0.98); }

        .status-disconnected { background: rgba(239, 68, 68, 0.2); color: var(--danger-red); border: 1px solid var(--danger-red); }
        .status-host { background: rgba(59, 130, 246, 0.2); color: var(--color-host); border: 1px solid var(--color-host); }
        .status-connected { background: rgba(34, 197, 94, 0.2); color: var(--color-connected); border: 1px solid var(--color-connected); }
        .status-connecting { background: rgba(234, 179, 8, 0.2); color: var(--civil-yellow); border: 1px solid var(--civil-yellow); animation: pulse-yellow 1s infinite; }
        @keyframes pulse-yellow { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }


        /* --- FORMULAIRE --- */
        .log-entry-form {
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-glass);
            border-radius: var(--radius-md);
            padding: 20px;
            margin-bottom: 25px;
            position: relative;
            transition: opacity 0.3s; /* Pour l'effet de masquage en mode client */
        }

        .form-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; border-bottom: 1px solid var(--border-glass); padding-bottom: 10px;
        }
        .form-header h3 { margin: 0; color: var(--text-muted); font-size: 1.2em; display: flex; align-items: center; gap: 8px; }

        /* Toggle Buttons */
        #pax_mode_toggle_container { display: flex; background: rgba(0,0,0,0.2); padding: 3px; border-radius: 6px; }
        .mode-toggle-btn {
            background: transparent; border: none; color: var(--text-muted);
            padding: 6px 12px; border-radius: 4px; cursor: pointer; font-family: var(--font-ui); font-weight: 500;
            transition: all 0.2s;
        }
        .mode-toggle-btn.active { background: var(--accent-blue); color: white; box-shadow: 0 2px 5px var(--accent-glow); }

        /* Grid Layout */
        .form-row.main-fields {
            display: grid; grid-template-columns: 100px 1fr 1fr 1fr; gap: 15px; align-items: start;
        }
        .form-row.text-fields { margin-top: 15px; }

        label { color: var(--text-muted); font-size: 0.75em; text-transform: uppercase; font-weight: bold; margin-bottom: 5px; display: block; }
        
        input, textarea, select {
            width: 100%; background: var(--bg-input); border: 1px solid var(--border-glass);
            border-radius: var(--radius-sm); padding: 12px; color: var(--text-main);
            font-family: var(--font-data); font-size: 0.95em; transition: all 0.2s;
        }
        input:focus, textarea:focus { border-color: var(--accent-blue); background: rgba(0,0,0,0.5); }
        
        #heure_input { text-align: center; color: var(--accent-blue); font-weight: bold; }

        /* Pax Selectors */
        .pax-select { display: flex; gap: 8px; flex-wrap: wrap; }
        .pax-select-option {
            flex: 1; padding: 10px; background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-glass); border-radius: var(--radius-sm);
            cursor: pointer; text-align: center; font-size: 0.9em; transition: all 0.2s;
            min-width: 70px;
        }
        .pax-select-option.selected { transform: scale(1.05); border-color: transparent; box-shadow: 0 4px 10px rgba(0,0,0,0.3); opacity: 1; }
        
        /* Couleurs Chips */
        .pax-select-option[data-pax="Adversaire"].selected { background: var(--danger-red); color: white; }
        .pax-select-option[data-pax="Otage"].selected { background: var(--civil-yellow); color: black; }
        .pax-select-option[data-pax="Inter"].selected { background: var(--inter-blue); color: white; }
        .pax-select-option[data-pax="AO"].selected { background: var(--ao-green); color: black; }

        /* Free Mode Colors */
        #free_mode_options { background: rgba(255,255,255,0.03); padding: 10px; border-radius: var(--radius-sm); }
        .color-palette { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; justify-content: center; }
        .color-swatch { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: transform 0.2s; }
        .color-swatch.selected { border-color: white; transform: scale(1.2); }

        /* Bouton Ajouter */
        .add-log-btn {
            width: 100%; margin-top: 20px; padding: 14px;
            background: var(--accent-blue); color: white; border: none; border-radius: var(--radius-sm);
            font-size: 1.1em; text-transform: uppercase; letter-spacing: 1px; font-weight: bold;
            cursor: pointer; display: flex; justify-content: center; align-items: center; gap: 8px;
            box-shadow: 0 4px 12px var(--accent-glow); transition: all 0.2s;
        }
        .add-log-btn:hover { filter: brightness(1.1); transform: translateY(-1px); }

        /* --- TABLEAU / LISTE --- */
        #logTableContainer {
            background: var(--bg-glass); border: 1px solid var(--border-glass);
            border-radius: var(--radius-md); overflow: hidden; margin-top: 20px;
        }

        .sort-button {
            width: 100%; padding: 10px; background: rgba(0,0,0,0.2); color: var(--text-muted);
            border: none; border-bottom: 1px solid var(--border-glass); cursor: pointer;
            font-size: 0.8em; text-transform: uppercase; display: flex; justify-content: center; gap: 5px;
        }

        table { width: 100%; border-collapse: collapse; }
        th { text-align: left; padding: 15px; color: var(--text-muted); font-size: 0.75em; text-transform: uppercase; background: rgba(0,0,0,0.2); }
        td { padding: 12px 15px; border-bottom: 1px solid var(--border-glass); vertical-align: middle; }
        
        .heure-cell-text { font-family: var(--font-data); color: var(--accent-blue); font-weight: bold; }
        .pax-cell { padding: 4px 10px; border-radius: 4px; font-size: 0.85em; font-weight: bold; text-transform: uppercase; }
        
        .delete-btn { background: none; border: none; color: var(--trash-color); cursor: pointer; transition: color 0.2s; opacity: 0.6; }
        .delete-btn:hover { color: var(--danger-red); opacity: 1; }

        /* --- DOCK MENU --- */
        .dock-menu {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--bg-glass-heavy); backdrop-filter: blur(15px);
            border: 1px solid var(--border-glass); border-radius: 30px;
            padding: 8px 15px; display: flex; align-items: center; gap: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6); z-index: 1000;
            transition: width 0.3s, padding 0.3s;
            max-width: 90vw; width: auto; overflow-x: auto; scrollbar-width: none;
        }
        .dock-menu::-webkit-scrollbar { display: none; } 

        .dock-menu.collapsed { width: 50px; height: 50px; padding: 0; justify-content: center; overflow: hidden; border-radius: 50%; }
        .dock-menu.collapsed .dock-menu-item:not(#dockToggleBtn) { display: none; }

        .dock-menu-item {
            width: 42px; height: 42px; border-radius: 50%; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
            color: var(--text-muted); text-decoration: none; cursor: pointer;
            transition: all 0.2s;
        }
        .dock-menu-item:hover { color: var(--text-main); background: rgba(255,255,255,0.1); }
        #dockToggleBtn { color: var(--accent-blue); }
        #transferDockBtn { color: var(--ao-green); }

        /* --- MODALES --- */
        .custom-modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 2000; display: none; backdrop-filter: blur(5px); }
        .custom-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: var(--bg-body); border: 1px solid var(--border-glass); border-radius: var(--radius-md);
            padding: 25px; width: 95%; max-width: 450px; z-index: 2001; display: none;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5); text-align: center;
            max-height: 90vh; overflow-y: auto;
        }
        .modal-buttons { display: flex; gap: 10px; margin-top: 20px; }
        .modal-buttons button { flex: 1; padding: 12px; border: none; border-radius: var(--radius-sm); cursor: pointer; font-weight: bold; }
        #confirmResetBtn, #confirmDisconnectBtn { background: var(--danger-red); color: white; }
        #cancelResetBtn, #modalMessageBtn, #cancelDisconnectBtn, #closeWebRtcModalBtn { background: rgba(255,255,255,0.1); color: var(--text-main); }
        
        /* Modification pour la visibilité du bouton Fermer */
        #closeWebRtcModalBtn {
            background: var(--text-muted); /* Couleur neutre */
            color: white; /* Texte blanc, visible en light mode aussi */
            border: none;
        }
        body.light-mode #closeWebRtcModalBtn {
            background: var(--text-muted); /* Reste visible sur fond blanc */
            color: var(--text-main); /* Texte sombre */
        }
        
        /* Modal WebRTC - Login */
        .webrtc-menu-item {
            width: 100%; padding: 20px; margin-bottom: 15px;
            background: var(--bg-glass); border: 1px solid var(--border-glass);
            border-radius: var(--radius-md); color: var(--text-main);
            font-weight: 700; text-align: left; font-size: 1.1rem;
            display: flex; align-items: center; gap: 15px; cursor: pointer;
            transition: background 0.2s;
        }
        .webrtc-menu-item:active { background: var(--bg-glass-heavy); }
        .webrtc-menu-item.action { justify-content: center; background: var(--accent-blue); color: white; border: none; }
        .webrtc-input {
            width: 100%; background: var(--bg-input); border: 1px solid var(--border-glass);
            border-radius: var(--radius-sm); padding: 12px; color: var(--text-main);
            font-family: var(--font-data); font-size: 0.95em; transition: all 0.2s; margin-top: 10px;
        }
        .webrtc-input:focus { border-color: var(--accent-blue); background: rgba(0,0,0,0.5); }
        .qr-code-region-sm { 
            background: white; padding: 15px; border-radius: var(--radius-sm); 
            display: inline-block; max-width: 100%;
        }

        /* QR Scanner pour la connexion */
        #qr-scanner-region {
            width: 256px; height: 256px; margin: 20px auto; /* Taille demandée */
            border: 2px solid var(--accent-blue);
            border-radius: var(--radius-sm); overflow: hidden; 
            background: black; 
            display: none; /* Caché par défaut */
        }
        .qr-scan-placeholder {
            color: var(--text-muted); padding: 50px;
        }
        
        /* Raccourcir le statut client sur mobile */
        @media (max-width: 768px) {
            #webrtc-status-box.status-connected {
                width: auto;
                max-width: 120px;
            }
            #webrtc-status-box.status-connected .material-symbols-outlined {
                order: 2;
            }
            #webrtc-status-box.status-connected #webrtc-status-text {
                font-size: 0.9em;
                order: 1;
                margin-right: 5px;
            }
        }


        /* --- TRANSFERT MODAL STYLES (Conservé pour QR séquentiel local) --- */
        .transfer-tabs { display: flex; gap: 10px; margin-bottom: 20px; }
        .transfer-tab-btn {
            flex: 1; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid var(--border-glass);
            color: var(--text-muted); cursor: pointer; border-radius: var(--radius-sm); font-family: var(--font-ui);
        }
        .transfer-tab-btn.active { background: var(--accent-blue); color: white; border-color: transparent; }
        
        .transfer-content { display: none; }
        .transfer-content.active { display: block; }
        
        #qrcode-container {
            background: white; padding: 20px; border-radius: var(--radius-sm); margin: 20px auto;
            display: inline-block; max-width: 100%;
        }
        #qrcode-container img { margin: 0 auto; display: block; max-width: 100%; height: auto; }
        
        #qr-reader {
            width: 100%; margin: 20px auto; border: 2px solid var(--accent-blue);
            border-radius: var(--radius-sm); overflow: hidden; background: black;
        }

        /* Nav controls for QR */
        #qr-nav-controls {
            display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 15px;
            background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px;
        }
        .qr-nav-btn {
            background: rgba(255,255,255,0.1); border: 1px solid var(--border-glass); color: var(--text-main);
            width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer;
        }
        .qr-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .qr-nav-btn:hover:not(:disabled) { background: var(--accent-blue); }
        #qr-counter { font-family: var(--font-data); font-weight: bold; font-size: 1.1em; min-width: 60px; }

        /* Toast */
        #toast-container {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%) translateY(-100px);
            /* Utilisation d'un background par défaut (pour le message d'erreur) */
            background: rgba(34, 197, 94, 0.9); backdrop-filter: blur(5px);
            color: white; padding: 12px 24px; border-radius: 30px;
            font-family: var(--font-ui); box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 3000; transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex; align-items: center; gap: 10px; font-weight: 500;
        }
        #toast-container.show { transform: translateX(-50%) translateY(0); }

        /* --- MOBILE RESPONSIVE (Cards) --- */
        @media (max-width: 768px) {
            .container { padding: 10px; }
            h1 { font-size: 2em; }
            
            /* Amélioration de la lisibilité des logs en mode client/lecture seule */
            #logTableContainer { 
                /* Assure que le conteneur est visible même si le formulaire est masqué */
                margin-top: 5px; 
            }
            .form-row.main-fields { display: flex; flex-direction: column; gap: 15px; }
            .form-row.main-fields > div:nth-child(1) { order: 1; display: flex; align-items: center; gap: 10px; }
            .form-row.main-fields > div:nth-child(1) input { width: 120px; }
            .form-row.main-fields > div:nth-child(2) { order: 2; }
            .form-row.main-fields > div:nth-child(3) { order: 3; }
            .form-row.main-fields > div:nth-child(4) { order: 4; }

            table, thead, tbody, th, td, tr { display: block; }
            thead { display: none; }
            
            tr {
                background: rgba(255,255,255,0.03);
                border: 1px solid var(--border-glass);
                border-radius: var(--radius-md);
                margin-bottom: 15px;
                padding: 15px;
                position: relative;
            }

            td {
                padding: 6px 0; border: none;
                display: flex; justify-content: space-between; align-items: center;
                text-align: right;
            }

            td:nth-of-type(1) { justify-content: flex-start; font-size: 1.1em; border-bottom: 1px solid var(--border-glass); padding-bottom: 10px; margin-bottom: 5px; }
            td:nth-of-type(1) .delete-btn { display: none; }
            td:nth-of-type(2)::before { content: "Pax"; color: var(--text-muted); font-size: 0.75em; margin-right: 10px; }
            td:nth-of-type(3)::before { content: "Lieu"; color: var(--text-muted); font-size: 0.75em; margin-right: 10px; }
            td:nth-of-type(4)::before { content: "Ouvrant"; color: var(--text-muted); font-size: 0.75em; margin-right: 10px; }
            td:nth-of-type(5) { display: block; text-align: left; background: rgba(0,0,0,0.2); padding: 10px; margin-top: 10px; border-radius: 4px; color: var(--text-muted); font-style: italic; }
            td:nth-of-type(5)::before { content: "Notes"; display: block; font-size: 0.7em; margin-bottom: 4px; font-weight: bold; }

            .mobile-delete-btn {
                position: absolute; top: 15px; right: 15px;
                background: rgba(239, 68, 68, 0.15); color: var(--danger-red);
                border: none; border-radius: 4px; padding: 6px;
                display: block !important;
            }
        }
        
        .mobile-delete-btn { display: none; }
    </style>
</head>
<body class="dark-mode">
    <!-- INPUTS CACHÉS & MODALES -->
    <input type="file" id="jsonImportInput" accept=".json" style="display: none;">

    <div class="custom-modal-backdrop" id="modalBackdrop"></div>
    
    <!-- Toast Notification -->
    <div id="toast-container">
        <span class="material-symbols-outlined">check_circle</span>
        <span id="toast-message">Action effectuée</span>
    </div>

    <!-- Modal WebRTC - Connexion -->
    <div class="custom-modal" id="webrtcModal">
        <h3 style="color: var(--accent-blue); margin-bottom: 15px;">Partage en Direct (WebRTC)</h3>
        
        <!-- Vue CONNEXION/LOGIN -->
        <div id="webrtc-login-view">
             <p style="color: var(--text-muted); font-size: 0.9em; margin-bottom: 20px;">
                Mode Hôte pour créer une session de partage de log en temps réel.
             </p>
            <button class="webrtc-menu-item action" id="btn-create-host">
                <span class="material-symbols-outlined" style="font-size: 1.8rem;">add_circle</span>
                <div>Créer Session (Hôte)</div>
            </button>
            
            <div style="text-align: left; color: var(--text-muted); font-size: 0.8rem; margin-top: 20px; margin-bottom: 15px;">REJOINDRE (Client)</div>
            
            <div id="qr-scanner-region">
                 <div class="qr-scan-placeholder" style="text-align: center;">Scan QR Code en cours...</div>
            </div>
            
            <button class="webrtc-menu-item" id="btn-scan-qr" style="justify-content: center; margin-bottom: 15px;">
                <span class="material-symbols-outlined" style="font-size: 1.5rem;">qr_code_scanner</span>
                Scanner QR Code
            </button>
            
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <input type="text" id="input-join-id" class="webrtc-input" placeholder="ID CANAL..." style="margin: 0; margin-top: 0;">
                <button id="btn-paste-id" style="width: 60px; background: var(--bg-glass); border: 1px solid var(--border-glass); border-radius: var(--radius-md); color: white; cursor: pointer;">
                    <span class="material-symbols-outlined">content_paste</span>
                </button>
            </div>
            <button class="webrtc-menu-item action" id="btn-join-session" style="background: rgba(255,255,255,0.05); color: var(--text-main);">
                REJOINDRE SESSION
            </button>
        </div>
        
        <!-- Vue HÔTE ACTIF -->
        <div id="webrtc-host-view" style="display: none;">
            <p style="color: var(--color-host); font-weight: bold; margin-bottom: 10px;">SESSION HÔTE ACTIVE</p>
            <p style="color: var(--text-muted); font-size: 0.9em; margin-bottom: 15px;">Partagez cet ID ou QR Code pour connecter les clients.</p>
            <div class="qr-code-region-sm" id="qr-code-region"></div>
            <div id="session-id-display" style="margin-top: 15px; font-family: var(--font-data); color: var(--accent-blue); word-break: break-all;">ID: ...</div>
            <p id="peer-count-display" style="color: var(--text-muted); font-size: 0.8em; margin-top: 10px;">Clients connectés: 0</p>
        </div>
        
        <!-- Vue CLIENT ACTIF -->
        <div id="webrtc-client-view" style="display: none;">
            <p style="color: var(--color-connected); font-weight: bold; margin-bottom: 10px;">CONNECTÉ AU CANAL</p>
            <p style="color: var(--text-muted); font-size: 0.9em; margin-bottom: 15px;">Réception des logs en direct. Le journal n'est pas modifiable.</p>
            <div id="client-session-id-display" style="margin-top: 15px; font-family: var(--font-data); color: var(--accent-blue); word-break: break-all;">Canal: ...</div>
        </div>
        
        <div id="webrtc-active-controls" class="modal-buttons" style="margin-top: 30px;">
            <button id="disconnect-session-btn">Déconnecter</button>
            <button id="closeWebRtcModalBtn">Fermer</button>
        </div>
        
    </div>

    <!-- Modal Confirmation Déconnexion -->
    <div class="custom-modal" id="disconnectModal">
        <h3 style="color: var(--danger-red); margin-bottom: 10px;">Déconnexion WebRTC</h3>
        <p id="disconnectMessage" style="color: var(--text-main);">Confirmer la déconnexion de la session de partage ?</p>
        <div class="modal-buttons">
            <button id="confirmDisconnectBtn">Déconnecter</button>
            <button id="cancelDisconnectBtn">Annuler</button>
        </div>
    </div>
    
    <!-- Modal Reset -->
    <div class="custom-modal" id="resetModal">
        <h3 style="color: var(--accent-blue); margin-bottom: 10px;">Purge Système</h3>
        <p style="color: var(--text-main);">Confirmer la suppression totale du journal d'opération ?</p>
        <div class="modal-buttons">
            <button id="confirmResetBtn">Confirmer</button>
            <button id="cancelResetBtn">Annuler</button>
        </div>
    </div>
    
    <!-- Modal Message -->
    <div class="custom-modal" id="messageModal">
        <h3 id="modalMessageTitle" style="margin-bottom: 10px;">Message</h3>
        <p id="modalMessageContent" style="color: var(--text-main);"></p>
        <div class="modal-buttons">
            <button id="modalMessageBtn">OK</button>
        </div>
    </div>

    <!-- Modal Transfert (QR séquentiel local) -->
    <div class="custom-modal" id="transferModal">
        <h3 style="color: var(--accent-blue); margin-bottom: 15px;">Export/Import (QR Local)</h3>
        
        <div class="transfer-tabs">
            <button class="transfer-tab-btn active" data-tab="send">Exporter (QR Séquentiel)</button>
            <button class="transfer-tab-btn" data-tab="receive">Importer (Scan)</button>
        </div>
        
        <!-- Contenu Envoyer -->
        <div id="transfer-send" class="transfer-content active">
            <div id="qrcode-container"></div>
            
            <!-- Navigation QR Code -->
            <div id="qr-nav-controls" style="display: none;">
                <button class="qr-nav-btn" id="prevQrBtn"><span class="material-symbols-outlined">arrow_back</span></button>
                <span id="qr-counter">1/1</span>
                <button class="qr-nav-btn" id="nextQrBtn"><span class="material-symbols-outlined">arrow_forward</span></button>
            </div>
            
            <p id="qr-status-text" style="color: var(--text-muted); font-size: 0.85em; margin-top: 10px;"></p>
        </div>
        
        <!-- Contenu Recevoir -->
        <div id="transfer-receive" class="transfer-content">
            <div id="qr-reader"></div>
            <p style="color: var(--text-muted); font-size: 0.9em;">Scanner les QR codes séquentiellement.</p>
        </div>

        <div class="modal-buttons">
            <button id="closeTransferBtn" style="background: rgba(44, 119, 211, 0.885);">Terminer</button>
        </div>
    </div>
    
    <div class="container">
        <h1>PC TAC</h1>

        <div id="intervention-title-container">
            <label for="intervention_title_input"><span class="material-symbols-outlined" style="vertical-align:bottom; font-size:1.1em; margin-right:5px;">edit_document</span>Opération :</label>
            <input type="text" id="intervention_title_input" placeholder="Nom de l'intervention..." value="">
            <div id="webrtc-status-box" class="status-disconnected" title="Statut WebRTC" onclick="showDisconnectModal()">
                <span class="material-symbols-outlined" style="font-size: 1em;">sensors_off</span>
                <span id="webrtc-status-text">Déconnecté</span>
            </div>
        </div>
        
        <!-- Formulaire -->
        <form id="log-form" class="log-entry-form">
            <div class="form-header">
                <h3><span class="material-symbols-outlined">playlist_add</span> Nouvelle Entrée</h3>
                <div id="pax_mode_toggle_container">
                    <button type="button" class="mode-toggle-btn active" data-mode="standard">Standard</button>
                    <button type="button" class="mode-toggle-btn" data-mode="free">Libre</button>
                </div>
            </div>
            
            <div class="form-row main-fields">
                 <div>
                    <label for="heure_input">Heure</label>
                    <input type="time" id="heure_input" required value="">
                 </div>
                 
                 <div>
                    <label>Pax / Élément</label>
                    <div id="pax_select_wrapper_standard" class="pax-select-wrapper">
                        <div class="pax-select" id="pax_select_container">
                            <span class="pax-select-option" data-pax="Adversaire">Adversaire</span>
                            <span class="pax-select-option" data-pax="Otage">Otage</span>
                            <span class="pax-select-option" data-pax="Inter">Inter</span>
                            <span class="pax-select-option" data-pax="AO">AO</span>
                        </div>
                    </div>
                    <div id="pax_select_wrapper_free" class="pax-select-wrapper" style="display: none;">
                        <div id="free_mode_options">
                            <div class="color-palette" id="free_color_palette"></div>
                            <input type="text" id="free_pax_input" placeholder="Identifiant..." value="" />
                            <input type="hidden" id="free_color_input" value="#800000">
                         </div>
                    </div>
                    <input type="hidden" id="pax_input" required value="Adversaire">
                    <input type="hidden" id="pax_mode_input" value="standard">
                    <input type="hidden" id="pax_custom_color_input" value="#800000">
                 </div>
                 
                 <div>
                    <label for="lieu_input">Lieu / Zone</label>
                    <input type="text" id="lieu_input" list="lieu_history" placeholder="Ex: Salon..." value="">
                    <datalist id="lieu_history"></datalist>
                 </div>

                 <div>
                    <label for="fenetre_porte_input">Ouvrant</label>
                    <input type="text" id="fenetre_porte_input" list="fp_history" placeholder="Ex: Porte N..." value="">
                    <datalist id="fp_history"></datalist>
                 </div>
            </div>
            
            <div class="form-row text-fields">
                <div style="grid-column: span 1;">
                    <label for="remarques_input">Remarques & Détails</label>
                    <textarea id="remarques_input" rows="2" placeholder="Observations..."></textarea>
                </div>
            </div>

            <button type="submit" class="add-log-btn" id="addLogBtn">
                <span class="material-symbols-outlined">send</span> Ajouter au Journal
            </button>
        </form>

        <!-- Tableau -->
        <div id="logTableContainer">
            <button type="button" class="sort-button" id="sortTimeBtn">
                <span class="material-symbols-outlined">schedule</span> Trier Chronologie
            </button>
            <table id="logTable">
                <thead>
                    <tr>
                        <th style="width: 15%;">Heure</th>
                        <th style="width: 15%;">Pax</th>
                        <th style="width: 20%;">Lieu</th>
                        <th style="width: 20%;">Ouvrant</th>
                        <th style="width: 30%;">Remarques</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Généré par JS -->
                </tbody>
            </table>
        </div>
        
		<footer id="main-footer" style="text-align: center; margin-top: 30px; font-size: 0.7rem; color: var(--text-muted); opacity: 0.5;">
            PC Tac v3 &bull; G/Maheux
        </footer>
    </div>
    
    <!-- Dock Flottant -->
    <div class="dock-menu collapsed" id="dockMenu">

        <div class="dock-menu-item" id="dockToggleBtn"><span class="material-symbols-outlined">expand_less</span></div>
		<a href="index.html" class="dock-menu-item home-button">
        <span class="material-icons"> home </span>
        </a>
        <div class="dock-menu-item" id="webrtcDockBtn" title="WebRTC Live"><span class="material-symbols-outlined">sensors</span></div>
        <div class="dock-menu-item" id="transferDockBtn" title="Transfert QR Local"><span class="material-symbols-outlined">qr_code_2</span></div>
        
        <div class="dock-menu-item" id="exportJsonDockBtn"><span class="material-symbols-outlined">save</span></div>
        <div class="dock-menu-item" id="importJsonDockBtn"><span class="material-symbols-outlined">upload_file</span></div>
        <div class="dock-menu-item" id="darkModeToggle"><span class="material-symbols-outlined" id="darkModeIcon">nightlight</span></div>
        <div class="dock-menu-item" id="fullscreenToggle"><span class="material-symbols-outlined" id="fullscreenIcon">fullscreen</span></div>
        <div class="dock-menu-item" id="previewPdfDockBtn"><span class="material-symbols-outlined">picture_as_pdf</span></div>
        <div class="dock-menu-item" id="resetDataDockBtn"><span class="material-symbols-outlined" style="color: var(--danger-red);">delete_forever</span></div>
    </div>

    <!-- SCRIPT COMPLET -->
    <script>
        const LOCAL_STORAGE_KEY = 'pcTacLogData';
        const HISTORY_STORAGE_KEY = 'pcTacHistory';
        const TITLE_STORAGE_KEY = 'pcTacTitle';
        const WEBRTC_STORAGE_KEY = 'pcTacWebRTC';
        
        const RECONNECT_INTERVAL_MS = 5000; // Tentative de reconnexion toutes les 5s
        
        const FREE_MODE_COLORS = [
            { hex: '#800000', name: 'Bordeaux' }, { hex: '#B87333', name: 'Cuivre' },         
            { hex: '#FFDB58', name: 'Jaune Moutarde' }, { hex: '#A3D900', name: 'Vert Lime' },      
            { hex: '#00FFFF', name: 'Cyan' }, { hex: '#000080', name: 'Bleu Marine' },    
            { hex: '#FF69B4', name: 'Rose Vif' }, { hex: '#FF8C00', name: 'Orange Foncée' },  
            { hex: '#8A2BE2', name: 'Bleu Violet' }, { hex: '#008080', name: 'Sarcelle' },       
            { hex: '#C0C0C0', name: 'Argent' }, { hex: '#ffffff', name: 'Blanc' }           
        ];

        const PDF_PAX_COLORS = {
            'Adversaire': { text: 'Adversaire', color: '#be1b09', fontColor: '#ffffff' },
            'Otage': { text: 'Civil/Otage', color: '#f1c40f', fontColor: '#000000' }, 
            'Civil': { text: 'Civil/Otage', color: '#f1c40f', fontColor: '#000000' }, 
            'Inter': { text: 'Inter', color: '#3498db', fontColor: '#ffffff' },
            'AO': { text: 'AO', color: '#2ecc71', fontColor: '#000000' }
        };
        
        // --- CONSTANTES WEBRTC inspirées de comtac ---
        const PEER_CONFIG = { 
            debug: 0, // Passer à 2 pour le debug
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun.l.google.com:443' },
                    { urls: 'stun:stun.stunprotocol.org:80' }, 
                ],
                iceCandidatePoolSize: 5, 
            }
        };


        const logTableBody = document.querySelector('#logTable tbody');
        const logForm = document.getElementById('log-form');
        const heureInput = document.getElementById('heure_input');
        const paxInput = document.getElementById('pax_input');
        const paxModeInput = document.getElementById('pax_mode_input'); 
        const paxCustomColorInput = document.getElementById('pax_custom_color_input'); 
        const freePaxInput = document.getElementById('free_pax_input'); 
        const lieuInput = document.getElementById('lieu_input');
        const fenetrePorteInput = document.getElementById('fenetre_porte_input');
        const remarquesInput = document.getElementById('remarques_input');
        const paxSelectContainer = document.getElementById('pax_select_container');
        const previewPdfDockBtn = document.getElementById('previewPdfDockBtn');
        const resetDataDockBtn = document.getElementById('resetDataDockBtn');
        const jsonImportInput = document.getElementById('jsonImportInput'); 
        const exportJsonDockBtn = document.getElementById('exportJsonDockBtn'); 
        const importJsonDockBtn = document.getElementById('importJsonDockBtn'); 
        const lieuHistoryDatalist = document.getElementById('lieu_history');
        const fpHistorDatalist = document.getElementById('fp_history');
        const interventionTitleInput = document.getElementById('intervention_title_input');
        const sortTimeBtn = document.getElementById('sortTimeBtn');
        
        // --- Nouveaux éléments Transfert QR local ---
        const transferDockBtn = document.getElementById('transferDockBtn');
        const transferModal = document.getElementById('transferModal');
        const closeTransferBtn = document.getElementById('closeTransferBtn');
        const transferTabs = document.querySelectorAll('.transfer-tab-btn');
        let html5QrCodeLocal; // Renommé pour le scanner local
        let qrChunks = [];
        let currentQrIndex = 0;
        const QR_BATCH_SIZE = 8; // Nombre d'entrées par QR pour assurer la lisibilité

        // --- Nouveaux éléments WebRTC ---
        const webrtcDockBtn = document.getElementById('webrtcDockBtn');
        const webrtcModal = document.getElementById('webrtcModal');
        const closeWebRtcModalBtn = document.getElementById('closeWebRtcModalBtn');
        const webrtcStatusBox = document.getElementById('webrtc-status-box');
        const webrtcStatusText = document.getElementById('webrtc-status-text');
        const webrtcStatusIcon = webrtcStatusBox.querySelector('.material-symbols-outlined');
        const webrtcScannerRegion = document.getElementById('qr-scanner-region'); // Nouvelle zone de scan
        const btnScanQr = document.getElementById('btn-scan-qr');
        let html5QrCodeWebRtc = null; // Scanner spécifique pour la connexion WebRTC
        
        let isTimeInputManuallyChanged = false;
        let paxColorMap = {}; 
        let colorPaxMap = {};

        // ----------------------------------------------------
        // --- DÉBUT MODULE PEERJS (WEBRTC) ---
        // ----------------------------------------------------

        const PeerService = {
            peer: null,
            conn: {}, // { peerId: connection_object }
            isHost: false,
            hostId: null, // Si client, l'ID de l'hôte
            localId: null, // L'ID généré pour cette session
            isReady: false,
            reconnectTimer: null,
            
            // État pour les clients qui ne doivent pas éditer
            isClientReadOnly: false, 

            initPeer: (id = null) => {
                PeerService.isReady = false;
                if (PeerService.peer) { PeerService.peer.destroy(); }
                
                // --- MODIFICATION: Réutilisation de l'ID d'hôte stocké ---
                let peerId = id;
                if (PeerService.isHost) {
                    // Si on est Host, on tente de récupérer l'ID persistant
                    const savedSession = JSON.parse(localStorage.getItem(WEBRTC_STORAGE_KEY));
                    if (savedSession && savedSession.isHost && savedSession.id) {
                         peerId = savedSession.id;
                    } else {
                         // Laisse PeerJS en générer un (peerId = undefined)
                         peerId = undefined; 
                    }
                } else if (!id) {
                     // Client: l'ID doit être fourni (hostId) ou être généré pour la connexion
                     peerId = crypto.randomUUID();
                }
                
                NetService.updateUI('connecting', peerId);

                const peer = new Peer(peerId, PEER_CONFIG);

                peer.on('open', (pid) => {
                    PeerService.localId = pid;
                    PeerService.isReady = true;
                    // Arrêter le loop de reconnexion si on réussit
                    clearInterval(PeerService.reconnectTimer);
                    
                    NetService.updateUI(PeerService.isHost ? 'host' : 'connected');
                    
                    if (PeerService.isHost) {
                        NetService.showHostUI(pid);
                        // --- MODIFICATION: Persister l'ID Host réel ---
                        NetService.saveSession(pid, true);
                    } else if (PeerService.hostId) {
                        NetService.connectToHost();
                    }
                });

                peer.on('error', (err) => {
                    console.error("PeerJS Error:", err);
                    
                    // Si l'erreur n'est pas due à une déconnexion (peer-unavailable/network), on réagit.
                    if (err.type !== 'peer-unavailable' && err.type !== 'network') {
                        NetService.updateUI('disconnected');
                        
                        if (document.getElementById('webrtcModal').style.display === 'block' || PeerService.hostId) {
                            showMessageModal("Erreur Réseau", `Erreur PeerJS : ${err.type}. Veuillez réessayer.`, true);
                        }
                        PeerService.isClientReadOnly = false;
                        PeerService.hostId = null; 
                        if (html5QrCodeWebRtc) NetService.stopWebRtcScanner();
                        
                        // Tenter la reconnexion si on était connecté et que l'erreur est grave (ex: id déjà utilisé)
                        if (PeerService.hostId || PeerService.isHost) {
                            PeerService.startReconnectLoop();
                        }
                    }
                });
                
                peer.on('disconnected', () => { 
                    showToast("Déconnexion PeerJS. Reco...");
                    // PeerJS tente de reconnecter automatiquement, mais on ajoute notre boucle de sécurité
                    PeerService.startReconnectLoop();
                });

                peer.on('connection', NetService.handleConnection);
                
                PeerService.peer = peer;
            },
            
            reconnectLoop: () => {
                // Tente de se reconnecter si PeerService n'est pas prêt et que des infos de session existent
                if (!PeerService.isReady && (PeerService.hostId || PeerService.isHost)) {
                    showToast("Tentative de reconnexion...", true);
                    
                    if (PeerService.isHost) {
                        // Recréer la session Host (l'ID sera réutilisé par initPeer)
                        PeerService.initPeer(); 
                    } else if (PeerService.hostId) {
                        // Recréer la session Client et tenter de rejoindre
                        PeerService.initPeer(crypto.randomUUID());
                    }
                } else if (PeerService.isReady && PeerService.hostId && !Object.keys(PeerService.conn).length) {
                     // Peer prêt mais n'est plus connecté à l'hôte (côté client)
                     NetService.connectToHost();
                }
            },

            startReconnectLoop: () => {
                if (!PeerService.reconnectTimer) {
                    PeerService.reconnectTimer = setInterval(PeerService.reconnectLoop, RECONNECT_INTERVAL_MS);
                }
            },
            
            createHost: () => {
                PeerService.isHost = true;
                PeerService.isClientReadOnly = false;
                NetService.stopWebRtcScanner();
                PeerService.initPeer();
            },

            joinClient: (hostId) => {
                PeerService.isHost = false;
                PeerService.hostId = hostId;
                PeerService.isClientReadOnly = true; 
                NetService.stopWebRtcScanner();
                PeerService.initPeer(crypto.randomUUID()); 
            },

            disconnect: (isFullReset = false) => {
                // Arrêter la boucle de reconnexion
                clearInterval(PeerService.reconnectTimer);
                PeerService.reconnectTimer = null;

                Object.values(PeerService.conn).forEach(c => {
                    if (c.open) c.close();
                });
                if (PeerService.peer) {
                    PeerService.peer.destroy();
                }
                PeerService.conn = {};
                PeerService.isHost = false;
                PeerService.hostId = null;
                PeerService.localId = null;
                PeerService.isReady = false;
                PeerService.isClientReadOnly = false;
                NetService.updateUI('disconnected');
                document.getElementById('webrtc-login-view').style.display = 'block';
                document.getElementById('webrtc-host-view').style.display = 'none';
                document.getElementById('webrtc-client-view').style.display = 'none';
                
                // Affichage du formulaire d'ajout de log
                logForm.style.display = 'block';
                
                if (isFullReset) {
                    localStorage.removeItem(WEBRTC_STORAGE_KEY);
                } else {
                    NetService.saveSession(null, false);
                }
                
                // Réactive l'édition
                logForm.disabled = false;
                interventionTitleInput.disabled = false;
            }
        };

        const NetService = {
            
            // Connecte le client à l'hôte
            connectToHost: () => {
                if (!PeerService.isReady || !PeerService.hostId) return;

                const hostConn = PeerService.peer.connect(PeerService.hostId, { metadata: { type: 'client', id: PeerService.localId } });
                NetService.handleConnection(hostConn);
            },
            
            // Gère une nouvelle connexion (pour Host et Client)
            handleConnection: (conn) => {
                PeerService.conn[conn.peer] = conn;
                
                conn.on('open', () => {
                    showToast(`Connexion établie avec ${conn.peer}`);
                    
                    if (PeerService.isHost) {
                        // Hôte envoie le titre et les logs à la connexion
                        conn.send({ type: 'TITLE_SYNC', title: interventionTitleInput.value.trim() });
                        conn.send({ type: 'LOG_SYNC', logs: getLogData() });
                        NetService.updateHostPeerCount();
                    } else if (conn.peer === PeerService.hostId) {
                        // Client connecté à l'hôte
                        NetService.showClientUI(conn.peer);
                        NetService.saveSession(conn.peer, false);
                    }
                });

                conn.on('data', NetService.handleData);
                
                conn.on('close', () => { 
                    showToast(`Déconnexion de ${conn.peer}`, true);
                    delete PeerService.conn[conn.peer];
                    if (PeerService.isHost) {
                        NetService.updateHostPeerCount();
                    } else if (conn.peer === PeerService.hostId) {
                        // Client a perdu la connexion avec l'hôte
                        PeerService.disconnect();
                        showMessageModal("Déconnexion", "Connexion à l'hôte perdue. Tentative de reconnexion en arrière-plan.", true);
                        PeerService.startReconnectLoop(); // Redémarre la boucle de reconnexion
                    }
                });

                conn.on('error', (err) => { 
                    console.error("Erreur Data Connexion:", err);
                });
            },
            
            // Gère les données reçues
            handleData: (data) => {
                // Si client, on force la lecture seule
                if (PeerService.isClientReadOnly) {
                    logForm.disabled = true;
                    interventionTitleInput.disabled = true;
                }
                
                if (data.type === 'TITLE_SYNC' && data.title) {
                    interventionTitleInput.value = data.title;
                    saveTitle();
                    showToast("Titre d'Opération mis à jour.");
                } else if (data.type === 'LOG_SYNC' && Array.isArray(data.logs)) {
                    renderLogTable(data.logs);
                    showToast(`Journal synchronisé (${data.logs.length} entrées)`);
                } else if (data.type === 'LOG_UPDATE' && Array.isArray(data.logs)) {
                    // Si l'hôte envoie les logs, on met à jour la page sans notification pour l'hôte.
                    // Seul un client voit une notification si l'hôte a fait une modification.
                    
                    if (!PeerService.isHost) {
                        // Logique de notification pour les clients (abonnés)
                        const oldLogs = loadLogData();
                        const newLogs = data.logs;

                        const newIds = new Set(newLogs.map(l => l.id));
                        const oldIds = new Set(oldLogs.map(l => l.id));
                        
                        let toastMessage = `Journal mis à jour.`;
                        let toastColor = 'var(--ao-green)';
                        let logEntry = null;
                        let isDeletion = false;

                        if (newLogs.length > oldLogs.length) {
                            // Ajout
                            logEntry = newLogs.find(l => !oldIds.has(l.id));
                            if (logEntry) toastMessage = `Log: ${logEntry.pax} ajouté`;
                        } else if (newLogs.length < oldLogs.length) {
                            // Suppression
                            logEntry = oldLogs.find(l => !newIds.has(l.id));
                            isDeletion = true;
                            if (logEntry) toastMessage = `Log: ${logEntry.pax} supprimé`;
                        } else {
                             // Modification/Réorganisation
                             toastMessage = `Log: Journal modifié`;
                        }
                        
                        if (logEntry) {
                            if (logEntry.paxMode === 'free') {
                               toastColor = logEntry.paxColor;
                            } else {
                               toastColor = PDF_PAX_COLORS[logEntry.pax].color || 'var(--ao-green)';
                            }
                        }
                        
                        renderLogTable(newLogs);
                        showToast(toastMessage, isDeletion, toastColor);
                    } else {
                        // Hôte: met à jour la page en silence, sans notification.
                        renderLogTable(data.logs);
                    }
                }
            },
            
            // Diffuse les logs à tous les clients
            broadcastLogs: () => {
                if (!PeerService.isHost) return;
                const logData = getLogData();
                Object.values(PeerService.conn).forEach(conn => {
                    if (conn.open) {
                        conn.send({ type: 'LOG_UPDATE', logs: logData });
                    }
                });
            },
            
            // Diffuse le titre (une seule fois)
            broadcastTitle: () => {
                if (!PeerService.isHost) return;
                const title = interventionTitleInput.value.trim();
                Object.values(PeerService.conn).forEach(conn => {
                    if (conn.open) {
                        conn.send({ type: 'TITLE_SYNC', title: title });
                    }
                });
            },
            
            // Mise à jour de l'UI globale
            updateUI: (status, peerId = null) => {
                webrtcStatusBox.className = '';
                let iconName = '';
                let text = '';
                let boxClass = '';

                switch (status) {
                    case 'connecting':
                        iconName = 'sync';
                        text = 'Connexion...';
                        boxClass = 'status-connecting';
                        break;
                    case 'host':
                        iconName = 'sensors';
                        text = `HÔTE: ${peerId || PeerService.localId}`;
                        boxClass = 'status-host';
                        break;
                    case 'connected':
                        iconName = 'sensors_in';
                        text = `Connecté`; // Affichage simplifié sur mobile
                        if (window.matchMedia("(min-width: 769px)").matches) {
                            text = `CLIENT: ${peerId || PeerService.hostId}`; // Affichage complet sur PC
                        }
                        boxClass = 'status-connected';
                        break;
                    case 'disconnected':
                    default:
                        iconName = 'sensors_off';
                        text = 'Déconnecté';
                        boxClass = 'status-disconnected';
                        break;
                }
                
                webrtcStatusBox.classList.add(boxClass);
                webrtcStatusIcon.innerText = iconName;
                webrtcStatusText.innerText = text;
                
                // Si non connecté, réactiver les champs
                if (status === 'disconnected') {
                     logForm.disabled = false;
                     interventionTitleInput.disabled = false;
                     logForm.style.display = 'block'; // Afficher le formulaire en mode déconnecté
                }
            },
            
            updateHostPeerCount: () => {
                if (!PeerService.isHost) return;
                const count = Object.keys(PeerService.conn).length;
                document.getElementById('peer-count-display').innerText = `Clients connectés: ${count}`;
            },

            showHostUI: (pid) => {
                 document.getElementById('webrtc-login-view').style.display = 'none';
                 document.getElementById('webrtc-client-view').style.display = 'none';
                 document.getElementById('webrtc-host-view').style.display = 'block';
                 document.getElementById('session-id-display').innerText = `ID: ${pid}`;
                 document.getElementById('qr-code-region').innerHTML = '';
                 new QRCode(document.getElementById('qr-code-region'), { text: pid, width: 200, height: 200 });
                 NetService.updateUI('host', pid);
                 NetService.updateHostPeerCount();
                 logForm.style.display = 'block'; // L'hôte garde le formulaire
            },
            
            showClientUI: (hostId) => {
                 document.getElementById('webrtc-login-view').style.display = 'none';
                 document.getElementById('webrtc-host-view').style.display = 'none';
                 document.getElementById('webrtc-client-view').style.display = 'block';
                 document.getElementById('client-session-id-display').innerText = `Canal: ${hostId}`;
                 NetService.updateUI('connected', hostId);
                 // Désactiver et masquer l'édition pour le client
                 logForm.disabled = true;
                 interventionTitleInput.disabled = true;
                 logForm.style.display = 'none'; // Masquer le formulaire en mode client
            },
            
            loadSession: () => {
                 const s = JSON.parse(localStorage.getItem(WEBRTC_STORAGE_KEY));
                 if (s && s.id) {
                     PeerService.isHost = s.isHost;
                     // --- MODIFICATION: Persister l'ID host/client dans PeerService pour la réutilisation ---
                     PeerService.hostId = s.isHost ? s.id : s.id; 
                     
                     if (s.isHost) {
                         PeerService.createHost();
                     } else {
                         document.getElementById('input-join-id').value = s.id;
                         PeerService.joinClient(s.id);
                     }
                 }
            },
            
            saveSession: (id, isHost) => {
                 localStorage.setItem(WEBRTC_STORAGE_KEY, JSON.stringify({ id: id, isHost: isHost }));
            },
            
            // --- LOGIQUE SCANNER WEBRTC (Basé sur comtac) ---
            startWebRtcScanner: () => {
                if (html5QrCodeWebRtc) return;
                webrtcScannerRegion.style.display = 'block';
                btnScanQr.innerHTML = '<span class="material-symbols-outlined" style="font-size: 1.5rem;">stop</span> Arrêter Scan';
                btnScanQr.classList.remove('webrtc-menu-item');
                btnScanQr.classList.add('action'); 
                
                html5QrCodeWebRtc = new Html5Qrcode("qr-scanner-region");
                
                const config = { 
                    fps: 10, 
                    qrbox: { width: 256, height: 256 }, // Taille demandée
                    disableFlip: false 
                };
                
                html5QrCodeWebRtc.start({ facingMode: "environment" }, config, 
                    (decodedText) => {
                        // Succès du scan
                        NetService.stopWebRtcScanner();
                        const hostId = decodedText.trim();
                        document.getElementById('input-join-id').value = hostId;
                        PeerService.joinClient(hostId);
                        closeWebRtcModal();
                    }, 
                    (errorMessage) => {
                        // Progression du scan ou petite erreur ignorée
                    }
                )
                .catch(err => {
                    NetService.stopWebRtcScanner();
                    webrtcScannerRegion.innerHTML = `<div class="qr-scan-placeholder" style="color:var(--danger-red);">Erreur Caméra: ${err}.</div>`;
                    showToast("Erreur caméra WebRTC", true);
                });
            },
            
            stopWebRtcScanner: () => {
                 if (html5QrCodeWebRtc) {
                    html5QrCodeWebRtc.stop().catch(err => console.log("Stop WebRTC Scanner failed", err));
                    html5QrCodeWebRtc = null;
                 }
                 webrtcScannerRegion.style.display = 'none';
                 webrtcScannerRegion.innerHTML = `<div class="qr-scan-placeholder" style="text-align: center;">Scan QR Code en cours...</div>`;
                 btnScanQr.innerHTML = '<span class="material-symbols-outlined" style="font-size: 1.5rem;">qr_code_scanner</span> Scanner QR Code';
                 btnScanQr.classList.remove('action');
                 btnScanQr.classList.add('webrtc-menu-item');
            }
        };

        // ----------------------------------------------------
        // --- FIN MODULE PEERJS (WEBRTC) ---
        // ----------------------------------------------------
        
        function getHexToRgb(hex) {
             const bigint = parseInt(hex.slice(1), 16);
             const r = (bigint >> 16) & 255;
             const g = (bigint >> 8) & 255;
             const b = bigint & 255;
             return { r: r / 255, g: g / 255, b: b / 255 };
        }
        
        function calculateTextColor(hexColor) {
            const {r, g, b} = getHexToRgb(hexColor); 
            const luminosity = (0.299 * r + 0.587 * g + 0.114 * b);
            return luminosity > 0.5 ? '#000000' : '#ffffff';
        }
        
        function generateUniqueId() {
             return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }
        
        function showMessageModal(title, content, isError = false) {
            const modal = document.getElementById('messageModal');
            const backdrop = document.getElementById('modalBackdrop');
            document.getElementById('modalMessageTitle').textContent = title;
            document.getElementById('modalMessageContent').textContent = content;
            const titleElement = document.getElementById('modalMessageTitle');
            if (isError) { titleElement.style.color = 'var(--danger-red)'; } else { titleElement.style.color = 'var(--ao-green)'; }
            backdrop.style.display = 'block';
            modal.style.display = 'block';
            document.getElementById('modalMessageBtn').onclick = () => {
                backdrop.style.display = 'none';
                modal.style.display = 'none';
            };
        }
        
        // Mise à jour de la fonction showToast pour accepter une couleur
        function showToast(message, isError = false, backgroundColor = null) {
            const toast = document.getElementById('toast-container');
            const msgSpan = document.getElementById('toast-message');
            const iconSpan = toast.querySelector('.material-symbols-outlined');
            
            msgSpan.textContent = message;
            
            // Déterminer la couleur de fond
            let bg = backgroundColor || (isError ? 'var(--danger-red)' : 'var(--ao-green)');
            toast.style.backgroundColor = bg;
            
            // Déterminer la couleur du texte (pour les couleurs custom)
            let textColor = 'white';
            if (bg.startsWith('#')) {
                // Pour s'assurer que le texte est lisible sur la couleur de fond
                const luminosity = calculateTextColor(bg) === '#000000' ? 0.6 : 1; 
                textColor = `rgba(255, 255, 255, ${luminosity})`; 
            } else if (bg.includes('yellow') || bg.includes('civil-yellow') || bg.includes('ao-green')) {
                textColor = 'black'; // Texte sombre pour les couleurs claires
            }
            toast.style.color = textColor;
            iconSpan.style.color = textColor; // Assurer que l'icône a la bonne couleur
            
            iconSpan.textContent = isError ? 'error' : 'check_circle';
            
            toast.classList.add('show');
            setTimeout(() => { 
                toast.classList.remove('show'); 
                // Réinitialiser les couleurs après la fermeture
                toast.style.backgroundColor = 'var(--ao-green)'; 
                toast.style.color = 'white';
                iconSpan.style.color = 'white';
            }, 3000);
        }

        function saveLogData(logData) {
            try {
                logData.sort((a, b) => {
                    if (a.heure === b.heure) return 0;
                    if (a.heure < b.heure) return -1;
                    if (a.heure > b.heure) return 1;
                    return 0; 
                });
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(logData));
                updateHistoryAndColorMap(logData);
                
                // !!! WEBRTC BROADCAST: Les logs ont changé
                if (PeerService.isHost) NetService.broadcastLogs();
                
            } catch (e) {
                console.error("Erreur de sauvegarde des données:", e);
                showMessageModal("Erreur de sauvegarde", "Impossible de sauvegarder les données dans le stockage local.", true);
            }
        }

        function loadLogData() {
            try {
                const dataString = localStorage.getItem(LOCAL_STORAGE_KEY);
                return dataString ? JSON.parse(dataString) : [];
            } catch (e) {
                console.error("Erreur de chargement des données:", e);
                return [];
            }
        }
        
        function getLogData() {
            return Array.from(logTableBody.querySelectorAll('tr')).map(row => {
                const getSafeDataset = (key) => {
                    const value = row.dataset[key] || '';
                    return value === 'undefined' ? '' : value; 
                };
                const paxMode = getSafeDataset('paxmode') || 'standard';
                let paxValue = getSafeDataset('pax');
                if (paxMode === 'free') {
                    paxValue = getSafeDataset('freepaxname') || 'Pax Libre';
                }
                return {
                    id: row.dataset.id,
                    heure: row.querySelector('.heure-cell-text').textContent,
                    pax: paxValue,
                    paxMode: paxMode, 
                    paxColor: getSafeDataset('paxcolor') || (paxMode === 'free' ? FREE_MODE_COLORS[0].hex : undefined), 
                    lieu: getSafeDataset('lieu'),
                    fenetrePorte: getSafeDataset('fenetreporte'),
                    remarques: getSafeDataset('remarques'),
                };
            });
        }

        function loadHistory() {
            try {
                const dataString = localStorage.getItem(HISTORY_STORAGE_KEY);
                const history = dataString ? JSON.parse(dataString) : { lieux: [], fp: [], paxColorMap: {} };
                colorPaxMap = {};
                for (const paxName in history.paxColorMap) {
                    const color = history.paxColorMap[paxName];
                    colorPaxMap[color] = paxName; 
                }
                return history;
            } catch (e) {
                console.error("Erreur de chargement de l'historique:", e);
                return { lieux: [], fp: [], paxColorMap: {} };
            }
        }

        function saveHistory(history) {
            try { localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history)); } catch (e) { console.error("Erreur de sauvegarde de l'historique:", e); }
        }

        function updateHistoryAndColorMap(logData) {
            const lieux = new Set();
            const fp = new Set();
            const newPaxColorMap = {};
            const newColorPaxMap = {}; 
            logData.forEach(entry => {
                if (entry.lieu) lieux.add(entry.lieu.trim());
                if (entry.fenetrePorte) fp.add(entry.fenetrePorte.trim());
                if (entry.paxMode === 'free' && entry.paxColor) {
                    newPaxColorMap[entry.pax] = entry.paxColor;
                    newColorPaxMap[entry.paxColor] = entry.pax;
                }
            });
            const history = {
                lieux: Array.from(lieux).slice(0, 20),
                fp: Array.from(fp).slice(0, 20),
                paxColorMap: newPaxColorMap
            };
            paxColorMap = newPaxColorMap; 
            colorPaxMap = newColorPaxMap; 
            saveHistory(history);
            updateDatalists(history.lieux, history.fp);
        }
        
        function updateDatalists(lieux, fp) {
             lieuHistoryDatalist.innerHTML = '';
             fpHistorDatalist.innerHTML = '';
             lieux.forEach(item => {
                 const option = document.createElement('option');
                 option.value = item;
                 lieuHistoryDatalist.appendChild(option);
             });
             fp.forEach(item => {
                 const option = document.createElement('option');
                 option.value = item;
                 fpHistorDatalist.appendChild(option);
             });
        }
        
        function loadTitle() { interventionTitleInput.value = localStorage.getItem(TITLE_STORAGE_KEY) || ''; }
        function saveTitle() { 
             localStorage.setItem(TITLE_STORAGE_KEY, interventionTitleInput.value.trim()); 
             // !!! WEBRTC BROADCAST: Le titre a changé
             if (PeerService.isHost) NetService.broadcastTitle();
        }

        function renderLogTable(logData, newEntryId = null) {
            logTableBody.innerHTML = '';
            logData.forEach(entry => {
                let paxColor, paxText, paxFontColor;
                const isFreeMode = entry.paxMode === 'free';
                if (isFreeMode) {
                    paxColor = entry.paxColor || FREE_MODE_COLORS[0].hex;
                    paxText = entry.pax;
                    paxFontColor = calculateTextColor(paxColor);
                } else {
                    const paxInfo = PDF_PAX_COLORS[entry.pax] || PDF_PAX_COLORS['Adversaire'];
                    paxColor = paxInfo.color;
                    paxText = paxInfo.text;
                    paxFontColor = paxInfo.fontColor;
                }
                const row = logTableBody.insertRow();
                row.dataset.id = entry.id;
                row.dataset.lieu = entry.lieu || '';
                row.dataset.fenetreporte = entry.fenetrePorte || '';
                row.dataset.remarques = entry.remarques || '';
                row.dataset.pax = isFreeMode ? 'Libre' : entry.pax; 
                row.dataset.freepaxname = isFreeMode ? entry.pax : ''; 
                row.dataset.paxmode = entry.paxMode; 
                row.dataset.paxcolor = isFreeMode ? paxColor : ''; 
                
                if (entry.id === newEntryId) { row.classList.add('just-added'); }
                row.draggable = !PeerService.isClientReadOnly;
                row.classList.add('draggable-row');

                const heureCell = row.insertCell();
                heureCell.style.width = '15%';
                heureCell.innerHTML = `
                    <div class="heure-action-cell">
                        <span class="heure-cell-text">${entry.heure}</span>
                        ${PeerService.isClientReadOnly ? '' : `<button type="button" class="delete-btn" data-id="${entry.id}">
                            <span class="material-symbols-outlined">close</span>
                        </button>`}
                    </div>`;

                const paxCell = row.insertCell();
                paxCell.style.width = '15%';
                paxCell.innerHTML = `<span class="pax-cell" style="background-color: ${paxColor}; color: ${paxFontColor};">${paxText}</span>`;
                
                const lieuCell = row.insertCell();
                lieuCell.style.width = '20%';
                lieuCell.textContent = entry.lieu;

                const fpCell = row.insertCell();
                fpCell.style.width = '20%';
                fpCell.textContent = entry.fenetrePorte;

                const remarquesCell = row.insertCell();
                remarquesCell.style.width = '30%'; 
                remarquesCell.textContent = entry.remarques;
                
                if (!PeerService.isClientReadOnly) {
                    const mobileDelBtn = document.createElement('button');
                    mobileDelBtn.className = 'mobile-delete-btn';
                    mobileDelBtn.innerHTML = '<span class="material-symbols-outlined">delete</span>';
                    mobileDelBtn.onclick = function() { deleteLogEntry(entry.id); };
                    row.appendChild(mobileDelBtn); 
                }
            });
             saveLogData(getLogData());
             // Gère l'état d'édition si client
             if (PeerService.isClientReadOnly) {
                 logForm.disabled = true;
                 interventionTitleInput.disabled = true;
                 logForm.style.display = 'none'; // Masquer le formulaire en mode client
                 sortTimeBtn.disabled = true;
             } else {
                 logForm.disabled = false;
                 interventionTitleInput.disabled = false;
                 logForm.style.display = 'block';
                 sortTimeBtn.disabled = false;
             }
        }
        
        function handleAddLogEntry(e) {
            e.preventDefault();
            if (PeerService.isClientReadOnly) { showToast("Journal non éditable en mode Client WebRTC.", true); return; }
            
            const mode = paxModeInput.value;
            let paxName, paxColorHex;
            if (mode === 'standard') {
                paxName = paxInput.value;
                paxColorHex = ''; 
                if (!paxName) { showMessageModal("Erreur de saisie", "Veuillez sélectionner un type de PAX standard.", true); return; }
            } else {
                paxName = freePaxInput.value.trim();
                paxColorHex = paxCustomColorInput.value;
                if (!paxName) { showMessageModal("Erreur de saisie", "Veuillez donner un nom à l'intervenant TP.", true); return; }
            }
            if (!heureInput.value) { showMessageModal("Erreur de saisie", "Veuillez renseigner l'heure.", true); return; }
            
            const currentHeure = heureInput.value;
            const newId = generateUniqueId();
            const newEntry = {
                id: newId, heure: currentHeure, pax: paxName, paxMode: mode, paxColor: paxColorHex,
                lieu: lieuInput.value.trim(), fenetrePorte: fenetrePorteInput.value.trim(), remarques: remarquesInput.value.trim(),
            };
            const logData = getLogData(); 
            logData.push(newEntry);
            isTimeInputManuallyChanged = false;
            
            // 1. Déterminer la couleur et le nom pour le Toast
            let toastColor, paxText;
            if (mode === 'free') {
               toastColor = paxColorHex;
               paxText = paxName;
            } else {
               const paxInfo = PDF_PAX_COLORS[paxName] || PDF_PAX_COLORS['Adversaire'];
               toastColor = paxInfo.color;
               paxText = paxInfo.text;
            }
            
            // 2. Rendre le tableau (cela déclenche saveLogData et broadcast)
            renderLogTable(logData, newId); 

            // 3. Afficher le Toast
            showToast(`Log: ${paxText} ajouté`, false, toastColor);
            
            if (mode === 'free') {
                 paxColorMap[paxName] = paxColorHex; 
                 colorPaxMap[paxColorHex] = paxName; 
            }
            updateTimeInput();
            lieuInput.value = ''; fenetrePorteInput.value = ''; remarquesInput.value = '';
            remarquesInput.focus();
        }
        
        function deleteLogEntry(id) {
            if (PeerService.isClientReadOnly) { showToast("Journal non éditable en mode Client WebRTC.", true); return; }
            
            const oldLogs = getLogData();
            const logToDelete = oldLogs.find(entry => entry.id === id);
            
            const logData = oldLogs.filter(entry => entry.id !== id);
            renderLogTable(logData);
            
            // Afficher le Toast de suppression
            if (logToDelete) {
                let toastColor, paxText;
                if (logToDelete.paxMode === 'free') {
                   toastColor = logToDelete.paxColor;
                   paxText = logToDelete.pax;
                } else {
                   const paxInfo = PDF_PAX_COLORS[logToDelete.pax] || PDF_PAX_COLORS['Adversaire'];
                   toastColor = paxInfo.color;
                   paxText = paxInfo.text;
                }
                showToast(`Log: ${paxText} supprimé`, true, toastColor); // Couleur rouge pour la suppression
            }
        }

        function sortLogTableByTime() {
             if (PeerService.isClientReadOnly) { showToast("Opération non autorisée en mode Client WebRTC.", true); return; }
             const logData = getLogData();
             logData.sort((a, b) => {
                if (a.heure < b.heure) return -1;
                if (a.heure > b.heure) return 1;
                return 0; 
             });
             renderLogTable(logData);
             showMessageModal("Tri terminé", "Le journal a été trié par ordre chronologique de l'heure.", false);
        }

        function handleColorSwatchClick() {
            Array.from(document.getElementById('free_color_palette').querySelectorAll('.color-swatch')).forEach(s => s.classList.remove('selected'));
            this.classList.add('selected');
            const selectedColor = this.dataset.color;
            paxCustomColorInput.value = selectedColor;
            if (paxModeInput.value === 'free') {
                if (colorPaxMap[selectedColor]) {
                    const lastPaxName = colorPaxMap[selectedColor];
                    freePaxInput.value = lastPaxName;
                    paxInput.value = lastPaxName; 
                } else {
                    freePaxInput.value = ''; 
                    paxInput.value = ''; 
                }
                freePaxInput.focus(); 
            }
        }

        function initPaxModeAndColors() {
            const paletteContainer = document.getElementById('free_color_palette');
            paletteContainer.innerHTML = '';
            FREE_MODE_COLORS.forEach((color, index) => {
                const swatch = document.createElement('span');
                swatch.className = `color-swatch swatch-${index + 1}`;
                swatch.dataset.color = color.hex;
                swatch.style.backgroundColor = color.hex;
                if (color.hex === '#ffffff') { swatch.style.borderColor = '#000000'; }
                swatch.addEventListener('click', handleColorSwatchClick);
                paletteContainer.appendChild(swatch);
            });
            paletteContainer.querySelector('.color-swatch').classList.add('selected');
            paxCustomColorInput.value = FREE_MODE_COLORS[0].hex;
            setPaxMode('standard');
            Array.from(paxSelectContainer.querySelectorAll('.pax-select-option')).forEach(option => {
                option.addEventListener('click', function() {
                    Array.from(paxSelectContainer.querySelectorAll('.pax-select-option')).forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    paxInput.value = this.dataset.pax;
                    lieuInput.focus();
                });
            });
            paxInput.value = 'Adversaire';
            const initialOption = paxSelectContainer.querySelector(`[data-pax="Adversaire"]`);
            if (initialOption) { initialOption.classList.add('selected'); }
        }
        
        function setPaxMode(mode) {
            const isStandard = mode === 'standard';
            document.getElementById('pax_select_wrapper_standard').style.display = isStandard ? 'block' : 'none';
            document.getElementById('pax_select_wrapper_free').style.display = isStandard ? 'none' : 'block';
            document.querySelectorAll('#pax_mode_toggle_container .mode-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
            paxModeInput.value = mode;
            if (isStandard) {
                 const selectedOption = paxSelectContainer.querySelector('.pax-select-option.selected');
                 paxInput.value = selectedOption ? selectedOption.dataset.pax : 'Adversaire';
            } else {
                 freePaxInput.value = ''; 
                 paxInput.value = ''; 
                 const defaultColor = FREE_MODE_COLORS[0].hex;
                 paxCustomColorInput.value = defaultColor;
                 Array.from(document.getElementById('free_color_palette').querySelectorAll('.color-swatch')).forEach((s, index) => {
                    s.classList.toggle('selected', index === 0);
                 });
                 freePaxInput.focus();
            }
        }
        
        document.querySelectorAll('#pax_mode_toggle_container .mode-toggle-btn').forEach(btn => {
            btn.addEventListener('click', () => setPaxMode(btn.dataset.mode));
        });
        
        freePaxInput.addEventListener('input', (e) => {
            const paxName = e.target.value.trim();
            if (paxModeInput.value === 'free') { paxInput.value = paxName; }
             if (paxColorMap[paxName]) {
                const savedColor = paxColorMap[paxName];
                paxCustomColorInput.value = savedColor;
                Array.from(document.getElementById('free_color_palette').querySelectorAll('.color-swatch')).forEach(s => {
                    s.classList.toggle('selected', s.dataset.color === savedColor);
                });
             }
        });

        function updateTimeInput() {
            if (!isTimeInputManuallyChanged) {
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                heureInput.value = `${hours}:${minutes}`;
            }
        }

        let dragSrcEl = null;
        function handleDragStart(e) {
            if (PeerService.isClientReadOnly) { e.preventDefault(); return; }
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.dataset.id);
            this.classList.add('dragging');
        }
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const targetRow = this;
            if (targetRow.closest('tbody') !== logTableBody) return; 
            if (dragSrcEl === targetRow) return;
            const rect = targetRow.getBoundingClientRect();
            const offsetY = e.clientY - rect.top;
            const halfHeight = rect.height / 2;
            if (offsetY < halfHeight) { logTableBody.insertBefore(dragSrcEl, targetRow); } else { logTableBody.insertBefore(dragSrcEl, targetRow.nextSibling); }
        }
        function handleDrop(e) {
            e.stopPropagation(); e.preventDefault(); 
            saveLogData(getLogData()); renderLogTable(loadLogData());
            return false;
        }
        function handleDragEnd(e) { this.classList.remove('dragging'); }
        
        function exportJson() {
             const logData = getLogData();
             const title = interventionTitleInput.value.trim() || "Sans Titre";
             if (logData.length === 0) { showMessageModal("Exportation impossible", "Le journal est vide. Rien à exporter.", true); return; }
             const now = new Date();
             const datePart = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
             const timePart = `${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}`; 
             const sanitizedTitle = title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
             const fileName = `PC_Tac_Session_${datePart}_${timePart}_${sanitizedTitle}.json`;
             const exportObject = {
                 metadata: { appName: "PC Tac Log", version: "1.0", timestamp: now.toISOString(), title: title },
                 logEntries: logData
             };
             const jsonString = JSON.stringify(exportObject, null, 2);
             const blob = new Blob([jsonString], { type: "application/json" });
             const url = URL.createObjectURL(blob);
             const link = document.createElement('a');
             link.href = url; link.download = fileName;
             document.body.appendChild(link); link.click(); document.body.removeChild(link);
             URL.revokeObjectURL(url);
             showMessageModal("Exportation réussie", `Les données ont été exportées sous le nom : ${fileName}`, false);
        }
        
        async function importJson(event) {
            if (PeerService.isClientReadOnly) { showToast("Opération non autorisée en mode Client WebRTC.", true); return; }
            
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const jsonContent = JSON.parse(e.target.result);
                    if (jsonContent.metadata && jsonContent.metadata.appName === "PC Tac Log" && Array.isArray(jsonContent.logEntries)) {
                        const currentIds = new Set(getLogData().map(e => e.id));
                        const validatedEntries = jsonContent.logEntries.map(entry => {
                            let newId = entry.id;
                            if (currentIds.has(entry.id)) { newId = generateUniqueId(); }
                            const paxMode = entry.paxMode || (PDF_PAX_COLORS[entry.pax] ? 'standard' : 'free');
                            return {
                                id: newId, heure: entry.heure || '00:00',
                                pax: entry.pax, paxMode: paxMode,
                                paxColor: entry.paxColor || (paxMode === 'free' ? FREE_MODE_COLORS[0].hex : undefined),
                                lieu: entry.lieu || '', fenetrePorte: entry.fenetrePorte || '', remarques: entry.remarques || '',
                            };
                        });
                        if (jsonContent.metadata.title) { interventionTitleInput.value = jsonContent.metadata.title; saveTitle(); }
                        const currentData = getLogData();
                        const mergedData = [...currentData, ...validatedEntries];
                        renderLogTable(mergedData);
                        showMessageModal("Importation réussie", `${validatedEntries.length} entrées ont été chargées.`, false);
                    } else { throw new Error("Fichier JSON invalide."); }
                } catch (error) { console.error("Erreur JSON:", error); showMessageModal("Erreur d'importation", `Erreur : ${error.message}`, true);
                } finally { jsonImportInput.value = ''; initPaxModeAndColors(); }
            };
            reader.readAsText(file);
        }

        // --- PDF UTILS (Minifié pour la place) ---
        function wrapTextForPdf(font, fontSize, text, maxWidth) {
            text = String(text || ''); const token = ' \n '; const chunks = text.replace(/\r?\n/g, token).split(' ');
            let lines = []; let currentLine = '';
            for (const chunk of chunks) {
                if (chunk === '\n') { lines.push(currentLine.trim()); currentLine = ''; continue; }
                const lineWithChunk = currentLine === '' ? chunk : `${currentLine} ${chunk}`;
                if (font.widthOfTextAtSize(lineWithChunk, fontSize) > maxWidth && currentLine !== '') { 
                    lines.push(currentLine.trim()); currentLine = chunk; 
                } else { currentLine = lineWithChunk; }
            }
            lines.push(currentLine.trim()); return lines.filter(line => line.length > 0);
        }
        function getPdfColors(isDarkMode, rgb) {
            return isDarkMode ? { background: rgb(0, 0, 0), text: rgb(1, 1, 1), line: rgb(1, 1, 1) } : { background: rgb(1, 1, 1), text: rgb(0, 0, 0), line: rgb(0, 0, 0) };
        }
        let pdfRgb; 
        async function buildPdf() {
            if (typeof PDFLib === 'undefined') { throw new Error("PDFLib non chargé."); }
            const { PDFDocument, StandardFonts, rgb, PageSizes } = PDFLib;
            pdfRgb = rgb; 
            const pdfDoc = await PDFDocument.create();
            let helveticaFont, helveticaBoldFont;
            try {
                helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
                helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
            } catch (e) { return null; }
            const logData = getLogData();
            const interventionTitle = interventionTitleInput.value.trim() || "Journal d'intervention";
            const isDarkMode = document.body.classList.contains('dark-mode');
            const pdfThemeColors = getPdfColors(isDarkMode, rgb); 
            const pageConfig = { width: PageSizes.A4[1], height: PageSizes.A4[0], margin: 30, fontSize: 10, lineHeight: 14 };
            const colWidths = [0.10, 0.15, 0.20, 0.20, 0.35]; 
            const context = {
                pdfDoc, helveticaFont, helveticaBoldFont, currentPage: null, y: 0, pageNumber: 0,
                pageWidth: pageConfig.width, pageHeight: pageConfig.height, margin: pageConfig.margin,
                fontSize: pageConfig.fontSize, lineHeight: pageConfig.lineHeight,
                colors: { ...pdfThemeColors, adversaire: rgb(0xbe/255, 0x1b/255, 0x09/255), otage: rgb(0xf1/255, 0xc4/255, 0x0f/255), inter: rgb(0x34/255, 0x98/255, 0xdb/255), ao: rgb(0x2e/255, 0xcc/255, 0x71/255) },
                interventionTitle: interventionTitle
            };
            const drawFooter = () => {
                const footerText = `Page ${context.pageNumber}`;
                const textWidth = context.helveticaFont.widthOfTextAtSize(footerText, context.fontSize);
                context.currentPage.drawText(footerText, { x: (context.pageWidth / 2) - (textWidth / 2), y: context.margin / 2, font: context.helveticaFont, size: context.fontSize, color: context.colors.text });
            };
            const addNewPage = () => {
                if (context.currentPage) { drawFooter(); }
                context.currentPage = context.pdfDoc.addPage([PageSizes.A4[1], PageSizes.A4[0]]); 
                context.pageNumber++;
                context.pageWidth = context.currentPage.getWidth();
                context.pageHeight = context.currentPage.getHeight();
                context.y = context.pageHeight - context.margin;
                context.currentPage.drawRectangle({ x: 0, y: 0, width: context.pageWidth, height: context.pageHeight, color: context.colors.background });
                context.currentPage.drawText(`PC TAC - ${context.interventionTitle}`, { x: context.margin, y: context.pageHeight - context.margin / 2, font: context.helveticaBoldFont, size: 14, color: context.colors.text });
                context.y = context.pageHeight - context.margin - 20; 
            };
            const checkY = (spaceNeeded) => { if (context.y - spaceNeeded < context.margin * 1.5) { addNewPage(); drawTableHeader(); return true; } return false; };
            const drawTableHeader = () => {
                 const headers = ["Heure", "Pax", "Lieu", "Fenêtre/Porte", "Remarques"];
                 let currentX = context.margin;
                 const tableY = context.y;
                 const headerHeight = context.lineHeight + 5;
                 context.currentPage.drawLine({ start: { x: context.margin, y: tableY - 1 }, end: { x: context.pageWidth - context.margin, y: tableY - 1 }, color: context.colors.line, thickness: 1 });
                 headers.forEach((header, i) => {
                     const colWidth = context.pageWidth * colWidths[i];
                     context.currentPage.drawText(header, { x: currentX + 2, y: tableY - headerHeight + 5, font: context.helveticaBoldFont, size: context.fontSize, color: context.colors.text });
                     currentX += colWidth;
                 });
                 context.y -= headerHeight;
            };
            const drawLogEntry = (entry) => {
                let paxColorHex, paxText, paxTextColor;
                const isFreeMode = entry.paxMode === 'free';
                if (isFreeMode) {
                    paxColorHex = entry.paxColor || FREE_MODE_COLORS[0].hex; paxText = entry.pax;
                    paxTextColor = calculateTextColor(paxColorHex) === '#000000' ? pdfRgb(0, 0, 0) : pdfRgb(1, 1, 1);
                } else {
                    const paxInfo = PDF_PAX_COLORS[entry.pax] || PDF_PAX_COLORS['Adversaire'];
                    paxColorHex = paxInfo.color; paxText = paxInfo.text;
                    paxTextColor = paxInfo.fontColor === '#000000' ? pdfRgb(0, 0, 0) : pdfRgb(1, 1, 1);
                }
                const { r, g, b } = getHexToRgb(paxColorHex); 
                const paxPdfColor = pdfRgb(r, g, b); 
                const colWidthsPx = colWidths.map(ratio => context.pageWidth * ratio - 4);
                const parts = [
                    { text: entry.heure, colIndex: 0, font: context.helveticaFont, size: context.fontSize, color: context.colors.text },
                    { text: paxText, colIndex: 1, font: context.helveticaBoldFont, size: context.fontSize, color: paxTextColor, isPax: true }, 
                    { text: entry.lieu, colIndex: 2, font: context.helveticaFont, size: context.fontSize, color: context.colors.text }, 
                    { text: entry.fenetrePorte, colIndex: 3, font: context.helveticaFont, size: context.fontSize, color: context.colors.text },
                    { text: entry.remarques, colIndex: 4, font: context.helveticaFont, size: context.fontSize, color: context.colors.text },
                ];
                let allLines = parts.map((part, i) => {
                    part.text = String(part.text || '').trim(); if (!part.text) return ['']; 
                    return wrapTextForPdf(part.font, part.size, part.text, colWidthsPx[i]);
                });
                const maxLines = allLines.reduce((max, lines) => Math.max(max, lines.length), 1);
                const rowHeight = maxLines * context.lineHeight + 5;
                if (checkY(rowHeight)) return;
                let currentX = context.margin; const tableY = context.y;
                parts.forEach((part, i) => {
                    const colWidth = context.pageWidth * colWidths[i];
                    const x = currentX; const textLines = allLines[i];
                    if (i === 1) { 
                        const bgX = x + 1; const paxBlockHeight = context.lineHeight + 4; 
                        const paxBlockY = tableY - rowHeight + (rowHeight - paxBlockHeight) / 2;
                        context.currentPage.drawRectangle({ x: bgX, y: paxBlockY, width: colWidthsPx[i] - 2, height: paxBlockHeight, color: paxPdfColor, opacity: 1, borderWidth: 0 });
                        const text = textLines[0] || ''; const textWidth = part.font.widthOfTextAtSize(text, part.size);
                        const textX = bgX + (colWidthsPx[i] - textWidth) / 2; const textY = paxBlockY + (paxBlockHeight - part.size) / 2 + 1; 
                        context.currentPage.drawText(text, { x: textX, y: textY, font: part.font, size: part.size, color: part.color });
                    } else { 
                        textLines.forEach((line, lineIndex) => {
                            const textY = tableY - context.lineHeight - (lineIndex * context.lineHeight) - 2;
                            if (line) { context.currentPage.drawText(line, { x: x + 2, y: textY, font: part.font, size: part.size, color: part.color }); }
                        });
                    }
                    currentX += colWidth;
                });
                context.currentPage.drawLine({ start: { x: context.margin, y: tableY - rowHeight + 1 }, end: { x: context.pageWidth - context.margin, y: tableY - rowHeight + 1 }, color: context.colors.line, thickness: 0.5, opacity: 0.5 });
                context.y -= rowHeight;
            };
            addNewPage(); drawTableHeader();
            logData.forEach(entry => { drawLogEntry(entry); });
            drawFooter();
            const pdfBytes = await pdfDoc.save();
            return pdfBytes;
        }

        // Fonction RESTAURÉE : downloadPdf
        async function downloadPdf() {
            const btn = previewPdfDockBtn; 
            const originalIcon = btn.querySelector('.material-symbols-outlined').textContent;
            btn.querySelector('.material-symbols-outlined').textContent = 'sync'; btn.disabled = true; btn.style.opacity = 0.6;
            try {
                const pdfBytes = await buildPdf();
                if (!pdfBytes) { showMessageModal("Erreur", "Echec PDF"); return; }
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const today = new Date().toLocaleDateString('fr-FR').replace(/\//g, '-');
                const title = interventionTitleInput.value.trim() || "Log";
                const fileName = `PC_Tac_${title.replace(/[^a-z0-9]/gi, '_')}_${today}.pdf`;
                if (navigator.msSaveBlob) { navigator.msSaveBlob(blob, fileName); } else {
                    const url = URL.createObjectURL(blob); const link = document.createElement('a');
                    link.href = url; link.download = fileName; document.body.appendChild(link); link.click();
                    setTimeout(() => { document.body.removeChild(link); URL.revokeObjectURL(url); }, 0); 
                }
            } catch (error) { 
                console.error(error);
                showMessageModal("Erreur", "Erreur PDF critique"); 
            } finally {
                btn.querySelector('.material-symbols-outlined').textContent = originalIcon; btn.disabled = false; btn.style.opacity = 1;
            }
        }

        // --- UI UTILS ---
        function isFullscreen() { return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement; }
        function toggleFullscreen() {
            if (!isFullscreen()) { if (document.documentElement.requestFullscreen) { document.documentElement.requestFullscreen(); } } else { if (document.exitFullscreen) { document.exitFullscreen(); } }
        }
        function updateFullscreenIcon() { const icon = document.getElementById('fullscreenIcon'); if (icon) { icon.textContent = isFullscreen() ? 'fullscreen_exit' : 'fullscreen'; } }
        function handleThemeToggle() {
            document.body.classList.toggle('light-mode'); document.body.classList.toggle('dark-mode');
            const isDarkMode = document.body.classList.contains('dark-mode'); localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            document.getElementById('darkModeIcon').textContent = isDarkMode ? 'nightlight' : 'clear_day';
        }
        function toggleDock() {
            const dock = document.getElementById('dockMenu'); const dockCollapsed = dock.classList.toggle('collapsed');
            localStorage.setItem('dockCollapsed', dockCollapsed);
            const icon = document.querySelector('#dockToggleBtn .material-symbols-outlined'); if (icon) { icon.textContent = dockCollapsed ? 'expand_less' : 'expand_more'; }
        }
        function showResetModal() { 
            if (PeerService.isClientReadOnly) { showToast("Opération non autorisée en mode Client WebRTC.", true); return; }
            document.getElementById('modalBackdrop').style.display = 'block'; document.getElementById('resetModal').style.display = 'block'; 
        }
        function hideResetModal() { document.getElementById('modalBackdrop').style.display = 'none'; document.getElementById('resetModal').style.display = 'none'; }
        function handleResetData() {
            localStorage.removeItem(LOCAL_STORAGE_KEY); localStorage.removeItem(HISTORY_STORAGE_KEY); localStorage.removeItem(TITLE_STORAGE_KEY);
            paxColorMap = {}; colorPaxMap = {}; renderLogTable([]); hideResetModal();
            heureInput.value = new Date().toTimeString().split(' ')[0].substring(0, 5); interventionTitleInput.value = '';
            setPaxMode('standard'); lieuInput.value = ''; fenetrePorteInput.value = ''; remarquesInput.value = '';
            updateDatalists([], []); showMessageModal("Réinitialisation", "Données effacées.");
        }
        function handleDeleteButtonClick(e) {
             if (PeerService.isClientReadOnly) return;
             if (e.target.closest('.delete-btn')) { const id = e.target.closest('.delete-btn').dataset.id; deleteLogEntry(id); }
        }

        // --- NOUVELLE LOGIQUE TRANSFERT QR (PAGINATION) ---
        function openTransferModal() {
            document.getElementById('modalBackdrop').style.display = 'block';
            transferModal.style.display = 'block';
            switchTransferTab('send');
        }
        function closeTransferModal() {
            document.getElementById('modalBackdrop').style.display = 'none';
            transferModal.style.display = 'none';
            if(html5QrCodeLocal) { // Utilise le nom pour le scanner local
                html5QrCodeLocal.stop().catch(err => console.log("Stop failed", err));
                html5QrCodeLocal = null;
            }
        }
        function switchTransferTab(tabName) {
            if (tabName === 'receive' && PeerService.isClientReadOnly) { 
                showToast("Importation par QR non autorisée en mode Client WebRTC.", true); 
                // Revenir à l'onglet envoyer
                tabName = 'send';
            }
            transferTabs.forEach(t => t.classList.toggle('active', t.dataset.tab === tabName));
            document.querySelectorAll('.transfer-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`transfer-${tabName}`).classList.add('active');
            
            if(tabName === 'send') {
                if(html5QrCodeLocal) { html5QrCodeLocal.stop().then(() => html5QrCodeLocal = null); }
                prepareQRPagination(); // Initialise la pagination
            } else {
                startScanner();
            }
        }
        
        // Fonction utilitaire pour découper un tableau en morceaux
        function chunkArray(array, size) {
            const chunks = [];
            for (let i = 0; i < array.length; i += size) {
                chunks.push(array.slice(i, i + size));
            }
            return chunks;
        }

        function prepareQRPagination() {
            const logs = getLogData();
            const container = document.getElementById('qrcode-container');
            const statusText = document.getElementById('qr-status-text');
            const navControls = document.getElementById('qr-nav-controls');
            
            container.innerHTML = '';
            
            if (logs.length === 0) {
                container.textContent = "Aucune donnée à transférer.";
                statusText.textContent = "";
                navControls.style.display = 'none'; // S'assurer qu'il est masqué
                return;
            }

            // Découpage en morceaux
            // On mappe d'abord en format compressé
            // Format: [id, heure, pax, paxMode, paxColor, lieu, fenetrePorte, remarques]
            let compressedData = logs.map(l => [l.id, l.heure, l.pax, l.paxMode, l.paxColor, l.lieu, l.fenetrePorte, l.remarques]);
            
            qrChunks = chunkArray(compressedData, QR_BATCH_SIZE);
            currentQrIndex = 0;
            
            if (qrChunks.length > 1) {
                navControls.style.display = 'flex'; // Afficher les contrôles si plus d'un chunk
            } else {
                navControls.style.display = 'none'; // S'assurer qu'il est masqué si un seul QR
            }
            
            showQR(currentQrIndex);
        }

        function showQR(index) {
            const container = document.getElementById('qrcode-container');
            const statusText = document.getElementById('qr-status-text');
            const counter = document.getElementById('qr-counter');
            const prevBtn = document.getElementById('prevQrBtn');
            const nextBtn = document.getElementById('nextQrBtn');
            
            container.innerHTML = ''; // Clear previous QR
            
            // Préparer le payload pour ce chunk spécifique
            let transferPayload = { 
                t: interventionTitleInput.value, 
                d: qrChunks[index] 
            };
            let jsonString = JSON.stringify(transferPayload);
            
            new QRCode(container, {
                text: jsonString,
                width: 256,
                height: 256,
                colorDark : "#000000",
                colorLight : "#ffffff",
                correctLevel : QRCode.CorrectLevel.M
            });
            
            // Mise à jour UI Navigation
            if (qrChunks.length > 1) {
                statusText.textContent = `Page ${index + 1} sur ${qrChunks.length} - ${qrChunks[index].length} entrées.`;
                counter.textContent = `${index + 1} / ${qrChunks.length}`;
                prevBtn.disabled = index === 0;
                nextBtn.disabled = index === qrChunks.length - 1;
            } else {
                statusText.textContent = `${qrChunks[0].length} entrées prêtes au transfert.`;
            }
        }

        function startScanner() {
            if (PeerService.isClientReadOnly) { showToast("Importation par QR non autorisée en mode Client WebRTC.", true); return; }
            if (html5QrCodeLocal) return; // Déjà actif
            html5QrCodeLocal = new Html5Qrcode("qr-reader");
            const config = { fps: 10, qrbox: { width: 250, height: 250 } };
            html5QrCodeLocal.start({ facingMode: "environment" }, config, onScanSuccess)
            .catch(err => {
                document.getElementById('qr-reader').textContent = "Erreur caméra: " + err;
            });
        }

        function onScanSuccess(decodedText, decodedResult) {
            try {
                const data = JSON.parse(decodedText);
                if (data.d && Array.isArray(data.d)) {
                    // Reconstruction des données
                    const currentLogs = getLogData();
                    const currentIds = new Set(currentLogs.map(l => l.id));
                    let addedCount = 0;

                    if(data.t) { interventionTitleInput.value = data.t; saveTitle(); }

                    // Format reçu: [id, heure, pax, paxMode, paxColor, lieu, fenetrePorte, remarques]
                    data.d.forEach(item => {
                        const id = item[0];
                        if (!currentIds.has(id)) {
                            currentLogs.push({
                                id: id,
                                heure: item[1],
                                pax: item[2],
                                paxMode: item[3],
                                paxColor: item[4],
                                lieu: item[5],
                                fenetrePorte: item[6],
                                remarques: item[7]
                            });
                            addedCount++;
                        }
                    });
                    
                    if (addedCount > 0) {
                        renderLogTable(currentLogs);
                        showToast(`Paquet reçu : ${addedCount} entrées ajoutées.`);
                    } else {
                        showToast("Données déjà présentes.");
                    }
                }
            } catch (e) {
                console.error(e);
                // Ignorer les erreurs de parsing QR non pertinents
            }
        }
        
        // --- LOGIQUE MODALE WEBRTC ---
        function openWebRtcModal() {
            document.getElementById('modalBackdrop').style.display = 'block';
            webrtcModal.style.display = 'block';
            
            NetService.stopWebRtcScanner(); // S'assurer que le scanner est arrêté à l'ouverture
            
            // Masquer/Afficher les vues selon l'état de connexion
            const isConnected = PeerService.isHost || PeerService.hostId;
            document.getElementById('webrtc-active-controls').style.display = isConnected ? 'flex' : 'none';
            document.getElementById('webrtc-login-view').style.display = isConnected ? 'none' : 'block';
            document.getElementById('webrtc-host-view').style.display = PeerService.isHost ? 'block' : 'none';
            document.getElementById('webrtc-client-view').style.display = !PeerService.isHost && PeerService.hostId ? 'block' : 'none';
            
            if (PeerService.isHost) NetService.showHostUI(PeerService.localId);
            else if (PeerService.hostId) NetService.showClientUI(PeerService.hostId);
        }
        
        function closeWebRtcModal() {
            NetService.stopWebRtcScanner(); // Arrêter le scanner avant de fermer
            document.getElementById('modalBackdrop').style.display = 'none';
            webrtcModal.style.display = 'none';
        }
        
        function showDisconnectModal() {
             // Si déjà déconnecté, la modale n'est pas nécessaire, on ouvre la modale de connexion
             if (!PeerService.isHost && !PeerService.hostId) {
                 openWebRtcModal();
                 return;
             }
             
             document.getElementById('disconnectMessage').textContent = PeerService.isHost 
                ? "Confirmer la déconnexion de la session HÔTE ? Tous les clients seront déconnectés."
                : "Confirmer la déconnexion de la session CLIENT ?";
            document.getElementById('modalBackdrop').style.display = 'block';
            document.getElementById('disconnectModal').style.display = 'block';
        }
        
        function hideDisconnectModal() {
            document.getElementById('modalBackdrop').style.display = 'none';
            document.getElementById('disconnectModal').style.display = 'none';
        }
        
        // --- INIT PRINCIPALE ---
        document.addEventListener('DOMContentLoaded', () => {
            const isDarkMode = localStorage.getItem('theme') === 'dark' || !localStorage.getItem('theme');
            if (!isDarkMode) { document.body.classList.replace('dark-mode', 'light-mode'); }
            document.getElementById('darkModeIcon').textContent = isDarkMode ? 'nightlight' : 'clear_day';
            const isDockCollapsed = localStorage.getItem('dockCollapsed') === 'true';
            if (!isDockCollapsed) { document.getElementById('dockMenu').classList.remove('collapsed'); }
            document.querySelector('#dockToggleBtn .material-symbols-outlined').textContent = isDockCollapsed ? 'expand_less' : 'expand_more';

            document.getElementById('fullscreenToggle').addEventListener('click', toggleFullscreen);
            document.getElementById('darkModeToggle').addEventListener('click', handleThemeToggle);
            document.getElementById('dockToggleBtn').addEventListener('click', toggleDock);
            document.addEventListener('fullscreenchange', updateFullscreenIcon); updateFullscreenIcon(); 
            updateTimeInput(); setInterval(updateTimeInput, 60000);
            heureInput.addEventListener('change', () => { isTimeInputManuallyChanged = true; });

            logForm.addEventListener('submit', handleAddLogEntry);
            const history = loadHistory(); paxColorMap = history.paxColorMap; updateDatalists(history.lieux, history.fp);
            loadTitle(); interventionTitleInput.addEventListener('input', saveTitle);
            initPaxModeAndColors();

            logTableBody.addEventListener('dragstart', handleDragStart);
            logTableBody.addEventListener('dragover', (e) => handleDragOver.call(e.target.closest('tr') || logTableBody, e));
            logTableBody.addEventListener('drop', handleDrop); logTableBody.addEventListener('dragend', handleDragEnd); 
            logTableBody.addEventListener('click', handleDeleteButtonClick);

            renderLogTable(loadLogData()); // Rendu initial

            previewPdfDockBtn.addEventListener('click', downloadPdf);
            exportJsonDockBtn.addEventListener('click', exportJson);
            importJsonDockBtn.addEventListener('click', () => jsonImportInput.click());
            jsonImportInput.addEventListener('change', importJson);
            resetDataDockBtn.addEventListener('click', showResetModal);
            document.getElementById('confirmResetBtn').addEventListener('click', handleResetData);
            document.getElementById('cancelResetBtn').addEventListener('click', hideResetModal);
            sortTimeBtn.addEventListener('click', sortLogTableByTime);

            // Listeners Transfert QR local
            transferDockBtn.addEventListener('click', openTransferModal);
            closeTransferBtn.addEventListener('click', closeTransferModal);
            transferTabs.forEach(btn => btn.addEventListener('click', (e) => switchTransferTab(e.target.dataset.tab)));
            
            // CORRECTION: Ajout des écouteurs pour la navigation QR séquentielle
            document.getElementById('prevQrBtn').addEventListener('click', () => {
                if (currentQrIndex > 0) { currentQrIndex--; showQR(currentQrIndex); }
            });
            document.getElementById('nextQrBtn').addEventListener('click', () => {
                if (currentQrIndex < qrChunks.length - 1) { currentQrIndex++; showQR(currentQrIndex); }
            });
            
            // Listeners WebRTC
            webrtcDockBtn.addEventListener('click', openWebRtcModal);
            closeWebRtcModalBtn.addEventListener('click', closeWebRtcModal);
            
            // Toggle du scanner QR WebRTC
            btnScanQr.addEventListener('click', () => {
                if (btnScanQr.classList.contains('action')) { // Si c'est l'état 'Arrêter Scan'
                    NetService.stopWebRtcScanner();
                } else { // Si c'est l'état 'Scanner QR Code'
                    NetService.startWebRtcScanner();
                }
            });
            
            document.getElementById('btn-create-host').addEventListener('click', () => { 
                PeerService.createHost();
                closeWebRtcModal(); // Fermer la modale après l'action
            });
            
            document.getElementById('btn-join-session').addEventListener('click', () => {
                const id = document.getElementById('input-join-id').value.trim();
                if (id) {
                    PeerService.joinClient(id);
                    closeWebRtcModal(); // Fermer la modale après l'action
                } else { showToast("Veuillez entrer un ID de canal.", true); }
            });
            
            document.getElementById('btn-paste-id').addEventListener('click', () => {
                navigator.clipboard.readText().then(t => document.getElementById('input-join-id').value = t).catch(() => showToast("Erreur de collage.", true));
            });

            document.getElementById('disconnect-session-btn').addEventListener('click', showDisconnectModal);
            document.getElementById('cancelDisconnectBtn').addEventListener('click', hideDisconnectModal);
            document.getElementById('confirmDisconnectBtn').addEventListener('click', () => {
                PeerService.disconnect(true);
                hideDisconnectModal();
                closeWebRtcModal();
                showToast("Session WebRTC déconnectée.", true);
            });
            
            // Listener pour fermer les modales en cliquant sur le fond
            document.getElementById('modalBackdrop').addEventListener('click', (e) => { 
                if (e.target.id === 'modalBackdrop') { 
                    hideResetModal(); 
                    closeTransferModal(); 
                    closeWebRtcModal();
                    hideDisconnectModal();
                } 
            });
            
            // Chargement de la session WebRTC persistante
            NetService.loadSession();

        });
    </script>
</body>
</html>





