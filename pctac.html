<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PC Tac</title>
    <link rel="icon" href="favicon.ico" sizes="any" type="image/png">
    <link rel="icon" href="favicon.ico" type="image/svg+xml">
    <link rel="apple-touch-icon" href="favicon.ico">
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Saira+Stencil+One:wght@400;500&display=swap" rel="stylesheet">
    <!-- Utilisation des Material Symbols Outlined -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <style>
        /* Définition des couleurs spécifiques pour PC Tac */
        :root {
            --bg-body: #000000; 
            --bg-container: #111111; 
            --bg-interactive: #2a2a2a;
            --text-primary: #e0e0e0; 
            --text-secondary: #95a5a6; 
            --border-color: #444444;
            --accent-blue: #5b9bd5; 
            --accent-hover: #4a7aa5; 
            --danger-red: #be1b09; /* Adversaire */
            --civil-yellow: #f1c40f; /* Otage/Civil */
            --inter-blue: #3498db; /* Inter */
            --ao-green: #2ecc71; /* AO */
            --trash-color: #6c757d;
            --success-green: #2ecc71;
            
            /* NOUVEAU: Couleurs pour le mode libre (12 couleurs DISTINCTES du mode standard) */
            --free-color-1: #800000; /* Bordeaux (Maroon) */
            --free-color-2: #B87333; /* Cuivre (Brown) */
            --free-color-3: #FFDB58; /* Jaune Moutarde */
            --free-color-4: #A3D900; /* Vert Lime */
            --free-color-5: #00FFFF; /* Cyan */
            --free-color-6: #000080; /* Bleu Marine (Navy) */
            --free-color-7: #FF69B4; /* Rose Vif (Hot Pink) */
            --free-color-8: #FF8C00; /* Orange Foncée */
            --free-color-9: #8A2BE2; /* Bleu Violet */
            --free-color-10: #008080; /* Sarcelle (Teal) */
            --free-color-11: #C0C0C0; /* Argent (Silver) */
            --free-color-12: #ffffff; /* Blanc pur */
        }
        body.light-mode {
            --bg-body: #d2d3d59c; 
            --bg-container: #ffffff; 
            --bg-interactive: #e9ecef;
            --text-primary: #212529; 
            --text-secondary: #6c757d; 
            --accent-blue: #002e91;
            --border-color: #adb5bd;
            --trash-color: #000000;
        }
        #main-footer { width: 100%; text-align: center; margin-top: 2rem; padding: 1rem; color: var(--accent-blue); font-size: 0.75rem;border-top: 1px solid var(--accent-blue);}
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { font-size: 16px; }
        body { 
            font-family: 'Oswald', sans-serif; background-color: var(--bg-body); color: var(--text-primary); 
            line-height: 1.6; padding: 10px; padding-bottom: 90px;
            transition: background-color 0.3s, color 0.3s; 
        }
        .container { 
            width: 100%; max-width: 1000px; margin: auto; 
            background: var(--bg-container); padding: 20px; 
            border-radius: 8px; border: 1px solid var(--border-color); 
            position: relative; 
        }
        h1 { 
            /* Titre en bleu (couleur Inter) */
            font-size: 2.5em; margin-bottom: 20px; color: var(--inter-blue); 
            font-family: 'Saira Stencil One', sans-serif; text-align: center; 
            letter-spacing: 2px; font-weight: 400; 
        }
        
        /* Titre de l'intervention */
        #intervention-title-container {
            margin-bottom: 20px;
            padding: 10px 15px;
            background-color: var(--bg-interactive);
            border-radius: 8px;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        #intervention_title_input {
            border: none;
            background-color: transparent;
            font-size: 1.2em;
            font-weight: 500;
            padding: 5px 0;
            color: var(--accent-blue);
        }
        #intervention-title-container label {
             color: var(--text-secondary);
        }

        /* Formulaire */
        .log-entry-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-interactive);
            position: relative; /* IMPORTANT pour le positionnement absolu du toggle */
        }

        .log-entry-form h3 {
            /* Ajout d'une marge à droite pour ne pas chevaucher le toggle en haut à droite */
            padding-right: 150px; 
        }
        
        .form-row {
            display: grid;
            gap: 10px;
        }
        
        /* Grille pour les grands écrans */
        @media (min-width: 768px) {
            /* On modifie légèrement la grille pour optimiser l'espace si pas d'autocomplétion */
            .form-row.main-fields {
                grid-template-columns: 0.8fr 1.2fr 1fr 1fr;
                align-items: end;
            }
            .form-row.text-fields {
                grid-template-columns: 1fr;
            }
        }
        
        /* Grille pour les mobiles (IMPORTANT: 1 colonne pour un empilement facile) */
        @media (max-width: 767px) {
            .form-row {
                 grid-template-columns: 1fr;
            }
            .form-row.main-fields > div {
                 margin-bottom: 10px;
            }
            .form-row.main-fields {
                 grid-template-columns: 1fr;
            }
            /* L'heure vient en premier, suivi du PAX, puis des lieux */
            .form-row.main-fields > div:nth-child(1) { order: 1; } /* Heure */
            .form-row.main-fields > div:nth-child(2) { order: 2; } /* Pax */
            .form-row.main-fields > div:nth-child(3) { order: 3; } /* Lieu */
            .form-row.main-fields > div:nth-child(4) { order: 4; } /* Fenetre/Porte */
            
            /* Sur mobile, on enlève la position absolue pour que le toggle se place sous le titre */
             #pax_mode_toggle_container {
                position: static; 
                margin-bottom: 10px;
                justify-content: center;
            }
            .log-entry-form h3 {
                padding-right: 0; 
            }
        }

        label { 
            display: block; margin-bottom: 4px; font-weight: bold; 
            color: var(--text-secondary); font-size: 0.9em;
        }
        /* OPTIMISATION: taille des inputs augmentée sur mobile pour le toucher */
        input, textarea, select { 
            width: 100%; padding: 12px 8px; /* Padding vertical augmenté */
            border: 1px solid var(--border-color); 
            border-radius: 4px; font-size: 1.1em; /* Texte plus grand */
            background-color: var(--bg-body); color: var(--text-primary); 
            font-family: 'Oswald', sans-serif; 
            min-height: 50px; /* Hauteur minimale augmentée */
        }
        
        /* Conteneur PAX - Bascule */
        #pax_mode_toggle_container {
            /* NOUVEAU POSITIONNEMENT: Haut droite du formulaire */
            position: absolute; 
            top: 15px; /* Décalage du padding du form */
            right: 15px; 
            display: flex;
            gap: 5px; 
            z-index: 10;
        }
        .mode-toggle-btn {
            background-color: var(--bg-body);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 10px 15px; 
            border-radius: 4px;
            font-size: 1em; 
            cursor: pointer;
            transition: all 0.2s;
        }
        .mode-toggle-btn.active {
             background-color: var(--accent-blue);
             color: white;
             border-color: var(--accent-blue);
        }

        /* Sélecteurs PAX */
        .pax-select-wrapper {
            transition: all 0.3s ease-in-out;
        }
        .pax-select {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        /* OPTIMISATION MOBILE: Taille des boutons PAX augmentée pour le toucher */
        .pax-select-option {
            flex-grow: 1;
            padding: 18px 10px; /* ENCORE PLUS GRAND */
            border: 2px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            transition: all 0.2s;
            min-width: 80px;
            display: block;
            font-size: 1.2em; /* Très lisible */
            line-height: 1;
        }
        .pax-select-option:hover {
            opacity: 0.8;
        }
        .pax-select-option.selected {
            border-width: 4px;
        }

        .pax-select-option[data-pax="Adversaire"] { background-color: var(--danger-red); color: white; }
        .pax-select-option[data-pax="Otage"], .pax-select-option[data-pax="Civil"] { background-color: var(--civil-yellow); color: black; }
        .pax-select-option[data-pax="Inter"] { background-color: var(--inter-blue); color: white; }
        .pax-select-option[data-pax="AO"] { background-color: var(--ao-green); color: black; }

        /* NOUVEAU: Sélecteur de couleur libre */
        #free_mode_options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 8px; /* Augmenté */
            margin-bottom: 5px;
        }
        .color-swatch {
            width: 35px; /* Augmenté */
            height: 35px; /* Augmenté */
            border-radius: 50%;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: transform 0.1s, border-color 0.2s;
        }
        .color-swatch:hover {
            transform: scale(1.1);
        }
        .color-swatch.selected {
            border: 4px solid var(--accent-blue);
            transform: scale(1.1);
        }
        
        /* Styles spécifiques pour chaque couleur libre (Mis à jour) */
        .swatch-1 { background-color: var(--free-color-1); }
        .swatch-2 { background-color: var(--free-color-2); }
        .swatch-3 { background-color: var(--free-color-3); }
        .swatch-4 { background-color: var(--free-color-4); }
        .swatch-5 { background-color: var(--free-color-5); }
        .swatch-6 { background-color: var(--free-color-6); }
        .swatch-7 { background-color: var(--free-color-7); }
        .swatch-8 { background-color: var(--free-color-8); }
        .swatch-9 { background-color: var(--free-color-9); }
        .swatch-10 { background-color: var(--free-color-10); }
        .swatch-11 { background-color: var(--free-color-11); border-color: #ffffff; }
        .swatch-12 { background-color: var(--free-color-12); border-color: #000000; }
        
        /* Tableau de Log */
        #logTableContainer {
            overflow-x: auto;
            margin-top: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-interactive);
        }
        #logTable {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            min-width: 600px;
        }
        #logTable th, #logTable td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        #logTable th {
            background-color: var(--bg-interactive);
            color: var(--accent-blue);
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: sticky;
            top: 0;
        }
        #logTable tbody tr:hover {
            background-color: var(--bg-body);
        }

        /* Style pour l'élément déplacé */
        #logTable tbody tr.dragging {
            opacity: 0.5;
            border: 2px dashed var(--accent-blue);
            cursor: grabbing !important;
        }
        
        /* NOUVEAU: Style pour la ligne ajoutée */
        #logTable tbody tr.just-added {
            animation: flash-row 1.5s ease-out;
        }
        @keyframes flash-row {
            0% { background-color: var(--accent-blue); }
            50% { background-color: var(--bg-body); }
            100% { background-color: transparent; }
        }

        .pax-cell {
            font-weight: bold;
            padding: 5px;
            border-radius: 4px;
            text-align: center;
            font-size: 0.9em;
            word-break: break-word; /* Pour les noms longs en mode libre */
        }
        
        /* Logique de couleur pour le tableau */
        .pax-Adversaire { background-color: var(--danger-red); color: white; }
        .pax-Otage, .pax-Civil { background-color: var(--civil-yellow); color: black; }
        .pax-Inter { background-color: var(--inter-blue); color: white; }
        .pax-AO { background-color: var(--ao-green); color: black; }
        
        /* Modification pour la croix de suppression */
        .delete-btn {
            background: none;
            border: none;
            color: var(--trash-color);
            cursor: pointer;
            font-size: 1.2em;
            transition: color 0.2s;
            float: right; 
            margin-left: 5px;
            line-height: 1; 
        }
        .delete-btn:hover {
            color: var(--danger-red);
        }
        /* Nouvelle classe pour la cellule heure/suppression */
        .heure-action-cell {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 5px;
            padding-right: 0 !important; 
        }
        .heure-cell-text {
            flex-grow: 1;
            font-weight: bold;
        }

        
        /* Boutons d'action */
        .action-button {
            padding: 16px 20px; /* Plus grand pour le toucher */
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Oswald', sans-serif;
            font-size: 1.2em; /* Plus lisible */
            font-weight: 500;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .add-log-btn {
            background-color: var(--accent-blue);
            color: white;
            margin-top: 15px;
        }
        .add-log-btn:hover {
            background-color: var(--accent-hover);
        }

        .sort-button {
            background-color: var(--bg-interactive);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .sort-button:hover {
            background-color: var(--bg-body);
        }

        /* Dock Flottant */
        .dock-menu { 
            position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 10px; padding: 10px; z-index: 1000; 
            background-color: rgba(30, 30, 30, 0.7); 
            border: 1px solid var(--border-color); 
            border-radius: 35px; backdrop-filter: blur(10px); 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: all 0.3s ease-in-out; 
        }
        body.light-mode .dock-menu {
             background-color: rgba(255, 255, 255, 0.7); 
             box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        /* Style pour les boutons P2P selon l'état */
        .dock-menu-item.p2p-active {
            box-shadow: 0 0 15px 3px var(--ao-green); /* Bordure verte brillante si actif */
            color: var(--ao-green);
        }
        .dock-menu-item.p2p-connecting {
            box-shadow: 0 0 15px 3px var(--accent-blue);
            color: var(--accent-blue);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
          0% { box-shadow: 0 0 5px 0px var(--accent-blue); }
          50% { box-shadow: 0 0 15px 5px var(--accent-blue); }
          100% { box-shadow: 0 0 5px 0px var(--accent-blue); }
        }


        .dock-menu-item { 
            display: flex; align-items: center; justify-content: center; 
            background-color: var(--bg-container); color: var(--text-primary); 
            border: 1px solid var(--border-color); 
            border-radius: 50%; width: 50px; height: 50px; 
            font-size: 28px; cursor: pointer; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
            transition: all 0.2s; text-decoration: none; flex-shrink: 0; 
        }
        .dock-menu-item:hover { transform: scale(1.1); }
        .dock-menu.collapsed { 
            width: 55px; height: 55px; padding: 5px; 
            border-radius: 50%; border: none; 
            background-color: transparent; 
        }
        .dock-menu.collapsed .dock-menu-item:not(#dockToggleBtn) { 
            opacity: 0; width: 0; margin-left: -10px; visibility: hidden; 
        }
        #dockToggleBtn .material-symbols-outlined { transition: transform 0.3s ease; }
        .dock-menu.collapsed #dockToggleBtn .material-symbols-outlined { transform: rotate(180deg); }

        /* Styles spécifiques au mobile pour le dock */
        @media (max-width: 600px) {
            body { padding-bottom: 70px; } 
            .dock-menu {
                /* Permet de déborder mais maintient le centrage et la zone de clic */
                width: 95vw; 
                padding: 6px; 
                gap: 5px; /* Réduit l'espacement pour plus d'items */
                justify-content: center; 
                min-width: unset;
                overflow-x: auto; /* Autorise le défilement horizontal si nécessaire */
            }
            .dock-menu-item {
                width: 38px; 
                height: 38px; 
                font-size: 20px; 
                flex-shrink: 0; /* Empêche les items de rétrécir */
            }
             .dock-menu.collapsed {
                width: 38px; 
                overflow: hidden; /* Cache le débordement quand réduit */
            }
        }

        /* Modales */
        .custom-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--bg-container);
            border: 2px solid var(--accent-blue);
            border-radius: 8px;
            padding: 20px;
            z-index: 1001;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
            width: 400px;
            display: none;
            animation: fadeIn 0.3s ease-out;
        }

        .custom-modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-buttons {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 10px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
        }

        #confirmResetBtn, #closeMessageModalBtn {
            background-color: var(--danger-red);
            color: white;
            border: none;
        }

        #cancelResetBtn, #modalMessageBtn {
            background-color: var(--bg-interactive);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        /* Styles spécifiques à la modale P2P */
        #p2pModal {
            width: 450px;
            max-width: 95vw;
        }
        #qrCodeContainer {
             padding: 10px;
             background-color: white;
             border-radius: 4px;
             display: flex;
             justify-content: center;
             margin-bottom: 10px;
        }
        #qrCodeContainer canvas {
             max-width: 100%;
             height: auto;
        }
        #p2pStatus {
            font-weight: bold;
            text-align: center;
            margin-top: 15px;
        }
        #signalingInput {
            width: 100%;
            margin-top: 10px;
            min-height: 100px;
            font-size: 0.8em;
            font-family: monospace;
            resize: vertical;
        }
        #p2pModal .role-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        /* Styles pour le scanner QR Code */
        #qrScannerContainer {
            width: 100%;
            max-width: 350px;
            margin: 0 auto;
        }
        /* Style pour la rangée de copie/scan */
        .copy-scan-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .copy-scan-row button {
            flex: 1;
            padding: 10px 15px;
            font-size: 0.95em;
        }
        /* Rendre l'input plus lisible en mode connecté/finalisation */
        .signaling-input-wrapper {
             position: relative;
             margin-top: 10px;
        }


    </style>
</head>
<body class="dark-mode">
    <!-- Champ de fichier caché pour l'importation de JSON -->
    <input type="file" id="jsonImportInput" accept=".json" style="display: none;">

    <!-- Modale de Confirmation de Réinitialisation -->
    <div class="custom-modal-backdrop" id="modalBackdrop"></div>
    <div class="custom-modal" id="resetModal">
        <h3 style="color: var(--accent-blue); margin-bottom: 10px;">Confirmer la Réinitialisation</h3>
        <p style="color: var(--text-primary);">Êtes-vous sûr de vouloir réinitialiser TOUTES les données de journalisation du PC Tac ? Cette action est irréversible et supprimera tout le tableau.</p>
        <div class="modal-buttons">
            <button id="confirmResetBtn">Oui, Réinitialiser</button>
            <button id="cancelResetBtn">Annuler</button>
        </div>
    </div>
    
    <!-- Modale de Message (pour remplacer alert()) -->
    <div class="custom-modal" id="messageModal">
        <h3 id="modalMessageTitle" style="margin-bottom: 10px;">Message</h3>
        <p id="modalMessageContent" style="color: var(--text-primary);"></p>
        <div class="modal-buttons">
            <button id="closeMessageModalBtn">OK</button> 
        </div>
    </div>

    <!-- NOUVEAU: Modale de Synchronisation P2P (WebRTC) -->
    <div class="custom-modal" id="p2pModal">
        <h3 style="color: var(--accent-blue); margin-bottom: 10px;">Synchronisation P2P (WebRTC)</h3>
        
        <p id="p2pInstructions" style="color: var(--text-secondary); margin-bottom: 10px;"></p>

        <div id="qrCodeContainer" style="display: none;"></div>
        
        <div id="signalingInputWrapper" class="signaling-input-wrapper">
             <textarea id="signalingInput" placeholder="Collez ici le code de signalisation du pair (Hôte ou Client)..." style="display: none;"></textarea>
             
             <!-- Boutons de Copie pour l'Offer/Answer (Hôte/Client) -->
             <div class="copy-scan-row">
                <button id="copyCodeBtn" style="background-color: var(--inter-blue); color: white; display: none;">
                    <span class="material-symbols-outlined" style="font-size: 1.1em;">content_copy</span> Copier le code
                </button>
                <button id="startScanBtn" style="background-color: var(--inter-blue); color: white; display: none;">
                    <span class="material-symbols-outlined" style="font-size: 1.1em;">qr_code_scanner</span> Scanner l'Offer
                </button>
             </div>
        </div>
        
        <!-- NOUVEAU: Conteneur de scan (affiché seulement en mode client) -->
        <div id="qrScannerContainer" style="display: none;"></div>
        
        <p id="p2pStatus" class="p2p-connecting" style="display: none;">Démarrage...</p>

        <div class="modal-buttons role-buttons">
            <button id="startHostBtn" style="background-color: var(--ao-green); color: white;">Démarrer Hôte (Offer)</button>
            <button id="startClientBtn" style="background-color: var(--accent-blue); color: white;">Démarrer Client (Answer)</button>
        </div>
        
        <div class="modal-buttons">
            <button id="p2pDisconnectBtn" style="display: none;">Déconnecter</button>
            <button id="p2pCloseModalBtn" style="background-color: var(--danger-red); color: white;">Fermer</button>
        </div>
    </div>
    
    <div class="container">
        <h1>PC Tac</h1>

        <!-- Titre de l'intervention pour le PDF -->
        <div id="intervention-title-container">
            <label for="intervention_title_input">Nom de l'intervention :</label>
            <input type="text" id="intervention_title_input" placeholder="Ex: Exercice Alpha / Prise d'otage" value="">
        </div>
        
        <!-- Formulaire d'ajout de ligne -->
        <form id="log-form" class="log-entry-form">
            <h3 style="color: var(--accent-blue); margin-top: 0;">Ajouter une entrée</h3>
            
            <!-- NOUVEL EMPLACEMENT du toggle : Haut à droite du formulaire -->
            <div id="pax_mode_toggle_container">
                <button type="button" class="mode-toggle-btn active" data-mode="standard">Forcené</button>
                <button type="button" class="mode-toggle-btn" data-mode="free">TP</button>
            </div>
            <!-- Fin NOUVEL EMPLACEMENT -->
            
            <!-- OPTIMISATION MOBILE: Le lieu et la fenêtre/porte sont déplacés à la fin de la grille pour une séquence Heure -> PAX -> Saisie rapide -->
            <div class="form-row main-fields">
                 <div>
                     <label for="heure_input">Heure (HH:MM)</label>
                     <!-- Type="time" utilise l'interface de sélection d'heure native du mobile, très rapide -->
                     <input type="time" id="heure_input" required value="">
                 </div>
                 
                 <div>
                     <label>Pax</label>
                     
                     <div id="pax_select_wrapper_standard" class="pax-select-wrapper">
                         <div class="pax-select" id="pax_select_container">
                             <span class="pax-select-option" data-pax="Adversaire">Adversaire</span>
                             <span class="pax-select-option" data-pax="Otage">Civil/Otage</span>
                             <span class="pax-select-option" data-pax="Inter">Inter</span>
                             <span class="pax-select-option" data-pax="AO">AO</span>
                         </div>
                     </div>
                     
                     <div id="pax_select_wrapper_free" class="pax-select-wrapper" style="display: none;">
                         <div id="free_mode_options">
                             <div class="color-palette" id="free_color_palette">
                                 <!-- Les swatches de couleur sont générés par JS -->
                             </div>
                             <input type="text" id="free_pax_input" placeholder="Nom du TP (Ex: TP Alpha)" value="" />
                             <input type="hidden" id="free_color_input" value="#800000">
                         </div>
                     </div>
                     
                     <input type="hidden" id="pax_input" required value="Adversaire">
                     <input type="hidden" id="pax_mode_input" value="standard">
                     <input type="hidden" id="pax_custom_color_input" value="#800000">
                 </div>
                 
                 <div>
                     <label for="lieu_input">Lieu</label>
                     <!-- NOUVEAU: Ajout de datalist pour l'autocomplétion -->
                     <input type="text" id="lieu_input" list="lieu_history" placeholder="Baptême terrain (A,B...)" value="">
                     <datalist id="lieu_history"></datalist>
                 </div>

                 <div>
                     <label for="fenetre_porte_input">Fenêtre/Porte</label>
                     <!-- NOUVEAU: Ajout de datalist pour l'autocomplétion -->
                     <input type="text" id="fenetre_porte_input" list="fp_history" placeholder="Ex: B1,A102" value="">
                     <datalist id="fp_history"></datalist>
                 </div>
                 
            </div>
            
            <div class="form-row text-fields">
                <div style="grid-column: span 1;">
                    <label for="remarques_input">Remarques</label>
                    <!-- OPTIMISATION: Mise en évidence du champ remarques -->
                    <textarea id="remarques_input" rows="3" placeholder="Informations clés, compte-rendu..."></textarea>
                </div>
            </div>

            <button type="submit" class="action-button add-log-btn" id="addLogBtn">
                <span class="material-symbols-outlined">add_task</span> Ajouter au Log
            </button>
        </form>

        <!-- Tableau des entrées -->
        <div id="logTableContainer">
            <button type="button" class="sort-button" id="sortTimeBtn">
                <span class="material-symbols-outlined">sort</span> Trier par Heure
            </button>
            <table id="logTable">
                <thead>
                    <tr>
                        <th style="width: 15%;">Heure</th>
                        <th style="width: 15%;">Pax</th>
                        <th style="width: 20%;">Lieu</th>
                        <th style="width: 20%;">Fenêtre/Porte</th>
                        <th style="width: 30%;">Remarques</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Les lignes de log seront insérées ici -->
                </tbody>
            </table>
        </div>
        
		<footer id="main-footer">
            © PC Tac by G/ Maheux
        </footer>
    </div>
    
    <!-- Dock Flottant -->
    <div class="dock-menu collapsed" id="dockMenu">
        <!-- Bouton de bascule du dock -->
        <div class="dock-menu-item" id="dockToggleBtn" title="Ouvrir/Réduire">
            <span class="material-symbols-outlined">expand_less</span>
        </div>
        <!-- Bouton Home -->
        <a class="dock-menu-item" href="index.html" title="Accueil" style="text-decoration: none;">
            <span class="material-symbols-outlined">home</span>
        </a>
        
        <!-- Bouton Export JSON -->
        <div class="dock-menu-item" id="exportJsonDockBtn" title="Exporter les données au format JSON">
            <span class="material-symbols-outlined">save</span>
        </div>
          <!-- Bouton Import JSON -->
          <div class="dock-menu-item" id="importJsonDockBtn" title="Importer des données au format JSON">
              <span class="material-symbols-outlined">upload_file</span>
          </div>
        
        <!-- NOUVEAU: Bouton Démarrer la Synchronisation P2P -->
        <div class="dock-menu-item" id="p2pToggleBtn" title="Synchronisation P2P (WebRTC)">
            <span class="material-symbols-outlined">wifi_tethering</span>
        </div>

        <div class="dock-menu-item" id="darkModeToggle" title="Changer le thème">
            <span class="material-symbols-outlined" id="darkModeIcon">nightlight</span>
        </div>
        <div class="dock-menu-item" id="fullscreenToggle" title="Plein écran">
            <span class="material-symbols-outlined" id="fullscreenIcon">fullscreen</span>
        </div>
        <!-- Bouton PDF (téléchargement direct) -->
          <div class="dock-menu-item" id="previewPdfDockBtn" title="Générer et télécharger le PDF">
              <span class="material-symbols-outlined">picture_as_pdf</span>
          </div>
        <!-- Bouton Réinitialisation -->
          <div class="dock-menu-item" id="resetDataDockBtn" title="Réinitialiser toutes les données">
              <span class="material-symbols-outlined" style="color: var(--danger-red);">delete_forever</span>
          </div>
    </div>

    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <!-- Bibliothèques pour la nouvelle logique P2P (WebRTC et QR Code) -->
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <!-- CHANGEMENT DE CDN : Utilisation de Cloudflare pour html5-qrcode -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5-qrcode/2.3.4/html5-qrcode.min.js"></script>
    <!-- simple-peer est une bibliothèque légère pour simplifier l'API WebRTC P2P -->
    <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.0/simplepeer.min.js"></script>
    <script>
        const LOCAL_STORAGE_KEY = 'pcTacLogData';
        const HISTORY_STORAGE_KEY = 'pcTacHistory';
        const TITLE_STORAGE_KEY = 'pcTacTitle';
        
        // --- COULEURS ÉTENDUES ---
        const FREE_MODE_COLORS = [
            { hex: '#800000', name: 'Bordeaux' },      
            { hex: '#B87333', name: 'Cuivre' },        
            { hex: '#FFDB58', name: 'Jaune Moutarde' },
            { hex: '#A3D900', name: 'Vert Lime' },      
            { hex: '#00FFFF', name: 'Cyan' },          
            { hex: '#000080', name: 'Bleu Marine' },    
            { hex: '#FF69B4', name: 'Rose Vif (Hot Pink)' },      
            { hex: '#FF8C00', name: 'Orange Foncée' },  
            { hex: '#8A2BE2', name: 'Bleu Violet' },    
            { hex: '#008080', name: 'Sarcelle' },      
            { hex: '#C0C0C0', name: 'Argent' },        
            { hex: '#ffffff', name: 'Blanc' }          
        ];

        // Couleurs statiques pour le PDF (Standard)
        const PDF_PAX_COLORS = {
            'Adversaire': { text: 'Adversaire', color: '#be1b09', fontColor: '#ffffff' },
            'Otage': { text: 'Civil/Otage', color: '#f1c40f', fontColor: '#000000' }, 
            'Civil': { text: 'Civil/Otage', color: '#f1c40f', fontColor: '#000000' }, 
            'Inter': { text: 'Inter', color: '#3498db', fontColor: '#ffffff' },
            'AO': { text: 'AO', color: '#2ecc71', fontColor: '#000000' }
        };

        const logTableBody = document.querySelector('#logTable tbody');
        const logForm = document.getElementById('log-form');
        const heureInput = document.getElementById('heure_input');
        const paxInput = document.getElementById('pax_input');
        const paxModeInput = document.getElementById('pax_mode_input'); 
        const paxCustomColorInput = document.getElementById('pax_custom_color_input'); 
        const freePaxInput = document.getElementById('free_pax_input'); 
        const lieuInput = document.getElementById('lieu_input');
        const fenetrePorteInput = document.getElementById('fenetre_porte_input');
        const remarquesInput = document.getElementById('remarques_input');
        const paxSelectContainer = document.getElementById('pax_select_container');
        const previewPdfDockBtn = document.getElementById('previewPdfDockBtn');
        const resetDataDockBtn = document.getElementById('resetDataDockBtn');
        const jsonImportInput = document.getElementById('jsonImportInput'); 
        const exportJsonDockBtn = document.getElementById('exportJsonDockBtn'); 
        const importJsonDockBtn = document.getElementById('importJsonDockBtn'); 
        const lieuHistoryDatalist = document.getElementById('lieu_history');
        const fpHistorDatalist = document.getElementById('fp_history');
        const interventionTitleInput = document.getElementById('intervention_title_input');
        const sortTimeBtn = document.getElementById('sortTimeBtn');
        // NOUVEAUX ÉLÉMENTS P2P
        const p2pToggleBtn = document.getElementById('p2pToggleBtn');
        
        // Modales P2P
        const modalBackdrop = document.getElementById('modalBackdrop');
        const p2pModal = document.getElementById('p2pModal');
        const p2pInstructions = document.getElementById('p2pInstructions');
        const qrCodeContainer = document.getElementById('qrCodeContainer');
        const signalingInput = document.getElementById('signalingInput');
        const copyCodeBtn = document.getElementById('copyCodeBtn'); // Nouveau bouton Copier
        const p2pStatus = document.getElementById('p2pStatus');
        const startHostBtn = document.getElementById('startHostBtn');
        const startClientBtn = document.getElementById('startClientBtn');
        const p2pDisconnectBtn = document.getElementById('p2pDisconnectBtn');
        const p2pCloseModalBtn = document.getElementById('p2pCloseModalBtn');
        const startScanBtn = document.getElementById('startScanBtn'); // Nouveau bouton de scan
        
        // Variables pour suivre l'état
        let isTimeInputManuallyChanged = false;
        let paxColorMap = {}; // Map pour lier PAX libre à sa couleur
        let colorPaxMap = {}; // Map inversée pour lier Couleur -> dernier Nom de PAX libre
        let html5QrcodeScanner = null; // Instance du scanner
        
        // --- P2P Manager ---
        const P2PManager = {
            peer: null,
            isHost: false,
            isConnected: false,
            // Configuration WebRTC STUN/TURN (utilise des serveurs publics pour la traversée NAT)
            config: {
                // Utilisation des serveurs STUN publics
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478' }
                ]
            },

            /**
             * Démarre la connexion en tant qu'Hôte (crée l'Offer).
             */
            startHost() {
                this.disconnect();
                this.isHost = true;
                
                // 1. Créer le Peer (initiator: true pour générer l'Offer)
                this.peer = new SimplePeer({ initiator: true, trickle: false, config: this.config });
                this.setupPeerEvents();
                
                this.updateUI('host_waiting');
            },

            /**
             * Démarre la connexion en tant que Client (attend l'Offer, puis génère l'Answer).
             */
            startClient() {
                this.disconnect();
                this.isHost = false;
                
                // 1. Créer le Peer (initiator: false pour attendre l'Offer)
                this.peer = new SimplePeer({ initiator: false, trickle: false, config: this.config });
                this.setupPeerEvents();
                
                this.updateUI('client_waiting_offer');
            },

            /**
             * Configure les événements Peer commun (Hôte et Client).
             */
            setupPeerEvents() {
                this.peer.on('error', (err) => {
                    console.error('Erreur P2P:', err);
                    this.updateUI('error', `Erreur de connexion: ${err.message || 'Voir console.'}`);
                    this.disconnect();
                });

                this.peer.on('signal', (data) => {
                    // Événement Signal: Ceci est le message de signalisation (Offer/Answer/ICE) à échanger.
                    const signalingData = JSON.stringify(data);
                    
                    if (this.isHost) {
                        if (data.type === 'offer') {
                            // Hôte envoie l'Offer
                            this.updateUI('host_show_offer', signalingData);
                        } else if (data.type === 'answer') {
                            // L'Hôte reçoit l'Answer et la connexion démarre
                        }
                    } else {
                        if (data.type === 'answer') {
                            // Client envoie l'Answer (à coller dans l'Hôte)
                            this.updateUI('client_show_answer', signalingData);
                        }
                    }
                });

                this.peer.on('connect', () => {
                    this.isConnected = true;
                    // Mise à jour de l'UI pour un feedback visuel immédiat
                    this.updateUI('connected'); 
                    
                    // Après la connexion, l'Hôte envoie immédiatement l'état complet du Log.
                    if (this.isHost) {
                        this.sendData(getLogData());
                    }
                });

                this.peer.on('data', (data) => {
                    // Réception des données (toujours JSON stringifié)
                    try {
                        const jsonString = new TextDecoder().decode(data);
                        const parsedData = JSON.parse(jsonString);
                        
                        if (parsedData.type === 'log_update') {
                            // Mettre à jour le log et le titre
                            importLogData(parsedData.logEntries, parsedData.title);
                            showMessageModal("Synchronisation P2P", "Log mis à jour par l'Hôte.", false);
                        }
                    } catch (e) {
                        console.error("Erreur de réception de données P2P:", e);
                    }
                });
                
                this.peer.on('close', () => {
                    this.disconnect();
                });
            },

            /**
             * Envoie l'état du Log via le Data Channel (Hôte seulement).
             * @param {Array} logData - Les données de log à envoyer.
             */
            sendData(logData) {
                if (!this.isConnected || !this.isHost) return;
                
                const dataToSend = {
                    type: 'log_update',
                    title: interventionTitleInput.value.trim(),
                    logEntries: logData
                };
                const jsonString = JSON.stringify(dataToSend);
                
                try {
                    this.peer.send(jsonString);
                    console.log(`[P2P HÔTE] ${logData.length} entrées envoyées (${jsonString.length} octets)`);
                } catch (e) {
                    console.error("Échec de l'envoi P2P:", e);
                }
            },

            /**
             * Déconnecte le Peer WebRTC.
             */
            disconnect() {
                if (this.peer) {
                    this.peer.destroy();
                    this.peer = null;
                }
                this.isConnected = false;
                this.isHost = false;
                this.updateUI('disconnected');
                // Arrêter le scanner si actif
                stopQRScan(); 
            },

            /**
             * Gère l'affichage de la modale P2P.
             * @param {string} status - État courant de la connexion.
             * @param {string} payload - Données à afficher (Offer/Answer/Message).
             */
            updateUI(status, payload = '') {
                // Arrêter le scanner chaque fois que l'UI change d'état critique
                stopQRScan(); 
                
                // Rendre les éléments invisibles par défaut
                qrCodeContainer.style.display = 'none';
                signalingInput.style.display = 'none';
                p2pStatus.style.display = 'block';
                p2pDisconnectBtn.style.display = 'none';
                startHostBtn.style.display = 'block';
                startClientBtn.style.display = 'block';
                startScanBtn.style.display = 'none'; // Cacher le bouton de scan par défaut
                copyCodeBtn.style.display = 'none';  // Cacher le bouton de copie par défaut
                p2pToggleBtn.classList.remove('p2p-active', 'p2p-connecting');
                
                p2pModal.style.borderColor = 'var(--accent-blue)';
                
                qrCodeContainer.innerHTML = '';
                signalingInput.value = '';
                signalingInput.disabled = false; // Réactiver la saisie
                
                let title = "Synchronisation P2P (WebRTC)";

                switch (status) {
                    case 'host_waiting':
                        title = "HÔTE : En attente de l'Offer";
                        p2pStatus.textContent = "Génération de l'Offer en cours...";
                        p2pStatus.classList.add('p2p-connecting');
                        startHostBtn.style.display = 'none';
                        startClientBtn.style.display = 'none';
                        p2pDisconnectBtn.style.display = 'block';
                        p2pModal.style.borderColor = 'var(--ao-green)';
                        p2pInstructions.textContent = "Veuillez attendre que le QR Code (Offer) s'affiche.";
                        break;

                    case 'host_show_offer':
                        title = "HÔTE : Échanger l'Offer (Étape 1/2)";
                        qrCodeContainer.style.display = 'flex';
                        p2pStatus.textContent = "1. Faites scanner ce QR Code. 2. Collez l'Answer du Client ci-dessous.";
                        signalingInput.style.display = 'block';
                        signalingInput.placeholder = "Collez ici le code 'Answer' du Client...";
                        p2pStatus.classList.add('p2p-connecting');
                        startHostBtn.style.display = 'none';
                        startClientBtn.style.display = 'none';
                        p2pDisconnectBtn.style.display = 'block';
                        p2pModal.style.borderColor = 'var(--ao-green)';
                        copyCodeBtn.style.display = 'block'; // Afficher le bouton de copie pour l'Offer
                        
                        // Afficher l'Offer générée par simple-peer
                        new QRCode(qrCodeContainer, {
                            text: payload,
                            width: 250,
                            height: 250,
                            correctLevel: QRCode.CorrectLevel.L 
                        });
                        p2pInstructions.textContent = "Scannez l'Offer, puis collez l'Answer générée par le Client ci-dessous pour démarrer la connexion.";
                        // On stocke l'Offer dans l'input pour la copie, mais on le cache s'il y a le QR Code
                        signalingInput.value = payload;
                        break;
                    
                    case 'client_waiting_offer':
                        title = "CLIENT : Échanger l'Answer (Étape 1/2)";
                        p2pStatus.textContent = "Collez l'Offer scannée (QR Code de l'Hôte) pour générer l'Answer.";
                        signalingInput.style.display = 'block';
                        signalingInput.placeholder = "Collez ici le code 'Offer' de l'Hôte...";
                        p2pStatus.classList.add('p2p-connecting');
                        startHostBtn.style.display = 'none';
                        startClientBtn.style.display = 'none';
                        p2pDisconnectBtn.style.display = 'block';
                        startScanBtn.style.display = 'block'; // Afficher le bouton de scan
                        p2pModal.style.borderColor = 'var(--accent-blue)';
                        p2pInstructions.textContent = "Collez l'Offer de l'Hôte ci-dessous, ou utilisez le scanner pour la capturer.";
                        break;
                        
                    case 'client_show_answer':
                        title = "CLIENT : Échanger l'Answer (Étape 2/2)";
                        qrCodeContainer.style.display = 'flex';
                        p2pStatus.textContent = "Connexion en cours... (Scannez le code ou copiez le Answer)";
                        signalingInput.style.display = 'block';
                        p2pStatus.classList.add('p2p-connecting');
                        copyCodeBtn.style.display = 'block'; // Afficher le bouton de copie pour l'Answer
                        
                        new QRCode(qrCodeContainer, {
                            text: payload,
                            width: 250,
                            height: 250,
                            correctLevel: QRCode.CorrectLevel.L 
                        });
                        signalingInput.value = payload; // Afficher l'Answer en texte
                        p2pInstructions.textContent = "Scannez/copiez ce code (Answer) et donnez-le à l'Hôte pour finaliser la connexion.";
                        startHostBtn.style.display = 'none';
                        startClientBtn.style.display = 'none';
                        p2pDisconnectBtn.style.display = 'block';
                        break;

                    case 'connected':
                        p2pStatus.textContent = this.isHost ? "HÔTE CONNECTÉ (Autorité des données)" : "CLIENT CONNECTÉ (Synchronisé)";
                        p2pStatus.classList.remove('p2p-connecting');
                        p2pStatus.classList.add('p2p-active');
                        p2pToggleBtn.classList.add('p2p-active');
                        p2pModal.style.borderColor = 'var(--ao-green)';
                        startHostBtn.style.display = 'none';
                        startClientBtn.style.display = 'none';
                        p2pDisconnectBtn.style.display = 'block';
                        p2pInstructions.textContent = "La connexion est établie. Le Log se synchronise en temps réel depuis l'Hôte.";
                        // Fermer la modale après 2 secondes si le pair est connecté
                        setTimeout(hideP2PModal, 2000); 
                        break;
                        
                    case 'disconnected':
                        p2pStatus.textContent = "Déconnecté.";
                        p2pStatus.classList.remove('p2p-connecting', 'p2p-active');
                        p2pToggleBtn.classList.remove('p2p-active', 'p2p-connecting');
                        p2pInstructions.textContent = "Choisissez votre rôle pour démarrer une nouvelle session de synchronisation.";
                        break;
                        
                    case 'error':
                        p2pStatus.textContent = payload || "Erreur de connexion P2P.";
                        p2pStatus.classList.remove('p2p-connecting', 'p2p-active');
                        p2pModal.style.borderColor = 'var(--danger-red)';
                        p2pInstructions.textContent = "La connexion a échoué. Assurez-vous d'être sur le même réseau et réessayez.";
                        break;
                }
                
                document.querySelector('#p2pModal h3').textContent = title;
            },
            
            /**
             * Gère l'action de l'utilisateur après avoir copié/scanné le code.
             */
            handleSignalingExchange() {
                if (!this.peer) return;

                const signalCode = signalingInput.value.trim();
                if (!signalCode) {
                    return;
                }
                
                try {
                    const data = JSON.parse(signalCode);
                    
                    if (this.isHost) {
                        // L'Hôte s'attend à recevoir l'Answer du Client
                        if (data.type === 'answer') {
                            this.peer.signal(data);
                            // Rendre le champ de saisie non éditable et afficher un statut
                            signalingInput.disabled = true; 
                            p2pStatus.textContent = "Answer reçue. Tentative de connexion...";
                        } else {
                            showMessageModal("Erreur d'échange", "L'Hôte attend un code 'Answer' du Client.", true);
                        }
                    } else {
                        // Le Client s'attend à recevoir l'Offer de l'Hôte (pour générer l'Answer)
                        if (data.type === 'offer') {
                            // On désactive la saisie/scan après avoir reçu l'Offer
                            stopQRScan(); 
                            this.peer.signal(data);
                        } else {
                            showMessageModal("Erreur d'échange", "Le Client attend un code 'Offer' de l'Hôte.", true);
                        }
                    }
                } catch (e) {
                    showMessageModal("Erreur de décodage", "Le code copié n'est pas un JSON valide. Veuillez vérifier le scan/copier.", true);
                }
            }
        };

        // --- Fonctions de Scan QR Code et Copie ---

        const qrScannerContainer = document.getElementById('qrScannerContainer');

        function startQRScan() {
            if (typeof Html5QrcodeScanner === 'undefined') {
                 showMessageModal("Erreur de dépendance", "La bibliothèque de scan (html5-qrcode) n'est pas chargée.", true);
                 return;
            }

            // Masquer les éléments de saisie/QR code existants
            qrCodeContainer.style.display = 'none';
            signalingInput.style.display = 'none';
            copyCodeBtn.style.display = 'none'; 
            qrScannerContainer.style.display = 'block';

            startScanBtn.textContent = "Annuler le Scan";
            startScanBtn.onclick = stopQRScan; // Changer l'action du bouton

            html5QrcodeScanner = new Html5QrcodeScanner(
                "qrScannerContainer", 
                { 
                    fps: 10, 
                    qrbox: {width: 250, height: 250}, 
                    // Utiliser la caméra arrière sur mobile si disponible
                    facingMode: "environment" 
                },
                false
            );

            // LOGIQUE DE SUCCÈS DU SCAN ADAPTÉE AU P2P
            const onScanSuccess = (decodedText, decodedResult) => {
                // Arrêter le scanner
                stopQRScan(); 
                
                // Vérifier si le code scanné ressemble à une Offer WebRTC
                try {
                    const data = JSON.parse(decodedText);
                    if (data.type === 'offer') {
                        // Injecter la donnée scannée dans le champ de saisie
                        signalingInput.value = decodedText;
                        // Appeler l'échange pour générer l'Answer
                        P2PManager.handleSignalingExchange();
                    } else {
                        showMessageModal("Scan réussi, mais...", "Le code scanné n'est pas une 'Offer' WebRTC valide. Veuillez vérifier le code de l'Hôte.", true);
                    }
                } catch (e) {
                    showMessageModal("Erreur de décodage", "Le QR Code ne contient pas de données JSON WebRTC valides.", true);
                }
            };

            const onScanError = (errorMessage) => {
                // Laissez vide pour éviter les popups intempestifs. Les erreurs critiques de caméra sont souvent gérées par le timeout.
            };
            
            html5QrcodeScanner.render(onScanSuccess, onScanError);

            p2pStatus.textContent = "Veuillez pointer la caméra vers l'Offer QR de l'Hôte.";
            p2pStatus.classList.add('p2p-connecting');
        }

        function stopQRScan() {
            if (html5QrcodeScanner) {
                // Tente d'arrêter la caméra et efface le scanner
                const clearResult = html5QrcodeScanner.clear();
                if (clearResult && typeof clearResult.then === 'function') {
                    clearResult.then(() => {
                        html5QrcodeScanner = null;
                        qrScannerContainer.innerHTML = '';
                        qrScannerContainer.style.display = 'none';
                        
                        // Réinitialiser l'UI Client
                        if (P2PManager.peer && !P2PManager.isConnected && !P2PManager.isHost) {
                             P2PManager.updateUI('client_waiting_offer');
                        }
                    }).catch(error => {
                        console.warn("Erreur lors de l'arrêt du scanner:", error);
                        html5QrcodeScanner = null;
                        qrScannerContainer.innerHTML = '';
                        qrScannerContainer.style.display = 'none';
                        if (P2PManager.peer && !P2PManager.isConnected && !P2PManager.isHost) {
                             P2PManager.updateUI('client_waiting_offer');
                        }
                    });
                } else {
                    // Cas synchrone (pour la robustesse)
                    html5QrcodeScanner = null;
                    qrScannerContainer.innerHTML = '';
                    qrScannerContainer.style.display = 'none';
                    if (P2PManager.peer && !P2PManager.isConnected && !P2PManager.isHost) {
                        P2PManager.updateUI('client_waiting_offer');
                    }
                }
            }
            
            // Réinitialiser l'état du bouton Scan
            startScanBtn.textContent = "Scanner l'Offer";
            startScanBtn.onclick = startQRScan;
        }

        function copySignalingCode() {
            const code = signalingInput.value;
            if (!code) {
                 showMessageModal("Erreur", "Aucun code à copier.", true);
                 return;
            }
            
            // Utiliser l'API Clipboard moderne
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(code).then(() => {
                    showMessageModal("Copié", "Code de signalisation copié dans le presse-papiers.", false);
                }).catch(err => {
                    console.error('Erreur de copie via Clipboard API:', err);
                    // Fallback si l'API moderne échoue
                    fallbackCopyTextToClipboard(code);
                });
            } else {
                // Fallback pour les environnements plus anciens (comme les iframes)
                fallbackCopyTextToClipboard(code);
            }
        }

        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed"; 
            textArea.style.opacity = 0;
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                const msg = successful ? 'Copié' : 'Échec de la copie';
                showMessageModal(msg, `Code de signalisation copié dans le presse-papiers (Méthode de secours).`, !successful);
            } catch (err) {
                console.error('Échec de la copie de secours:', err);
                showMessageModal("Échec de la copie", "Impossible de copier le code. Veuillez le sélectionner manuellement.", true);
            }
            document.body.removeChild(textArea);
        }


        // --- Fonctions utilitaires ---
        
        function getHexToRgb(hex) {
             const bigint = parseInt(hex.slice(1), 16);
             const r = (bigint >> 16) & 255;
             const g = (bigint >> 8) & 255;
             const b = bigint & 255;
             return { r: r / 255, g: g / 255, b: b / 255 };
        }
        
        function calculateTextColor(hexColor) {
            const {r, g, b} = getHexToRgb(hexColor); 
            const luminosity = (0.299 * r + 0.587 * g + 0.114 * b);
            return luminosity > 0.5 ? '#000000' : '#ffffff';
        }
        
        function generateUniqueId() {
             return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }
        
        function showMessageModal(title, content, isError = false) {
            const modal = document.getElementById('messageModal');
            const backdrop = document.getElementById('modalBackdrop');
            
            document.getElementById('modalMessageTitle').textContent = title;
            document.getElementById('modalMessageContent').textContent = content;
            
            const titleElement = document.getElementById('modalMessageTitle');
            if (isError) {
                titleElement.style.color = 'var(--danger-red)';
            } else {
                 titleElement.style.color = 'var(--accent-blue)'; 
            }

            backdrop.style.display = 'block';
            modal.style.display = 'block';
            
            document.getElementById('closeMessageModalBtn').onclick = () => {
                backdrop.style.display = 'none';
                modal.style.display = 'none';
            };
        }


        // --- 1. Gestion des Données et Stockage ---
        
        function saveLogData(logData) {
            try {
                // Tri par heure avant de sauvegarder (maintient l'ordre pour l'ajout standard)
                logData.sort((a, b) => {
                    if (a.heure === b.heure) return 0;
                    if (a.heure < b.heure) return -1;
                    if (a.heure > b.heure) return 1;
                    return 0; 
                });
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(logData));
                
                updateHistoryAndColorMap(logData);
                
                // NOUVEAU: Tenter d'envoyer les données par P2P si en mode Hôte
                if (P2PManager.isHost) {
                    P2PManager.sendData(logData);
                }

            } catch (e) {
                console.error("Erreur de sauvegarde des données:", e);
                showMessageModal("Erreur de sauvegarde", "Impossible de sauvegarder les données dans le stockage local.", true);
            }
        }

        function loadLogData() {
            try {
                const dataString = localStorage.getItem(LOCAL_STORAGE_KEY);
                return dataString ? JSON.parse(dataString) : [];
            } catch (e) {
                console.error("Erreur de chargement des données:", e);
                return [];
            }
        }
        
        function getLogData() {
            return Array.from(logTableBody.querySelectorAll('tr')).map(row => {
                const getSafeDataset = (key) => {
                    const value = String(row.dataset[key] || ''); 
                    return value === 'undefined' ? '' : value; 
                };
                
                const paxMode = getSafeDataset('paxmode') || 'standard';
                let paxValue = getSafeDataset('pax');

                if (paxMode === 'free') {
                    paxValue = getSafeDataset('freepaxname') || 'Pax Libre';
                }

                return {
                    id: getSafeDataset('id'), 
                    heure: row.querySelector('.heure-cell-text').textContent,
                    pax: paxValue,
                    paxMode: paxMode, 
                    paxColor: getSafeDataset('paxcolor') || (paxMode === 'free' ? FREE_MODE_COLORS[0].hex : undefined), 
                    lieu: getSafeDataset('lieu'),
                    fenetrePorte: getSafeDataset('fenetreporte'),
                    remarques: getSafeDataset('remarques'),
                };
            });
        }

        function loadHistory() {
            try {
                const dataString = localStorage.getItem(HISTORY_STORAGE_KEY);
                const history = dataString ? JSON.parse(dataString) : { lieux: [], fp: [], paxColorMap: {} };
                colorPaxMap = {};
                for (const paxName in history.paxColorMap) {
                    const color = history.paxColorMap[paxName];
                    colorPaxMap[color] = paxName; 
                }
                return history;
            } catch (e) {
                console.error("Erreur de chargement de l'historique:", e);
                return { lieux: [], fp: [], paxColorMap: {} };
            }
        }

        function saveHistory(history) {
            try {
                 localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
            } catch (e) {
                console.error("Erreur de sauvegarde de l'historique:", e);
            }
        }

        function updateHistoryAndColorMap(logData) {
            const lieux = new Set();
            const fp = new Set();
            const newPaxColorMap = {};
            const newColorPaxMap = {}; 

            logData.forEach(entry => {
                if (entry.lieu) lieux.add(entry.lieu.trim());
                if (entry.fenetrePorte) fp.add(entry.fenetrePorte.trim());

                if (entry.paxMode === 'free' && entry.paxColor) {
                    newPaxColorMap[entry.pax] = entry.paxColor;
                    newColorPaxMap[entry.paxColor] = entry.pax;
                }
            });

            const history = {
                lieux: Array.from(lieux).slice(0, 20), 
                fp: Array.from(fp).slice(0, 20),
                paxColorMap: newPaxColorMap
            };
            
            paxColorMap = newPaxColorMap; 
            colorPaxMap = newColorPaxMap; 

            saveHistory(history);
            updateDatalists(history.lieux, history.fp);
        }
        
        function updateDatalists(lieux, fp) {
             lieuHistoryDatalist.innerHTML = '';
             fpHistorDatalist.innerHTML = '';

             lieux.forEach(item => {
                 const option = document.createElement('option');
                 option.value = item;
                 lieuHistoryDatalist.appendChild(option);
             });

             fp.forEach(item => {
                 const option = document.createElement('option');
                 option.value = item;
                 fpHistorDatalist.appendChild(option);
             });
        }
        
        function loadTitle() {
            interventionTitleInput.value = localStorage.getItem(TITLE_STORAGE_KEY) || '';
        }

        function saveTitle() {
            localStorage.setItem(TITLE_STORAGE_KEY, interventionTitleInput.value.trim());
            // Si hôte, envoi des données complettes avec le nouveau titre
            if (P2PManager.isHost) {
                 P2PManager.sendData(getLogData());
            }
        }

        function renderLogTable(logData, newEntryId = null) {
            logTableBody.innerHTML = '';
            
            logData.forEach(entry => {
                
                let paxColor, paxText, paxFontColor;
                const isFreeMode = entry.paxMode === 'free'; 

                if (isFreeMode) {
                    paxColor = entry.paxColor || FREE_MODE_COLORS[0].hex;
                    paxText = entry.pax;
                    paxFontColor = calculateTextColor(paxColor);
                } else {
                    const paxInfo = PDF_PAX_COLORS[entry.pax] || PDF_PAX_COLORS['Adversaire'];
                    paxColor = paxInfo.color;
                    paxText = paxInfo.text;
                    paxFontColor = paxInfo.fontColor;
                }

                const row = logTableBody.insertRow();
                // STOCKAGE DES VRAIES DONNÉES DANS LES DATASET DE LA LIGNE POUR RÉCUPÉRATION PAR getLogData()
                row.dataset.id = entry.id;
                row.dataset.lieu = String(entry.lieu || ''); 
                row.dataset.fenetreporte = String(entry.fenetrePorte || '');
                row.dataset.remarques = String(entry.remarques || '');
                row.dataset.pax = isFreeMode ? 'Libre' : entry.pax; 
                row.dataset.freepaxname = isFreeMode ? String(entry.pax) : ''; 
                row.dataset.paxmode = entry.paxMode; 
                row.dataset.paxcolor = isFreeMode ? paxColor : ''; 
                
                if (entry.id === newEntryId) {
                    row.classList.add('just-added');
                }
                
                row.draggable = true;
                row.classList.add('draggable-row');

                const heureCell = row.insertCell();
                heureCell.style.width = '15%';
                heureCell.innerHTML = `
                    <div class="heure-action-cell">
                        <span class="heure-cell-text">${entry.heure}</span>
                        <button type="button" class="delete-btn" data-id="${entry.id}">
                            <span class="material-symbols-outlined">close</span>
                        </button>
                    </div>`;

                const paxCell = row.insertCell();
                paxCell.style.width = '15%';
                paxCell.innerHTML = `<span class="pax-cell" style="background-color: ${paxColor}; color: ${paxFontColor};">${paxText}</span>`;
                
                const lieuCell = row.insertCell();
                lieuCell.style.width = '20%';
                lieuCell.textContent = entry.lieu;

                const fpCell = row.insertCell();
                fpCell.style.width = '20%';
                fpCell.textContent = entry.fenetrePorte;

                const remarquesCell = row.insertCell();
                remarquesCell.style.width = '30%'; 
                remarquesCell.textContent = entry.remarques;
            });
            
             // La sauvegarde appelle P2PManager.sendData si Hôte
             saveLogData(getLogData());
        }
        
        function handleAddLogEntry(e) {
            e.preventDefault();

            const mode = paxModeInput.value;
            let paxName, paxColorHex;

            if (mode === 'standard') {
                paxName = paxInput.value;
                paxColorHex = ''; 
                if (!paxName) {
                    showMessageModal("Erreur de saisie", "Veuillez sélectionner un type de PAX standard.", true);
                    return;
                }
            } else {
                paxName = freePaxInput.value.trim();
                paxColorHex = paxCustomColorInput.value;
                
                if (!paxName) {
                     showMessageModal("Erreur de saisie", "Veuillez donner un nom à l'intervenant TP.", true);
                     return;
                }
            }

            if (!heureInput.value) {
                showMessageModal("Erreur de saisie", "Veuillez renseigner l'heure.", true);
                return;
            }
            
            const currentHeure = heureInput.value;
            const newId = generateUniqueId();

            const newEntry = {
                id: newId,
                heure: currentHeure,
                pax: paxName, 
                paxMode: mode,
                paxColor: paxColorHex,
                lieu: lieuInput.value.trim(),
                fenetrePorte: fenetrePorteInput.value.trim(),
                remarques: remarquesInput.value.trim(),
            };

            const logData = getLogData(); 
            logData.push(newEntry);

            isTimeInputManuallyChanged = false;

            renderLogTable(logData, newId); 
            
            if (mode === 'free') {
                 paxColorMap[paxName] = paxColorHex; 
                 colorPaxMap[paxColorHex] = paxName; 
            }

            updateTimeInput();
            lieuInput.value = '';
            fenetrePorteInput.value = '';
            remarquesInput.value = '';
            
            remarquesInput.focus();
        }
        
        function deleteLogEntry(id) {
            const logData = getLogData().filter(entry => entry.id !== id);
            renderLogTable(logData);
        }

        function sortLogTableByTime() {
             const logData = getLogData();
             logData.sort((a, b) => {
                if (a.heure < b.heure) return -1;
                if (a.heure > b.heure) return 1;
                return 0; 
             });
             renderLogTable(logData);
             showMessageModal("Tri terminé", "Le journal a été trié par ordre chronologique de l'heure.", false);
        }

        function importLogData(newEntries, newTitle = null) {
             if (!Array.isArray(newEntries)) {
                 showMessageModal("Erreur d'importation", "Format de données invalide : la liste des entrées est manquante.", true);
                 return;
             }

             if (newEntries.length === 0) {
                 return;
             }
             
             // Utilise l'ID existant dans le log entrant comme source de vérité
             const currentData = getLogData();
             const mergedData = [...newEntries]; 

             if (newTitle !== null) {
                 interventionTitleInput.value = newTitle;
                 saveTitle(); // Sauvegarde locale du titre
             }
             
             // Rendre le log complet et écraser le log actuel
             renderLogTable(mergedData);
             showMessageModal("Synchronisation P2P", `Log mis à jour par l'Hôte. ${newEntries.length} entrées reçues.`, false);
        }
        
        
        // --- 2. Logique de sélection Pax (Standard et Libre) ---
        
        function handleColorSwatchClick() {
            Array.from(document.getElementById('free_color_palette').querySelectorAll('.color-swatch')).forEach(s => s.classList.remove('selected'));
            this.classList.add('selected');
            const selectedColor = this.dataset.color;
            paxCustomColorInput.value = selectedColor;

            if (paxModeInput.value === 'free') {
                if (colorPaxMap[selectedColor]) {
                    const lastPaxName = colorPaxMap[selectedColor];
                    freePaxInput.value = lastPaxName;
                    paxInput.value = lastPaxName;
                } else {
                    freePaxInput.value = ''; 
                    paxInput.value = ''; 
                }
                freePaxInput.focus(); 
            }
        }

        function initPaxModeAndColors() {
            const paletteContainer = document.getElementById('free_color_palette');
            paletteContainer.innerHTML = '';
            FREE_MODE_COLORS.forEach((color, index) => {
                const swatch = document.createElement('span');
                swatch.className = `color-swatch swatch-${index + 1}`;
                swatch.dataset.color = color.hex;
                swatch.style.backgroundColor = color.hex;
                if (color.hex === '#ffffff') {
                    swatch.style.borderColor = '#000000';
                }

                swatch.addEventListener('click', handleColorSwatchClick);
                paletteContainer.appendChild(swatch);
            });
            
            paletteContainer.querySelector('.color-swatch').classList.add('selected');
            paxCustomColorInput.value = FREE_MODE_COLORS[0].hex;

            setPaxMode('standard');

            Array.from(paxSelectContainer.querySelectorAll('.pax-select-option')).forEach(option => {
                option.addEventListener('click', function() {
                    Array.from(paxSelectContainer.querySelectorAll('.pax-select-option')).forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    paxInput.value = this.dataset.pax;
                    lieuInput.focus();
                });
            });

            paxInput.value = 'Adversaire';
            const initialOption = paxSelectContainer.querySelector(`[data-pax="Adversaire"]`);
            if (initialOption) {
                initialOption.classList.add('selected');
            }
        }
        
        function setPaxMode(mode) {
            const isStandard = mode === 'standard';
            
            document.getElementById('pax_select_wrapper_standard').style.display = isStandard ? 'block' : 'none';
            document.getElementById('pax_select_wrapper_free').style.display = isStandard ? 'none' : 'block';
            
            document.querySelectorAll('#pax_mode_toggle_container .mode-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });

            paxModeInput.value = mode;

            if (isStandard) {
                 const selectedOption = paxSelectContainer.querySelector('.pax-select-option.selected');
                 paxInput.value = selectedOption ? selectedOption.dataset.pax : 'Adversaire';
            } else {
                 freePaxInput.value = ''; 
                 paxInput.value = ''; 

                 const defaultColor = FREE_MODE_COLORS[0].hex;
                 paxCustomColorInput.value = defaultColor;
                 
                 Array.from(document.getElementById('free_color_palette').querySelectorAll('.color-swatch')).forEach((s, index) => {
                     s.classList.toggle('selected', index === 0);
                 });
                 
                 freePaxInput.focus();
            }
        }
        
        // CORRECTION DU BUG 3: Encapsuler la logique de mise à jour du PAX libre.
        function handleFreePaxInput() {
            const paxName = freePaxInput.value.trim();
            const currentColor = paxCustomColorInput.value; 
            
            if (paxModeInput.value === 'free') {
                 paxInput.value = paxName; 
            }
            
             // Tenter de retrouver la couleur du PAX si déjà utilisé
             if (paxColorMap[paxName]) {
                 const savedColor = paxColorMap[paxName];
                 paxCustomColorInput.value = savedColor;
                 
                 Array.from(document.getElementById('free_color_palette').querySelectorAll('.color-swatch')).forEach(s => {
                     s.classList.toggle('selected', s.dataset.color === savedColor);
                 });
             } else {
                 // Si le PAX n'est pas connu, on garde la couleur sélectionnée ou la première par défaut
                 paxCustomColorInput.value = currentColor;
                 Array.from(document.getElementById('free_color_palette').querySelectorAll('.color-swatch')).forEach(s => {
                     s.classList.toggle('selected', s.dataset.color === currentColor);
                 });
             }
        }


        // --- Mise à jour de l'heure en temps réel ---

        function updateTimeInput() {
            if (!isTimeInputManuallyChanged) {
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                heureInput.value = `${hours}:${minutes}`;
            }
        }

        // --- 3. Logique Drag & Drop ---
        
        let dragSrcEl = null;

        function handleDragStart(e) {
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.dataset.id);
            this.classList.add('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const targetRow = this;

            if (targetRow.closest('tbody') !== logTableBody) return; 
            if (dragSrcEl === targetRow) return;

            const rect = targetRow.getBoundingClientRect();
            const offsetY = e.clientY - rect.top;
            const halfHeight = rect.height / 2;

            if (offsetY < halfHeight) {
                logTableBody.insertBefore(dragSrcEl, targetRow);
            } else {
                logTableBody.insertBefore(dragSrcEl, targetRow.nextSibling);
            }
        }

        function handleDrop(e) {
            e.stopPropagation();
            e.preventDefault(); 
            
            saveLogData(getLogData()); 
            renderLogTable(loadLogData());

            return false;
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
        }
        
        // --- 4. Gestion JSON (Export/Import) ---
        
        function exportJson() {
             const logData = getLogData();
             const title = interventionTitleInput.value.trim() || "Sans Titre";

             if (logData.length === 0) {
                 showMessageModal("Exportation impossible", "Le journal est vide. Rien à exporter.", true);
                 return;
             }
             
             const now = new Date();
             const year = now.getFullYear();
             const month = String(now.getMonth() + 1).padStart(2, '0');
             const day = String(now.getDate()).padStart(2, '0');
             const datePart = `${year}-${month}-${day}`;
             const hours = String(now.getHours()).padStart(2, '0');
             const minutes = String(now.getMinutes()).padStart(2, '0');
             const timePart = `${hours}-${minutes}`; 
             
             const sanitizedTitle = title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
             const fileName = `PC_Tac_Session_${datePart}_${timePart}_${sanitizedTitle}.json`;

             const exportObject = {
                 metadata: {
                     appName: "PC Tac Log",
                     version: "1.0",
                     timestamp: now.toISOString(),
                     title: title
                 },
                 logEntries: logData
             };

             const jsonString = JSON.stringify(exportObject, null, 2);
             const blob = new Blob([jsonString], { type: "application/json" });
             
             const url = URL.createObjectURL(blob);
             const link = document.createElement('a');
             link.href = url;
             link.download = fileName;
             
             document.body.appendChild(link);
             link.click();
             document.body.removeChild(link);
             URL.revokeObjectURL(url);
             showMessageModal("Exportation réussie", `Les données ont été exportées sous le nom : ${fileName}`, false);
        }
        
        async function handleJsonFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const jsonContent = JSON.parse(e.target.result);
                    
                    if (!jsonContent.metadata || jsonContent.metadata.appName !== "PC Tac Log" || !Array.isArray(jsonContent.logEntries)) {
                        throw new Error("Fichier JSON invalide. Assurez-vous qu'il provient d'une exportation PC Tac.");
                    }
                    
                    const title = jsonContent.metadata.title || null;
                    importLogData(jsonContent.logEntries, title); 
                    
                } catch (error) {
                    console.error("Erreur lors de l'importation JSON:", error);
                    showMessageModal("Erreur d'importation", `Erreur : ${error.message}`, true);
                } finally {
                    jsonImportInput.value = ''; 
                    initPaxModeAndColors(); 
                }
            };
            reader.readAsText(file);
        }

        // --- 5. Logique P2P (WebRTC) ---
        
        function showP2PModal() {
             modalBackdrop.style.display = 'block';
             p2pModal.style.display = 'block';
             P2PManager.updateUI('disconnected');
        }

        function hideP2PModal() {
             modalBackdrop.style.display = 'none';
             p2pModal.style.display = 'none';
             // S'assurer de déconnecter proprement
             P2PManager.disconnect();
        }

        // --- 6. Logique Dock et Divers ---

        function isFullscreen() {
            return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        }

        function toggleFullscreen() {
            const icon = document.getElementById('fullscreenIcon');
            if (!isFullscreen()) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) {
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.documentElement.msExitFullscreen) {
                    document.documentElement.msExitFullscreen();
                }
            }
        }
        
        function updateFullscreenIcon() {
            const icon = document.getElementById('fullscreenIcon');
            if (icon) {
                 icon.textContent = isFullscreen() ? 'fullscreen_exit' : 'fullscreen';
                 icon.title = isFullscreen() ? 'Quitter le plein écran' : 'Plein écran';
            }
        }

        function handleThemeToggle() {
            document.body.classList.toggle('light-mode'); 
            document.body.classList.toggle('dark-mode');
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            document.getElementById('darkModeIcon').textContent = isDarkMode ? 'nightlight' : 'clear_day';
        }

        function toggleDock() {
            const dock = document.getElementById('dockMenu');
            const dockCollapsed = dock.classList.toggle('collapsed');
            localStorage.setItem('dockCollapsed', dockCollapsed);
            const icon = document.querySelector('#dockToggleBtn .material-symbols-outlined');
            if (icon) {
                icon.textContent = dockCollapsed ? 'expand_less' : 'expand_more';
            }
        }
        
        function showResetModal() {
            document.getElementById('modalBackdrop').style.display = 'block';
            document.getElementById('resetModal').style.display = 'block';
        }

        function hideResetModal() {
            document.getElementById('modalBackdrop').style.display = 'none';
            document.getElementById('resetModal').style.display = 'none';
        }


        function handleResetData() {
            localStorage.removeItem(LOCAL_STORAGE_KEY);
            localStorage.removeItem(HISTORY_STORAGE_KEY);
            localStorage.removeItem(TITLE_STORAGE_KEY);

            paxColorMap = {};
            colorPaxMap = {}; 
            
            renderLogTable([]);
            hideResetModal();
            
            heureInput.value = new Date().toTimeString().split(' ')[0].substring(0, 5);
            interventionTitleInput.value = '';

            setPaxMode('standard');
            
            lieuInput.value = '';
            fenetrePorteInput.value = '';
            remarquesInput.value = '';
            
            updateDatalists([], []);
            
            P2PManager.disconnect();
            
            showMessageModal("Réinitialisation réussie", "Toutes les données du Log PC Tac (journal, historique et titre) ont été réinitialisées.", false);
        }

        function handleDeleteButtonClick(e) {
             if (e.target.closest('.delete-btn')) {
                 const id = e.target.closest('.delete-btn').dataset.id;
                 deleteLogEntry(id);
             }
        }
        
        // --- Fonctions de Génération PDF ---

        function wrapTextForPdf(font, fontSize, text, maxWidth) {
            text = String(text || ''); 
            const token = ' \n ';
            const chunks = text.replace(/\r?\n/g, token).split(' ');
            let lines = []; 
            let currentLine = '';

            for (const chunk of chunks) {
                if (chunk === '\n') { 
                    lines.push(currentLine.trim()); 
                    currentLine = ''; 
                    continue; 
                }
                
                const lineWithChunk = currentLine === '' ? chunk : `${currentLine} ${chunk}`;
                
                if (font.widthOfTextAtSize(lineWithChunk, fontSize) > maxWidth && currentLine !== '') { 
                    lines.push(currentLine.trim()); 
                    currentLine = chunk; 
                } else { 
                    currentLine = lineWithChunk; 
                }
            }
            
            lines.push(currentLine.trim()); 
            return lines.filter(line => line.length > 0);
        }
        
        function getPdfColors(isDarkMode, rgb) {
            if (isDarkMode) {
                return {
                    background: rgb(0, 0, 0),
                    text: rgb(1, 1, 1),
                    line: rgb(1, 1, 1),
                };
            } else {
                return {
                    background: rgb(1, 1, 1),
                    text: rgb(0, 0, 0),
                    line: rgb(0, 0, 0),
                };
            }
        }

        let pdfRgb; 

        async function buildPdf() {
            if (typeof PDFLib === 'undefined') { throw new Error("PDFLib non chargé."); }

            const { PDFDocument, StandardFonts, rgb, PageSizes } = PDFLib;
            pdfRgb = rgb; 
            
            const pdfDoc = await PDFDocument.create();
            let helveticaFont, helveticaBoldFont;
            try {
                helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
                helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
            } catch (e) {
                console.error("Erreur de chargement des polices PDF standard:", e);
                return null;
            }
            
            const logData = getLogData();
            const interventionTitle = interventionTitleInput.value.trim() || "Journal d'intervention";
            const isDarkMode = document.body.classList.contains('dark-mode');
            const pdfThemeColors = getPdfColors(isDarkMode, rgb); 
            
            const pageConfig = { 
                width: PageSizes.A4[1], 
                height: PageSizes.A4[0],
                margin: 30,
                fontSize: 10,
                lineHeight: 14
            };
            const colWidths = [0.10, 0.15, 0.20, 0.20, 0.35]; 
            
            const context = {
                pdfDoc, helveticaFont, helveticaBoldFont,
                currentPage: null, 
                y: 0, 
                pageNumber: 0,
                pageWidth: pageConfig.width,
                pageHeight: pageConfig.height,
                margin: pageConfig.margin,
                fontSize: pageConfig.fontSize,
                lineHeight: pageConfig.lineHeight,
                colors: {
                    ...pdfThemeColors, 
                    // Couleurs PAX Standard (RGB)
                    adversaire: rgb(0xbe/255, 0x1b/255, 0x09/255), 
                    otage: rgb(0xf1/255, 0xc4/255, 0x0f/255), 
                    inter: rgb(0x34/255, 0x98/255, 0xdb/255), 
                    ao: rgb(0x2e/255, 0xcc/255, 0x71/255) 
                },
                interventionTitle: interventionTitle
            };
            
            const drawFooter = () => {
                const footerText = `Page ${context.pageNumber}`;
                const textWidth = context.helveticaFont.widthOfTextAtSize(footerText, context.fontSize);
                
                context.currentPage.drawText(footerText, {
                    x: (context.pageWidth / 2) - (textWidth / 2), 
                    y: context.margin / 2, 
                    font: context.helveticaFont, 
                    size: context.fontSize, 
                    color: context.colors.text
                });
            };

            const addNewPage = () => {
                if (context.currentPage) { drawFooter(); }

                context.currentPage = context.pdfDoc.addPage([PageSizes.A4[1], PageSizes.A4[0]]); 
                context.pageNumber++;
                context.pageWidth = context.currentPage.getWidth();
                context.pageHeight = context.currentPage.getHeight();
                context.y = context.pageHeight - context.margin;
                
                context.currentPage.drawRectangle({ x: 0, y: 0, width: context.pageWidth, height: context.pageHeight, color: context.colors.background });
                
                // Affichage du titre d'intervention
                context.currentPage.drawText(`PC TAC - ${context.interventionTitle}`, {
                    x: context.margin, y: context.pageHeight - context.margin / 2,
                    font: context.helveticaBoldFont, size: 14, color: context.colors.text
                });
                
                context.y = context.pageHeight - context.margin - 20; 
            };

            const checkY = (spaceNeeded) => { 
                if (context.y - spaceNeeded < context.margin * 1.5) { 
                    addNewPage(); 
                    drawTableHeader();
                    return true; 
                } 
                return false; 
            };
            
            const drawTableHeader = () => {
                 const headers = ["Heure", "Pax", "Lieu", "Fenêtre/Porte", "Remarques"];
                 let currentX = context.margin;
                 const tableY = context.y;
                 const headerHeight = context.lineHeight + 5;
                 
                 context.currentPage.drawLine({
                     start: { x: context.margin, y: tableY - 1 },
                     end: { x: context.pageWidth - context.margin, y: tableY - 1 },
                     color: context.colors.line, thickness: 1
                 });

                 headers.forEach((header, i) => {
                     const colWidth = context.pageWidth * colWidths[i];
                     const x = currentX;
                     
                     context.currentPage.drawText(header, {
                         x: x + 2, y: tableY - headerHeight + 5,
                         font: context.helveticaBoldFont, size: context.fontSize, color: context.colors.text
                     });
                     
                     currentX += colWidth;
                 });
                 context.y -= headerHeight;
            };

            const drawLogEntry = (entry) => {
                
                let paxColorHex, paxText, paxTextColor;
                const isFreeMode = entry.paxMode === 'free';

                if (isFreeMode) {
                    paxColorHex = entry.paxColor || FREE_MODE_COLORS[0].hex;
                    paxText = entry.pax;
                    paxTextColor = calculateTextColor(paxColorHex) === '#000000' ? pdfRgb(0, 0, 0) : pdfRgb(1, 1, 1);
                } else {
                    const paxInfo = PDF_PAX_COLORS[entry.pax] || PDF_PAX_COLORS['Adversaire'];
                    paxColorHex = paxInfo.color;
                    paxText = paxInfo.text;
                    paxTextColor = paxInfo.fontColor === '#000000' ? pdfRgb(0, 0, 0) : pdfRgb(1, 1, 1);
                }
                
                const { r, g, b } = getHexToRgb(paxColorHex); 
                const paxPdfColor = pdfRgb(r, g, b); 
                
                const colWidthsPx = colWidths.map(ratio => context.pageWidth * ratio - 4);

                const parts = [
                    { text: entry.heure, colIndex: 0, font: context.helveticaFont, size: context.fontSize, color: context.colors.text },
                    { text: paxText, colIndex: 1, font: context.helveticaBoldFont, size: context.fontSize, color: paxTextColor, isPax: true }, 
                    { text: entry.lieu, colIndex: 2, font: context.helveticaFont, size: context.fontSize, color: context.colors.text }, 
                    { text: entry.fenetrePorte, colIndex: 3, font: context.helveticaFont, size: context.fontSize, color: context.colors.text },
                    { text: entry.remarques, colIndex: 4, font: context.helveticaFont, size: context.fontSize, color: context.colors.text },
                ];
                
                let allLines = parts.map((part, i) => {
                    part.text = String(part.text || '').trim();
                    if (!part.text) return ['']; 
                    return wrapTextForPdf(part.font, part.size, part.text, colWidthsPx[i]);
                });

                const maxLines = allLines.reduce((max, lines) => Math.max(max, lines.length), 1);
                const rowHeight = maxLines * context.lineHeight + 5;
                if (checkY(rowHeight)) return;

                let currentX = context.margin;
                const tableY = context.y;

                parts.forEach((part, i) => {
                    const colWidth = context.pageWidth * colWidths[i];
                    const x = currentX;
                    const textLines = allLines[i];
                    
                    if (i === 1) { // Colonne PAX
                        const bgX = x + 1;
                        const paxBlockHeight = context.lineHeight + 4; 
                        const paxBlockY = tableY - rowHeight + (rowHeight - paxBlockHeight) / 2;
                        
                        context.currentPage.drawRectangle({
                            x: bgX,
                            y: paxBlockY, 
                            width: colWidthsPx[i] - 2, 
                            height: paxBlockHeight,
                            color: paxPdfColor, 
                            opacity: 1,
                            borderWidth: 0
                        });
                        
                        const text = textLines[0] || '';
                        const textWidth = part.font.widthOfTextAtSize(text, part.size);
                        const textX = bgX + (colWidthsPx[i] - textWidth) / 2;
                        const textY = paxBlockY + (paxBlockHeight - part.size) / 2 + 1; 
                        
                        context.currentPage.drawText(text, {
                            x: textX, y: textY, 
                            font: part.font, size: part.size, color: part.color
                        });

                    } else { // Autres colonnes (multi-lignes)
                        textLines.forEach((line, lineIndex) => {
                            const textY = tableY - context.lineHeight - (lineIndex * context.lineHeight) - 2;
                            
                            if (line) {
                                context.currentPage.drawText(line, {
                                    x: x + 2, y: textY, 
                                    font: part.font, size: part.size, color: part.color
                                });
                            }
                        });
                    }
                    
                    currentX += colWidth;
                });
                
                context.currentPage.drawLine({
                    start: { x: context.margin, y: tableY - rowHeight + 1 },
                    end: { x: context.pageWidth - context.margin, y: tableY - rowHeight + 1 },
                    color: context.colors.line, thickness: 0.5, opacity: 0.5
                });

                context.y -= rowHeight;
            };

            addNewPage();
            drawTableHeader();
            
            logData.forEach(entry => {
                drawLogEntry(entry);
            });
            
            drawFooter();

            const pdfBytes = await pdfDoc.save();
            return pdfBytes;
        }

        async function downloadPdf() {
            const btn = previewPdfDockBtn; 
            const originalIcon = btn.querySelector('.material-symbols-outlined').textContent;
            
            btn.querySelector('.material-symbols-outlined').textContent = 'sync';
            btn.disabled = true;
            btn.style.opacity = 0.6;
            
            try {
                const pdfBytes = await buildPdf();
                if (!pdfBytes) { 
                    showMessageModal("Erreur de PDF", "La génération du PDF a échoué. Vérifiez la console (F12).", true);
                    return; 
                }

                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const today = new Date().toLocaleDateString('fr-FR').replace(/\//g, '-');
                const title = interventionTitleInput.value.trim() || "Journal_Intervention";
                const sanitizedTitle = title.replace(/[^a-z0-9]/gi, '_').toLowerCase();

                const fileName = `PC_Tac_Log_${sanitizedTitle}_${today}.pdf`;

                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, fileName);
                } else {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = fileName;
                    
                    document.body.appendChild(link);
                    link.click();
                    
                    setTimeout(() => {
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    }, 0); 
                }
                
            } catch (error) {
                console.error("Erreur critique lors de la génération du PDF:", error);
                showMessageModal("Erreur critique", "Une erreur critique est survenue lors de la génération du PDF. Consultez la console (F12).", true);
            } finally {
                btn.querySelector('.material-symbols-outlined').textContent = originalIcon;
                btn.disabled = false;
                btn.style.opacity = 1;
            }
        }


        // --- 7. Initialisation ---

        document.addEventListener('DOMContentLoaded', () => {
            
            // 8.1 Initialisation du thème et du dock
            const isDarkMode = localStorage.getItem('theme') === 'dark' || !localStorage.getItem('theme');
            if (!isDarkMode) { document.body.classList.replace('dark-mode', 'light-mode'); }
            document.getElementById('darkModeIcon').textContent = isDarkMode ? 'nightlight' : 'clear_day';
            
            const isDockCollapsed = localStorage.getItem('dockCollapsed') === 'true';
            if (!isDockCollapsed) {
                 document.getElementById('dockMenu').classList.remove('collapsed');
            }
            document.querySelector('#dockToggleBtn .material-symbols-outlined').textContent = isDockCollapsed ? 'expand_less' : 'expand_more';


            // 8.2 Événements globaux
            document.getElementById('fullscreenToggle').addEventListener('click', toggleFullscreen);
            document.getElementById('darkModeToggle').addEventListener('click', handleThemeToggle);
            document.getElementById('dockToggleBtn').addEventListener('click', toggleDock);
            document.addEventListener('fullscreenchange', updateFullscreenIcon);
            updateFullscreenIcon(); 
            
            updateTimeInput();
            setInterval(updateTimeInput, 60000); 

            heureInput.addEventListener('change', () => {
                isTimeInputManuallyChanged = true;
            });

            // 8.3 Initialisation du formulaire et des données
            logForm.addEventListener('submit', handleAddLogEntry);
            
            const history = loadHistory();
            paxColorMap = history.paxColorMap;
            updateDatalists(history.lieux, history.fp);
            loadTitle();
            interventionTitleInput.addEventListener('input', saveTitle);
            
            initPaxModeAndColors();

            // CORRECTION BUG 3: Rattacher correctement l'écouteur
            document.querySelectorAll('#pax_mode_toggle_container .mode-toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => setPaxMode(btn.dataset.mode));
            });
            freePaxInput.addEventListener('input', handleFreePaxInput);

            // 8.4 Logique Drag & Drop sur le corps du tableau
            logTableBody.addEventListener('dragstart', handleDragStart, true);
            logTableBody.addEventListener('dragover', (e) => handleDragOver.call(e.target.closest('tr') || logTableBody, e));
            logTableBody.addEventListener('drop', handleDrop);
            logTableBody.addEventListener('dragend', handleDragEnd); 
            logTableBody.addEventListener('click', handleDeleteButtonClick);

            // 8.5 Rendu initial
            renderLogTable(loadLogData());

            // 8.6 Événements Dock
            
            // Événements PDF/JSON/Réinitialisation
            previewPdfDockBtn.addEventListener('click', downloadPdf);
            exportJsonDockBtn.addEventListener('click', exportJson);
            importJsonDockBtn.addEventListener('click', () => jsonImportInput.click());
            jsonImportInput.addEventListener('change', handleJsonFileImport); 
            
            resetDataDockBtn.addEventListener('click', showResetModal);
            document.getElementById('confirmResetBtn').addEventListener('click', handleResetData);
            document.getElementById('cancelResetBtn').addEventListener('click', hideResetModal);
            
            document.getElementById('closeMessageModalBtn').addEventListener('click', () => {
                document.getElementById('modalBackdrop').style.display = 'none';
                document.getElementById('messageModal').style.display = 'none';
            });
            
            document.getElementById('modalBackdrop').addEventListener('click', (e) => {
                 if (e.target.id === 'modalBackdrop') {
                     hideResetModal();
                     hideP2PModal();
                 }
            });
            
            sortTimeBtn.addEventListener('click', sortLogTableByTime);

            // NOUVEAU: Événements P2P
            p2pToggleBtn.addEventListener('click', showP2PModal);
            p2pCloseModalBtn.addEventListener('click', hideP2PModal);
            p2pDisconnectBtn.addEventListener('click', P2PManager.disconnect.bind(P2PManager));
            startHostBtn.addEventListener('click', P2PManager.startHost.bind(P2PManager));
            startClientBtn.addEventListener('click', P2PManager.startClient.bind(P2PManager));
            
            // Événement Copie pour l'Offer/Answer
            copyCodeBtn.addEventListener('click', copySignalingCode); 
            
            // Événement Scan
            startScanBtn.addEventListener('click', startQRScan);
            
            // L'entrée de texte sert pour l'échange de signalisation dans les deux rôles.
            signalingInput.addEventListener('input', P2PManager.handleSignalingExchange.bind(P2PManager));
        });
    </script>
</body>
</html>
