<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF--8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Générateur d'OI</title>
    <link rel="icon" href="favicon.ico" sizes="any" type="image/png">
    <link rel="icon" href="favicon.ico" type="image/svg+xml">
    <link rel="apple-touch-icon" href="favicon.ico">
    <link rel="manifest" href="site.webmanifest">
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <style>
        :root {
            --bg-body: #121212; --bg-container: #1e1e1e; --bg-interactive: #2a2a2a;
            --text-primary: #e0e0e0; --text-secondary: #95a5a6; --border-color: #444444;
            --accent-blue: #5b9bd5; --accent-hover: #4a7aa5; --danger-red: #c0392b;
            --success-green: #27ae60;
        }
        body.light-mode {
            --bg-body: #f0f2f5; --bg-container: #ffffff; --bg-interactive: #f8f9fa;
            --text-primary: #212529; --text-secondary: #6c757d; --accent-blue: #0033a0;
            --border-color: #dee2e6;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { font-size: 16px; }
        body { font-family: 'Oswald', sans-serif; background-color: var(--bg-body); color: var(--text-primary); line-height: 1.6; padding: 10px; padding-bottom: 90px; transition: background-color 0.3s, color 0.3s; }
        .container { width: 100%; max-width: 800px; margin: auto; background: var(--bg-container); padding: 20px; border-radius: 8px; border: 1px solid var(--border-color); }
        h1 { font-size: 1.8em; margin-bottom: 20px; color: var(--accent-blue); font-family: 'Oswald', sans-serif; font-weight: 500; text-align: center; }
        h2 { font-size: 1.4em; color: var(--accent-blue); border-bottom: 2px solid var(--accent-blue); padding-bottom: 10px; margin-top: 20px; }
        h3 { font-size: 1.1em; color: var(--text-primary); margin-top: 15px; margin-bottom: 10px; }
        h4 { font-size: 1.0em; color: var(--text-secondary); margin-top: 10px; margin-bottom: 5px; }
        
        .wizard-progress { 
            display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; 
            margin-bottom: 25px; list-style-type: none; padding: 0; 
        }
        .wizard-progress-step {
            flex-grow: 1; padding: 8px 12px; text-align: center; font-size: 0.85em;
            color: var(--text-secondary); background-color: var(--bg-interactive);
            border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }

        .wizard-progress-step:hover { background-color: var(--bg-body); }
        .wizard-progress-step.completed { border-color: var(--accent-blue); color: var(--accent-blue); }
        .wizard-progress-step.active {
            color: white; background-color: var(--accent-blue);
            border-color: var(--accent-blue); font-weight: 500;
        }
        .wizard-step { display: none; animation: fadeIn 0.5s; }
        .wizard-step.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .wizard-nav { display: flex; flex-wrap: wrap; justify-content: space-between; margin-top: 30px; border-top: 1px solid var(--border-color); padding-top: 20px; gap: 10px; }
        .wizard-nav-btn { flex-grow: 1; padding: 14px 20px; border: none; border-radius: 5px; cursor: pointer; font-family: 'Oswald', sans-serif; font-size: 1.1em; min-height: 48px;}

        #prevBtn { background-color: var(--bg-interactive); color: var(--text-primary); border: 1px solid var(--border-color); }
        #nextBtn { background-color: var(--accent-blue); color: white; }
        #previewBtn { background-color: #6c757d; color: white; }
        /* #generatePdfBtn { background-color: #27ae60; color: white; } <-- Supprimé */
        #retexReportBtn { background-color: #008080; color: white; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--text-secondary); }
        input, textarea, select { width: 100%; padding: 14px; margin-bottom: 15px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 1.1rem; background-color: var(--bg-interactive); color: var(--text-primary); font-family: 'Oswald', sans-serif; min-height: 48px;}
        textarea { min-height: 120px; }
        
        .dynamic-list-item { 
            display: flex; flex-direction: column; align-items: stretch;
            gap: 10px; margin-bottom: 10px; 
        }
        /* Correction pour améliorer la lisibilité du formulaire sur mobile */
        .dynamic-list-item > *:not(button) { 
            flex-grow: 1; 
            margin-bottom: 0; 
            min-height: 48px; /* Assure que les inputs et selects sont de bonne taille */
        }
        /* Forcer le retour à la ligne pour chaque input sur mobile */
        .wizard-step .dynamic-list-item:has(#date_naissance) input {
            width: 100%;
        }
        @media (min-width: 480px) {
            .wizard-step .dynamic-list-item:has(#date_naissance) {
                flex-direction: row;
            }
            .wizard-step .dynamic-list-item:has(#date_naissance) input {
                width: auto;
            }
        }
        
        button.add-btn, button.remove-btn { min-height: 44px; }
        
        button.add-btn { background-color: #27ae60; color: white; border: none; border-radius: 4px; padding: 8px 12px; margin-top: 5px; cursor: pointer; }
        button.remove-btn { background-color: var(--danger-red); color: white; border: none; border-radius: 4px; padding: 5px 10px; font-size: 14px; cursor: pointer; }
        .collapsible-container { background-color: var(--bg-interactive); border: 1px solid var(--border-color); border-radius: 5px; margin-bottom: 15px; }
        .collapsible-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px; }
        .collapsible-header h3 { margin: 0; font-size: 1.2em; }
        .collapsible-header .material-symbols-outlined { transition: transform 0.3s; }
        .collapsible-container.open .collapsible-header .material-symbols-outlined { transform: rotate(180deg); }
        .collapsible-content { padding: 0 15px; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; }
        .collapsible-container.open .collapsible-content { max-height: 4000px; padding-top: 10px; padding-bottom: 15px; }
        /* Style for articulation display */
        .articulation-composition-display p { margin-bottom: 5px; }
        .articulation-composition-display strong { color: var(--accent-blue); }

        /* --- STYLES DOCK MENU (CORRIGÉS À PARTIR DE oi.html) --- */
        .dock-menu { 
            position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 10px; padding: 10px; z-index: 1000; 
            background-color: rgba(30, 30, 30, 0.7); 
            border: 1px solid var(--border-color); 
            border-radius: 35px; backdrop-filter: blur(10px); 
            transition: all 0.3s ease-in-out; 
        }
        .dock-menu-item { 
            display: flex; align-items: center; justify-content: center; 
            background-color: var(--bg-container); color: var(--text-primary); 
            border: 1px solid var(--border-color); 
            border-radius: 50%; width: 50px; height: 50px; 
            font-size: 28px; cursor: pointer; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
            transition: all 0.2s; text-decoration: none; flex-shrink: 0; 
        }
        .dock-menu-item:hover { transform: scale(1.1); }
        .dock-menu.collapsed { 
            width: 55px; height: 55px; padding: 5px; 
            border-radius: 50%; border: none; 
            background-color: transparent; 
        }
        .dock-menu.collapsed .dock-menu-item:not(#dockToggleBtn) { 
            opacity: 0; width: 0; margin-left: -10px; visibility: hidden; 
        }
        #dockToggleBtn .material-symbols-outlined { transition: transform 0.3s ease; }
        .dock-menu.collapsed #dockToggleBtn .material-symbols-outlined { transform: rotate(180deg); }
        /* FIN STYLES DOCK MENU (CORRIGÉS À PARTIR DE oi.html) */

        .photo-input, #sessionFileInput, #jsonConfigInput { display: none; }
        .file-upload-label { background-color: var(--accent-blue); color: white !important; padding: 10px 14px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; font-family: 'Oswald', sans-serif; font-weight: normal; display: inline-block; text-align: center; flex-shrink: 0; }
        .file-upload-label:hover { background-color: var(--accent-hover); }
        .file-name-display { color: var(--text-secondary); font-style: italic; margin-left: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; }
        .image-preview { max-width: 150px; max-height: 100px; margin-top: 10px; border-radius: 4px; border: 1px solid var(--border-color); }
        .draggable { cursor: grab; user-select: none; }
        .draggable.dragging { opacity: 0.5; cursor: grabbing; }
        
        /* --- STYLES PATRACDVR (Mobile First) --- */
        #patracdvr_container, #unassigned_members_container { 
            display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; min-height: 70px; 
            border: 1px dashed var(--border-color); border-radius: 5px; align-content: flex-start;
        }
        /* Style pour indiquer une zone de dépôt active */
        .patracdvr-members-container, #unassigned_members_container {
            transition: border-color 0.2s;
        }

        .patracdvr-member-btn { 
            background-color: var(--bg-body); border: 2px solid var(--border-color); color: var(--text-primary); 
            padding: 8px 12px; border-radius: 5px; text-align: center; font-family: 'Oswald', sans-serif; 
            cursor: pointer; transition: all 0.2s; min-height: 56px; display: flex; flex-direction: column; justify-content: center;
        }
        .patracdvr-member-btn:hover { border-color: var(--accent-hover); }
        .patracdvr-member-btn.member-active { border-color: var(--accent-blue); box-shadow: 0 0 8px var(--accent-blue); }
        .patracdvr-member-btn .trigramme { font-weight: bold; }
        .patracdvr-member-btn .fonction { font-size: 0.8em; color: var(--text-secondary); display: block; }
        
        .patracdvr-vehicle-row {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            padding-top: 28px; /* Espace pour le nom et le bouton */
            border: 1px solid var(--border-color);
            background-color: var(--bg-body);
            border-radius: 5px;
            min-height: 56px; /* Hauteur de base, comme un bouton membre */
            min-width: 100px; /* Largeur de base */
            width: auto; /* S'adapte au contenu */
            align-items: flex-start;
            justify-content: flex-start;
        }
        .patracdvr-vehicle-row .patracdvr-members-container {
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            min-height: 40px;
            width: 100%;
            padding: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-content: flex-start;
        }
        .vehicle-header {
            position: absolute;
            top: 4px;
            left: 8px;
            right: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .vehicle-name {
            font-size: 0.9em;
            font-weight: bold;
            color: var(--accent-blue);
        }
        .vehicle-header .remove-btn {
            padding: 2px 5px;
            min-height: unset;
            font-size: 12px;
        }
        #vehicle_creation_buttons { display: flex; flex-wrap: wrap; justify-content: space-between; gap: 10px; margin-bottom: 20px; padding: 10px; border: 1px dashed var(--border-color); border-radius: 5px; }
        .add-vehicle-btn { background-color: var(--bg-interactive); color: var(--text-primary); border: 1px solid var(--border-color); }
        
        #editMemberModal, #quickEditModal, #settingsModal { color: var(--text-primary); background: var(--bg-container); width: 100vw; max-width: 100vw; height: 100vh; max-height: 100vh; margin: 0; border: none; border-radius: 0; padding: 15px; }
        #editMemberModal::backdrop, #quickEditModal::backdrop, #settingsModal::backdrop { background: rgba(0, 0, 0, 0.85); }
        #editMemberModal #editMemberForm, #quickEditModal .modal-form, #settingsModal .modal-form { display: flex; flex-direction: column; height: 100%; }
        #editMemberModal .modal-content, #quickEditModal .modal-content, #settingsModal .modal-content { flex: 1 1 auto; overflow-y: auto; padding: 0 5px; }
        #editMemberModal .modal-actions, #quickEditModal .modal-actions, #settingsModal .modal-actions { flex-shrink: 0; display: flex; justify-content: space-between; gap: 10px; margin-top: 20px; }
        #editMemberModal .modal-actions button, #quickEditModal .modal-actions button, #settingsModal .modal-actions button { flex: 1; }
        #modal_cancelBtn, #quick_modal_closeBtn, #settings_closeBtn { background-color: var(--bg-interactive); color: var(--text-primary); border: 1px solid var(--border-color); }
        #modal_deleteBtn { background-color: var(--danger-red); color: white; }
        #settings_saveBtn { background-color: var(--success-green); color: white; }

        /* --- STYLES PANNEAU D'ÉDITION RAPIDE --- */
        #quickEditPanel { display: none; padding: 15px; border: 1px solid var(--border-color); border-radius: 5px; margin-top: 20px; background-color: var(--bg-body); }
        #quickEditPanel h4 { margin-top: 0; }
        #quickEditPanel h4 #selectedMemberTrigramme { color: var(--accent-blue); }
        .quick-edit-content .quick-edit-tab-panel { display: none; }
        .quick-edit-options { display: flex; flex-wrap: wrap; gap: 8px; }
        .quick-edit-btn { background-color: var(--bg-interactive); border: 1px solid var(--border-color); color: var(--text-secondary); padding: 6px 10px; border-radius: 4px; cursor: pointer; font-family: 'Oswald', sans-serif; font-size: 0.9em; transition: all 0.2s; }
        .quick-edit-btn:hover { border-color: var(--accent-hover); color: var(--text-primary); }
        .quick-edit-btn.selected { background-color: var(--accent-blue); color: white; border-color: var(--accent-blue); }
        #quickEditModal .quick-edit-category { margin-bottom: 20px; }
        #quickEditModal .quick-edit-category h5 { font-size: 1.1em; color: var(--text-secondary); margin-bottom: 10px; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }

        /* --- STYLES ANNOTATION --- */
        #annotationModal { width: 100vw; max-width: 100vw; height: 100vh; max-height: 100vh; background: var(--bg-container); color: var(--text-primary); border: none; border-radius: 0; padding: 0; overflow: hidden; }
        #annotationModal::backdrop { background: rgba(0,0,0,0.85); }
        .annotation-wrapper { display: flex; flex-direction: column; height: 100%; }
        /* Correction: Optimisation de l'agencement de la barre d'outils pour mobile */
        .annotation-toolbar { order: 2; display: flex; flex-direction: column; gap: 10px; padding: 10px; background: var(--bg-body); border-top: 1px solid var(--border-color); flex-shrink: 0; }
        .toolbar-main-tools, .toolbar-contextual-tools { 
            display: flex; 
            flex-wrap: nowrap; /* Empêche le retour à la ligne pour le défilement horizontal */
            gap: 10px; 
            overflow-x: auto; /* Permet le défilement horizontal */
            padding-bottom: 5px; 
        }
        .toolbar-main-tools::-webkit-scrollbar, .toolbar-contextual-tools::-webkit-scrollbar { height: 4px; }
        .toolbar-main-tools::-webkit-scrollbar-thumb, .toolbar-contextual-tools::-webkit-scrollbar-thumb { background: var(--border-color); }
        .tool-btn { 
            padding: 10px; font-family: 'Oswald', sans-serif; border: 1px solid var(--border-color); 
            background: var(--bg-interactive); color: var(--text-primary); cursor: pointer; border-radius: 4px; 
            display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 4px; 
            flex-shrink: 0; min-width: 80px; /* Augmenté légèrement pour un meilleur clic */
        }
        .tool-btn .material-symbols-outlined { font-size: 28px; }
        .tool-btn.active { background: var(--accent-blue); color: white; border-color: var(--accent-blue); }
        .tool-controls, #contextual_tools { display: none; }
        .tool-controls.active, #contextual_tools.active { 
            display: flex; flex-wrap: wrap; align-items: center; gap: 10px; padding: 10px; 
            border: 1px dashed var(--border-color); border-radius: 4px; 
            /* Correction: Assure le défilement sur mobile si les contrôles prennent trop de place */
            overflow-x: auto;
            max-width: 100%;
        }
        .tool-controls label { margin-bottom: 0; }
        .tool-controls input { margin-bottom: 0; padding: 8px; max-width: 150px; } /* Limite la largeur de l'input */
        #edit_text_btn { display: none; }
        #contextual_tools.active.location-selected #edit_text_btn { display: flex; }
        .annotation-actions { display: flex; justify-content: space-around; gap: 10px; padding-top: 10px; border-top: 1px solid var(--border-color); margin-top: 10px;}
        .annotation-actions button { flex: 1; justify-content: center; }
        .annotation-canvas-container { order: 1; flex-grow: 1; display: flex; align-items: center; justify-content: center; background: #000; padding: 5px; overflow: auto; min-height: 0; }
        #annotationCanvas { max-width: 100%; max-height: 100%; object-fit: contain; }
        .retex-section {
            display: flex; flex-direction: column;
            border: 1px solid var(--border-color); padding: 15px; border-radius: 5px;
            margin-top: 20px;
        }
        .retex-actions {
            display: flex; gap: 10px; margin-top: 15px;
        }
        .retex-status {
            margin-top: 10px; font-style: italic; color: var(--text-secondary);
        }
        .retex-output-content {
            border: 1px dashed var(--border-color); padding: 15px; border-radius: 5px;
            margin-top: 20px; min-height: 200px;
            white-space: pre-wrap;
            font-family: monospace;
            overflow-x: auto;
        }
        .retex-output-content h3 { color: var(--accent-blue); }
        
        .retex-output-content h4 { color: var(--accent-blue); border-bottom: 1px solid var(--border-color); margin-top: 10px; }
        .retex-output-content ul { list-style-type: disc; padding-left: 20px; }
        .retex-output-content p, .retex-output-content li { margin-bottom: 5px; }
        
        /* --- STYLES MODALE DE PRÉSENTATION (NOUVEAU) --- */
        #presentationModal {
            width: 95vw; max-width: 1200px; height: 95vh; 
            background: var(--bg-body); color: var(--text-primary); 
            border: 1px solid var(--accent-blue); border-radius: 8px; 
            padding: 20px; overflow: hidden;
        }
        #presentationModal::backdrop { background: rgba(0, 0, 0, 0.85); }

        #presentation-content {
            height: calc(100% - 60px); 
            overflow-y: auto; 
            padding-right: 15px; /* Pour l'esthétique du scrollbar */
        }
        #presentation-content h2 { 
            color: var(--accent-blue); 
            font-size: 1.8em; 
            border-bottom: 2px solid var(--accent-blue); 
            padding-bottom: 5px; 
        }
        #presentation-content h3 { 
            color: var(--accent-blue); 
            font-size: 1.3em; 
            margin-top: 15px; 
            margin-bottom: 10px; 
        }
        #presentation-content p {
            margin-bottom: 8px;
            padding-left: 15px;
        }
        #presentation-content strong {
             /* Conserver le danger color pour la composition des cellules */
             color: var(--danger-red);
        }
        #presentation-content table {
             width: 100%; border-collapse: collapse; margin-top: 15px; margin-bottom: 20px;
        }
        #presentation-content th {
             background-color: var(--accent-blue); color: white; padding: 10px; border: 1px solid var(--text-primary); text-align: left;
        }
        #presentation-content td {
             padding: 10px; border: 1px solid var(--text-secondary); vertical-align: top;
             background-color: var(--bg-interactive);
        }
        #presentation-content img {
            max-width: 100%; height: auto; border-radius: 4px; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        #presentation-content .image-container {
             text-align: center; margin: 20px 0; border: 1px solid var(--accent-blue); 
             padding: 10px; background-color: var(--bg-container);
        }
        .modal-actions-pdf {
            display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; 
            flex-shrink: 0;
        }
        .modal-actions-pdf button { width: auto; }
        .modal-actions-pdf #downloadPdfBtn { flex: 1; max-width: 250px; background-color: var(--success-green); }


        @media (min-width: 768px) {
            body { padding: 15px; padding-bottom: 80px; }
            .dynamic-list-item { flex-direction: row; }
            #editMemberModal, #quickEditModal, #settingsModal { width: 90%; max-width: 500px; height: auto; max-height: 90vh; margin: auto; border: 1px solid var(--border-color); border-radius: 8px; }
            #quickEditPanel { display: block; }
            .wizard-nav { flex-wrap: nowrap; }
            .wizard-nav-btn { width: auto; margin-top: 0; }
            #annotationModal { width: 95vw; max-width: 1400px; height: 95vh; border: 1px solid var(--border-color); border-radius: 8px;}
            .annotation-wrapper { flex-direction: row; }
            .annotation-toolbar { order: 1; flex-direction: column; width: 250px; border-top: none; border-right: 1px solid var(--border-color); }
            .toolbar-main-tools, .toolbar-contextual-tools { flex-direction: column; overflow-x: hidden; }
            .tool-btn { flex-direction: row; justify-content: flex-start; min-width: unset; }
            /* Réinitialisation des contrôles d'outils pour desktop */
            .tool-controls.active, #contextual_tools.active { 
                 overflow-x: hidden;
                 max-width: none;
            }
            .annotation-actions { flex-direction: column; margin-top: auto; padding-top: 20px; }
            .annotation-actions button { justify-content: flex-start; }
            .annotation-canvas-container { order: 2; padding: 10px; }
            
            /* Styles desktop pour le panneau d'édition */
            .quick-edit-tabs { display: none; } /* On cache les onglets */
            .quick-edit-content .quick-edit-tab-panel.active { display: block !important; } /* On affiche tous les panneaux */
            .quick-edit-content { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
            .quick-edit-content h5 { font-size: 0.9em; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; }
        }

        /* --- STYLES DU TUTORIEL --- */
        .tutorial-popup { position: absolute; background: var(--bg-container); color: var(--text-primary); border: 1px solid var(--accent-blue); border-radius: 8px; padding: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.35); z-index: 1001; width: 300px; display: none; flex-direction: column; gap: 10px; }
        .tutorial-popup p { margin-bottom: 0; }
        .tutorial-popup button { background-color: var(--accent-blue); color: white; border: none; border-radius: 4px; padding: 8px 12px; cursor: pointer; font-family: 'Oswald', sans-serif; text-transform: uppercase; }
        .tutorial-popup .close-btn { position: absolute; top: 5px; right: 10px; font-size: 20px; cursor: pointer; color: var(--text-secondary); }
        .highlight-element { box-shadow: 0 0 0 5px var(--accent-blue) !important; transition: box-shadow 0.3s ease-in-out; position: relative; z-index: 1002; }

        /* --- MEDIA QUERY POUR MOBILE (CORRIGÉ À PARTIR DE oi.html) --- */
        @media (max-width: 600px) {
            .dock-menu:not(.collapsed) {
                width: 95%;
                padding: 5px;
                gap: 5px;
                justify-content: center;
                display: flex; /* Force le flex pour le mode mobile */
                flex-wrap: wrap; /* Permet le retour à la ligne si trop d'éléments */
            }
            .dock-menu:not(.collapsed) .dock-menu-item {
                width: 45px;
                height: 45px;
                font-size: 24px;
            }
        }
    </style>
</head>
<body class="dark-mode">

    <dialog id="presentationModal">
        <div id="presentation-content">
            </div>
        <div class="modal-actions-pdf">
            <button id="downloadPdfBtn" type="button" class="wizard-nav-btn">
                Télécharger le PDF 📄
            </button>
            <button id="closePresentationModalBtn" type="button" class="wizard-nav-btn" style="background-color: var(--danger-red); color: white;">
                Fermer
            </button>
        </div>
    </dialog>
    <div class="dock-menu" id="dockMenu">
        <div class="dock-menu-item" id="dockToggleBtn" title="Réduire"><span class="material-symbols-outlined">expand_more</span></div>
        <a href="index.html" class="dock-menu-item" title="Accueil"><span class="material-symbols-outlined">home</span></a>
        <div class="dock-menu-item" id="importSessionBtn" title="Importer une session"><span class="material-symbols-outlined">file_upload</span></div>
        <div class="dock-menu-item" id="exportSessionBtn" title="Exporter la session"><span class="material-symbols-outlined">file_download</span></div>
        <div class="dock-menu-item" id="settingsBtn" title="Paramètres"><span class="material-symbols-outlined">settings</span></div>
        <div class="dock-menu-item" id="darkModeToggle" title="Changer le thème"><span class="material-symbols-outlined" id="darkModeIcon">nightlight</span></div>
        <div class="dock-menu-item" id="resetBtn" title="Réinitialiser le formulaire"><span class="material-symbols-outlined">refresh</span></div>
        <div class="dock-menu-item" id="tutorialBtn" title="Lancer le tutoriel"><span class="material-symbols-outlined">school</span></div>
    </div>
    <input type="file" id="sessionFileInput" accept=".json" />
    <input type="file" id="jsonConfigInput" accept=".json"/> 
    <dialog id="settingsModal">
        <div class="modal-form">
            <h3>Paramètres de l'application</h3>
            <div class="modal-content">
                <h4>Clé API Google Gemini</h4>
                <p>Pour l'analyse des rapports RETEX, vous devez fournir une clé API personnelle de Google Gemini. L'analyse est effectuée directement depuis votre navigateur.</p>
                <label for="geminiApiKey">Clé API:</label>
                <input type="password" id="geminiApiKey" placeholder="Saisissez votre clé d'API">
                <p style="margin-top: 15px;">**Note Importante:** Après la sauvegarde, votre clé sera stockée **uniquement dans votre navigateur** pour des raisons de sécurité et de confidentialité.</p>
            </div>
            <div class="modal-actions">
                <button type="button" id="settings_closeBtn">Fermer</button>
                <button type="button" id="settings_saveBtn">Sauvegarder</button>
            </div>
        </div>
    </dialog>

    <div id="tutorial-popup" class="tutorial-popup">
        <span class="close-btn">&times;</span>
        <p id="popup-text"></p>
        <button id="next-popup-btn">Suivant</button>
    </div>

    <dialog id="editMemberModal">
        <form id="editMemberForm" onsubmit="return false;">
            <h3>Éditer le membre</h3>
            <div class="modal-content">
                <label for="modal_trigramme">Trigramme:</label>
                <input type="text" id="modal_trigramme" placeholder="Trigramme">
                <label for="modal_fonction">Fonction:</label>
                <select id="modal_fonction"></select>
                <label for="modal_cellule">Cellule:</label>
                <select id="modal_cellule"></select>
                <label for="modal_armement">Armement:</label>
                <select id="modal_armement"></select>
                <label for="modal_equipement">Équipement 1:</label>
                <select id="modal_equipement"></select>
                <label for="modal_equipement2">Équipement 2:</label>
                <select id="modal_equipement2"></select>
                <label for="modal_tenue">Tenue:</label>
                <select id="modal_tenue"></select>
                <label for="modal_gpb">GPB:</label>
                <select id="modal_gpb"></select>
            </div>
            <div class="modal-actions">
                <button type="button" id="modal_deleteBtn" class="remove-btn">Renvoyer en Attente</button>
                <button type="button" id="modal_cancelBtn">Annuler</button>
                <button type="submit" id="modal_saveBtn" class="add-btn">Sauvegarder</button>
            </div>
        </form>
    </dialog>
    
    <dialog id="quickEditModal">
        <div class="modal-form">
            <h3 id="quick_modal_title">Édition rapide</h3>
            <div id="quick_modal_content" class="modal-content"></div>
            <div class="modal-actions">
                <button type="button" id="quick_modal_closeBtn">Fermer</button>
            </div>
        </div>
    </dialog>

    <dialog id="annotationModal">
        <div class="annotation-wrapper">
            <div class="annotation-toolbar">
                 <div id="contextual_tools">
                     <div class="toolbar-contextual-tools">
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                            <label for="rotation_input" style="font-size: 0.8em; margin:0;">Rotation (Degrés)</label>
                            <input type="number" id="rotation_input" min="0" max="360" step="1" value="0" style="max-width: 80px; text-align: center; padding: 5px; height: 35px; margin: 0;" onchange="updateAnnotationRotation()">
                        </div>
                        <button id="edit_text_btn" class="tool-btn"><span class="material-symbols-outlined">edit</span>Texte</button>
                         <button id="delete_btn" class="tool-btn" style="background-color: var(--danger-red); color: white;"><span class="material-symbols-outlined">delete</span>Supprimer</button>
                     </div>
                 </div>
                 <div class="toolbar-main-tools">
                     <button id="tool_move" class="tool-btn active"><span class="material-symbols-outlined">open_with</span>Déplacer</button>
                     <button id="tool_location" class="tool-btn"><span class="material-symbols-outlined">place</span>Emplacement</button>
                     <button id="tool_arrow" class="tool-btn"><span class="material-symbols-outlined">arrow_right_alt</span>Désigner</button>
                     <button id="tool_box" class="tool-btn"><span class="material-symbols-outlined">crop_square</span>Encadrer</button>
                 </div>
                 <div id="controls_location" class="tool-controls">
                     <label for="circle_text">Texte:</label>
                     <input type="text" id="circle_text" value="Zone">
                     <label for="circle_opacity">Transparence:</label>
                     <input type="range" id="circle_opacity" min="0.1" max="1" step="0.1" value="0.5">
                 </div>
                 <div id="controls_arrow" class="tool-controls">
                     <label for="arrow_thickness">Épaisseur:</label>
                     <input type="range" id="arrow_thickness" min="1" max="25" step="1" value="5">
                 </div>
                 <div id="controls_box" class="tool-controls">
                     <label for="box_thickness">Épaisseur:</label>
                     <input type="range" id="box_thickness" min="1" max="20" step="1" value="5">
                 </div>
                 <div class="annotation-actions">
                     <button id="tool_reset" class="tool-btn"><span class="material-symbols-outlined">delete_sweep</span>Effacer tout</button>
                     <button id="annotation_cancel" class="tool-btn">Annuler</button>
                     <button id="annotation_save" class="tool-btn" style="background-color: #27ae60; color: white;"><span class="material-symbols-outlined">save</span>Sauvegarder</button>
                 </div>
            </div>
            <div class="annotation-canvas-container">
                <canvas id="annotationCanvas"></canvas>
            </div>
        </div>
    </dialog>

    <div class="container">
        <h1>Générateur d'OI</h1>
        
        <ul class="wizard-progress">
            <li class="wizard-progress-step" onclick="goToStep(0)">Situation</li>
            <li class="wizard-progress-step" onclick="goToStep(1)">Adversaire</li>
            <li class="wizard-progress-step" onclick="goToStep(2)">Environnement</li>
            <li class="wizard-progress-step" onclick="goToStep(3)">Mission</li>
            <li class="wizard-progress-step" onclick="goToStep(4)">Exécution</li>
            <li class="wizard-progress-step" onclick="goToStep(5)">Articulation</li>
            <li class="wizard-progress-step" onclick="goToStep(6)">PATRACDVR</li>
            <li class="wizard-progress-step" onclick="goToStep(7)">Photos</li>
            <li class="wizard-progress-step" onclick="goToStep(8)">CAT</li>
            <li class="wizard-progress-step" onclick="goToStep(9)">Finalisation</li>
        </ul>

        <form id="oi-form">
            <div class="wizard-content">
                <div class="wizard-step">
                    <h2>1. Situation</h2>
                    <label for="date_op">Date de l'opération:</label><input type="date" id="date_op">
                    <label for="situation_generale">1.1 Générale:</label><textarea id="situation_generale"></textarea>
                    <label for="situation_particuliere">1.2 Particulière:</label><textarea id="situation_particuliere"></textarea>
                </div>

                <div class="wizard-step">
                    <h2>1.3 Adversaire</h2>
                    <label>Photo principale de l'adversaire:</label>
                    <div id="adversary_photo_container"></div>
                    <label for="nom_adversaire">Nom/Prénom:</label><input type="text" id="nom_adversaire">
                    <label for="domicile_adversaire">Domicile:</label><textarea id="domicile_adversaire" rows="2"></textarea>
                    <label>Moyens Employés:</label><div id="me_container"></div><button type="button" class="add-btn" onclick="addMeField()">➕ ME</button>
                    <h3>Informations TO</h3>
                    <h4>Date et lieu de naissance:</h4>
                    <div class="dynamic-list-item"><input type="date" id="date_naissance"><input type="text" id="lieu_naissance" placeholder="Lieu de naissance"></div>
                    <div class="dynamic-list-item"><input type="text" id="stature_adversaire" placeholder="Stature"><select id="ethnie_adversaire"><option>Caucasien</option><option>Nord africain</option><option>Afro-antillais</option><option>Asiatique</option></select></div>
                    <label for="signes_particuliers">Signes particuliers:</label><input type="text" id="signes_particuliers">
                    <label for="profession_adversaire">Profession:</label><input type="text" id="profession_adversaire">
                    <label for="antecedents_adversaire">Antécédents:</label><textarea id="antecedents_adversaire" rows="2"></textarea>
                    <label>État d'esprit:</label><div id="etat_esprit_container"></div><button type="button" class="add-btn" onclick="addDynamicFieldWithSelect('etat_esprit_container', ['Serein', 'Hostile', 'Conciliant', 'Sur ses gardes'])">➕</button>
                    <label for="attitude_adversaire">Attitude (connue):</label><textarea id="attitude_adversaire" rows="2"></textarea>
                    <label>Volume (renfort potentiel):</label><div id="volume_adversaire_container"></div><button type="button" class="add-btn" onclick="addDynamicFieldWithSelect('volume_adversaire_container', ['Seul', 'Famille', 'BO', 'Conjointe'])">➕</button>
                    
                    <h3>Photos des renforts potentiels</h3>
                    <div id="renforts_photo_container"></div>
                    <button type="button" class="add-btn" onclick="addPhotoInput('renforts_photo_container')">Ajouter Photo Renfort ➕</button>
                    
                    <h3 style="margin-top: 20px;">Photos supplémentaires de l'adversaire</h3>
                    <div id="adversary_extra_photos_container"></div>
                    <button type="button" class="add-btn" onclick="addPhotoInput('adversary_extra_photos_container')">Ajouter Photo Adversaire ➕</button>
                    <label for="substances_adversaire">Substances:</label><input type="text" id="substances_adversaire">
                    <label>Véhicules:</label><div id="vehicules_container"></div><button type="button" class="add-btn" onclick="addDynamicField('vehicules_container')">➕</button>
                    <label for="armes_connues">Armes connues:</label><input type="text" id="armes_connues">
                </div>
                
                <div class="wizard-step">
                    <h2>1.4 Environnement</h2>
                     <label>Ami(e)s (Unités en soutien):</label><input type="text" id="amies">
                     <label>Terrain / Météo:</label><input type="text" id="terrain_info">
                     <label>Population:</label><input type="text" id="population">
                     <label for="cadre_juridique">Cadre juridique:</label><input type="text" id="cadre_juridique">
                </div>

                <div class="wizard-step">
                    <h2>2. Mission du PSIG</h2>
                    <textarea id="missions_psig" rows="8">

INTERPELLER L'OBJECTIF.

ASSISTER LORS DE LA PERQUISITION.

CONDUITE AU LIEU DE GAV.</textarea>
                </div>

                <div class="wizard-step">
                     <h2>3. Exécution</h2>
                     <label for="date_execution">Date d'exécution:</label><input type="date" id="date_execution">
                     <label for="heure_execution">Heure d'exécution (H):</label><input type="time" id="heure_execution" value="06:00">
                     <label for="type_action">Type d'action:</label><input type="text" id="type_action">
                     <h3>Chronologie</h3><div id="time_events_container"></div><button type="button" class="add-btn" onclick="addTimeEvent()">➕</button>
                     <h3>Hypothèses</h3>
                     <label for="hypothese_h1">H1:</label><input type="text" id="hypothese_h1" value="Target présente LE1">
                     <label for="hypothese_h2">H2:</label><input type="text" id="hypothese_h2" value="Target présente LE2">
                     <label for="hypothese_h3">H3:</label><input type="text" id="hypothese_h3" value="Target absente LE 1 et 2">
                </div>

                <div class="wizard-step">
                     <h2>4. Articulation (MOIPC/ZMSPCP)</h2>
                     <label for="place_chef">Place du Chef (Générale):</label><input type="text" id="place_chef">
                     <div class="collapsible-container">
                          <div class="collapsible-header"><h3>Équipe INDIA (INTER)</h3><span class="material-symbols-outlined">expand_more</span></div>
                          <div class="collapsible-content">
                                 <label for="india_mission">Mission:</label><textarea id="india_mission" rows="3">RECONNAÎTRE LE DOMICILE EN VUE D'APPRÉHENDER L'OBJECTIF</textarea>
                                 
                                 <h3>Composition</h3>
                                 <div id="india_composition_display" class="articulation-composition-display">
                                     <p><i>La composition sera affichée ici après configuration dans l'onglet PATRACDVR.</i></p>
                                 </div>

                                 <label for="india_objectif">Objectif:</label><input type="text" id="india_objectif">
                                 <label for="india_itineraire">Itinéraire:</label><textarea id="india_itineraire" rows="3"></textarea>
                                 
                                 <h3>Photos - Itinéraire</h3>
                                 <h4>Itinéraire Extérieur</h4>
                                 <div id="photo_container_itineraire_exterieur"></div>
                                 <button type="button" class="add-btn" onclick="addPhotoInput('photo_container_itineraire_exterieur')">Ajouter Photo ➕</button>
                                 <h4>Itinéraire Intérieur</h4>
                                 <div id="photo_container_itineraire_interieur"></div>
                                 <button type="button" class="add-btn" onclick="addPhotoInput('photo_container_itineraire_interieur')">Ajouter Photo ➕</button>

                                 <label for="india_points_particuliers">Points Particuliers:</label><textarea id="india_points_particuliers" rows="3"></textarea>
                                 <label for="india_cat">Conduite à Tenir:</label><textarea id="india_cat" rows="6">- Si décelé, dynamiser jusqu'au domicile.
- Si présence tierce personne lors de la progression, contrôler.
- Si fuite, CR direction fuite + interpellation.
- Si rébellion, usage du strict niveau de force nécessaire.
- Si retranchement, CR + réarticulation pour fixer l'adversaire.</textarea>
                          </div>
                     </div>
                     <div class="collapsible-container">
                          <div class="collapsible-header"><h3>Équipe Appui/Observation (AO) - ZMSPCP</h3><span class="material-symbols-outlined">expand_more</span></div>
                          <div class="collapsible-content">
                             
                                 <h3>Composition</h3>
                                 <div id="ao_composition_display" class="articulation-composition-display">
                                     <p><i>La composition sera affichée ici après configuration dans l'onglet PATRACDVR.</i></p>
                                 </div>

                                 <label for="ao_zone_installation">Zone d'installation (Z):</label><textarea id="ao_zone_installation" rows="3"></textarea>
                                 <h3>Photos - Zone d'installation</h3>
                                 <h4>Baptême terrain</h4>
                                 <div id="photo_container_bapteme_terrain"></div>
                                 <button type="button" class="add-btn" onclick="addPhotoInput('photo_container_bapteme_terrain')">Ajouter Photo ➕</button>
                                 <h4>Emplacement AO</h4>
                                 <div id="photo_container_emplacement_ao"></div>
                                 <button type="button" class="add-btn" onclick="addPhotoInput('photo_container_emplacement_ao')">Ajouter Photo ➕</button>

                                 <label for="ao_mission">Mission (M):</label><textarea id="ao_mission" rows="3">BOUCLER - SURVEILLER - INTERDIRE TOUTE FUITE</textarea>
                                 <label for="ao_secteur_surveillance">Secteur de surveillance (S):</label><textarea id="ao_secteur_surveillance" rows="3"></textarea>
                                 <label for="ao_points_particuliers">Points Particuliers (P):</label><textarea id="ao_points_particuliers" rows="3"></textarea>
                                 <label for="ao_cat">Conduite à Tenir (C):</label><textarea id="ao_cat" rows="6">- Compte rendu de mise en place.
- Renseigner régulièrement.
- Si décelé, CR.
- Si fuite, CR direction fuite + interpellation si rapport de force favorable.
- Si rébellion, usage du strict minimum de force nécessaire.
- Si retranchement, CR + réarticulation pour fixer l'adversaire.</textarea>
                                 <label for="ao_place_chef">Place du Chef (P):</label><input type="text" id="ao_place_chef">
                          </div>
                     </div>
                </div>
                
                <div class="wizard-step">
                    <h2>5. PATRACDVR</h2>
                    <div style="margin-bottom: 20px; padding: 15px; border: 1px solid var(--border-color); border-radius: 5px;">
                        
                        <div style="display: flex; flex-wrap: wrap; justify-content: space-between; gap: 10px;">
                            <button type="button" id="importDefaultConfigBtn" class="add-btn" style="background-color: var(--accent-blue); flex-grow: 1;">Charger Config par Défaut ⚙️</button>
                            <button type="button" id="importJsonConfigBtn" class="add-btn" style="background-color: var(--success-green); flex-grow: 1;">Importer Configuration Membres (.json) 📤</button>
                            <button type="button" id="resetPatracdvrBtn" class="remove-btn" style="flex-grow: 1;">Réinitialiser PATRACDVR</button>
                        </div>
                    </div>

                    <div id="quickEditPanel">
                        <h4>Membre: <span id="selectedMemberTrigramme">Aucun</span>
                            <button type="button" id="fullEditBtn" class="add-btn" style="font-size: 0.8em; padding: 5px 8px; margin-left: 15px;">Édition Complète</button>
                        </h4>
                        <div class="quick-edit-content"></div>
                    </div>

                    <h4 style="margin-top: 20px;">Ajouter un véhicule ou un membre</h4>
                    <div id="vehicle_creation_buttons">
                        <button type="button" class="add-btn add-vehicle-btn" id="addManualVehicleBtn">➕ Véhicule Manuel</button>
                        <button type="button" class="add-btn add-vehicle-btn" id="addManualMemberBtn">➕ Membre Manuel</button>
                        </div>

                    <h4 style="margin-top: 20px;">Composition des véhicules</h4>
                    <div id="patracdvr_container"></div>
                    
                    <h4 style="margin-top: 20px;">Personnel à attribuer</h4>
                    <div id="unassigned_members_container"></div>
                </div>

                <div class="wizard-step">
                    <h2>Photos</h2>
                    <p>Ajoutez des photos complémentaires pour le PDF.</p>
                    <div class="form-section">
                        <h3>Transport PSIG vers PR</h3>
                        <div id="photo_container_transport_pr"></div>
                        <button type="button" class="add-btn" onclick="addPhotoInput('photo_container_transport_pr')">Ajouter Photo ➕</button>
                    </div>
                     <div class="form-section">
                        <h3>Transport PR vers Domicile</h3>
                        <div id="photo_container_transport_domicile"></div>
                        <button type="button" class="add-btn" onclick="addPhotoInput('photo_container_transport_domicile')">Ajouter Photo ➕</button>
                    </div>
                    <div class="form-section">
                        <h3>Cellule Effraction</h3>
                        <div id="photo_container_cellule_effraction"></div>
                        <button type="button" class="add-btn" onclick="addPhotoInput('photo_container_cellule_effraction')">Ajouter Photo ➕</button>
                    </div>
                </div>

                <div class="wizard-step">
                    <h2>Conduites à tenir</h2>
                    <h3>Générales</h3>
                    <textarea id="cat_generales" rows="6">- Si rébellion, user du strict niveau de force nécessaire
- Si retranché, alerter en mesure de se ré-articuler
- Si tente de fuir, alerter en mesure de jalonner/interpeller
- UDA : Article L435-1 du CSI + légitime défense</textarea>
                    
                    <h3>NO GO</h3>
                    <textarea id="no_go" rows="3" placeholder="Saisir les conditions de désengagement..."></textarea>
                    <h3>Liaison</h3>
                    <textarea id="cat_liaison" rows="4">TOM: 
DIR: 
Gestuelle et visuelle entre les éléments INDIA</textarea>
                </div>
                
                <div class="wizard-step">
                    <h2>Finalisation</h2>
                    <p style="text-align:center;">Vous êtes prêt. Cliquez sur "Aperçu" pour visualiser votre O.I. et le télécharger en PDF.</p>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                        <button class="wizard-nav-btn" id="previewBtn" type="button">Aperçu (Mode Présentation) 🔎</button>
                        </div>
                    
                    <div class="retex-section">
                        <h3>Lien vers RETEX</h3>
                        <p>Utilisez ce bouton pour afficher la page vers la plateforme interne de compte-rendu d'opération.</p>
                        <div class="retex-actions">
                            <button id="retexReportBtn" class="wizard-nav-btn" type="button" style="background-color: #008080;">Page Retex 🧠</button>
                        </div>
                    </div>
                    <div class="retex-section" style="margin-top: 10px;">
                        <h3>🧠 Analyse RETEX par IA (Fichiers locaux)</h3>
                        <p>Sélectionnez les fichiers JSON des comptes-rendus à analyser localement (Nécessite Clé API Gemini).</p>
                        <div class="retex-file-selector">
                            <label for="retexFileInput" class="file-upload-label" style="background-color: var(--accent-blue);">
                                <span class="material-symbols-outlined">upload_file</span> Choisir des fichiers
                            </label>
                            <input type="file" id="retexFileInput" accept=".json" multiple style="display: none;">
                            <span id="retexFileNames" class="file-name-display" style="color: var(--text-secondary);">Aucun fichier sélectionné</span>
                        </div>
                        <div class="retex-actions">
                             <button id="launchRetexAnalysisBtn" class="add-btn" type="button">Lancer l'Analyse</button>
                            <button id="generateRetexPdfBtn" class="wizard-nav-btn" style="display: none; background-color: var(--success-green);">Générer le PDF du rapport</button>
                        </div>
                        <p id="retex_status" class="retex-status"></p>
                        <div id="retex_output" class="retex-output-content" style="display: none;"></div>
                    </div>
                    </div>
            </div>
        </form>

        <div class="wizard-nav">
            <button class="wizard-nav-btn" id="prevBtn" type="button">Précédent</button>
            <button class="wizard-nav-btn" id="nextBtn" type="button">Suivant</button>
        </div>
    </div>

    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@4.0.10/marked.min.js"></script>
    <script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script>
        // --- NOUVELLE CONFIGURATION & VARIABLES GLOBALES ---
        const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1/models/gemini-2.5-flash:generateContent";
        const RETEX_BASE_URL = "https://oxsilaris06.github.io/Praxis/retex.html";
        const APPS_SCRIPT_WEB_APP_URL = "https://script.google.com/macros/s/AKfycbyF0CJ_B9U4Izn6ieZG4lfIq23oScE6cFvd1SoUXzUVUBRqk_Ce1R8TJpRRnuamcdJH-/exec";
        const DEFAULT_CONFIG_FILE = 'members_config.json'; // Fichier de configuration par défaut
        
        // --- GLOBAL CONFIG (Par défaut, sera écrasé par le JSON) ---
        let memberConfig = {
            fonctions: ['Chef inter', 'Chef dispo','Chef AO','Effrac', 'DE', 'Sans'],
            cellules: ['AO1','AO2','AO3','AO4','AO5','AO6','India 1','India 2','India 3','India 4','India 5', 'Sans'],
            armements: ['Sans', 'UMP9', 'G36', 'PIE', 'LBD40', 'FAP'],
            equipements: ['Sans', 'BBAL', 'GENL', 'EFFRAC', 'MP7', 'IL'],
            equipements2: ['Sans', 'Échelle', 'Stop stick', 'Lacry', 'Cale'],
            tenues: ['UBAS', '4S', 'Bleu', 'Treillis', 'Civil'],
            gpbs: ['GPBL', 'GPBPD','Sans']
        };
        const availableVehicles = ['Sharan', 'Kodiaq', '5008', 'Scénic', 'BT'];
        
        // --- GLOBAL STATE ---
        let activeMemberId = null;
        let retexFiles = []; // Nouveau tableau pour stocker les objets Retex JSON chargés

        // --- WIZARD & FORM MANAGEMENT ---
        let currentStep = 0;
        let visitedSteps = new Set();
        const steps = Array.from(document.querySelectorAll(".wizard-step"));
        const progressSteps = Array.from(document.querySelectorAll(".wizard-progress-step"));
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const previewBtn = document.getElementById('previewBtn');
        const retexReportBtn = document.getElementById('retexReportBtn');
        const retexStatus = document.getElementById('retex_status');
        const retexOutput = document.getElementById('retex_output');
        const launchRetexAnalysisBtn = document.getElementById('launchRetexAnalysisBtn');
        const generateRetexPdfBtn = document.getElementById('generateRetexPdfBtn');
        const patracdvrContainer = document.getElementById('patracdvr_container');
        const unassignedContainer = document.getElementById('unassigned_members_container');
        const jsonConfigInput = document.getElementById('jsonConfigInput');
        const resetPatracdvrBtn = document.getElementById('resetPatracdvrBtn');
        const importJsonConfigBtn = document.getElementById('importJsonConfigBtn');
        const importDefaultConfigBtn = document.getElementById('importDefaultConfigBtn');
        const downloadPdfBtn = document.getElementById('downloadPdfBtn'); // Nouveau bouton de la modale
        
        const retexFileInput = document.getElementById('retexFileInput');
        const retexFileNames = document.getElementById('retexFileNames');

        // Déclaration du canvas temporaire pour la génération PDF
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');


        function showStep(n) {
            steps.forEach((step, index) => step.classList.toggle('active', index === n));
            progressSteps.forEach((pStep, index) => {
                pStep.classList.toggle('active', index === n);
                if(visitedSteps.has(index) && index !== n) pStep.classList.add('completed');
                else pStep.classList.remove('completed');
            });
            prevBtn.style.display = n === 0 ? "none" : "inline-block";
            const isLastStep = n === (steps.length - 1);
            nextBtn.style.display = isLastStep ? "none" : "inline-block";
            if (isLastStep) {
                previewBtn.style.display = "inline-block";
                retexReportBtn.style.display = "inline-block";
            } else {
                previewBtn.style.display = "none";
                retexReportBtn.style.display = "none";
            }
        }
        function goToStep(n) {
            if (n >= 0 && n < steps.length) {
                visitedSteps.add(currentStep);
                saveFormData();
                currentStep = n;

                if (n === 6) {
                    if (activeMemberId) {
                        const oldActive = document.getElementById(activeMemberId);
                        if (oldActive) oldActive.classList.remove('member-active');
                        activeMemberId = null;
                    }
                    if (window.innerWidth >= 768) {
                        document.getElementById('quickEditPanel').style.display = 'none';
                    }
                }

                showStep(n);
            }
        }
        function changeStep(n) { goToStep(currentStep + n); }
        prevBtn.addEventListener('click', () => changeStep(-1));
        nextBtn.addEventListener('click', () => changeStep(1));
        
        // --- DYNAMIC FIELD & PHOTO MANAGEMENT ---
        function addPhotoInput(containerId, isSingle = false) {
            const container = document.getElementById(containerId);
            if (isSingle) container.innerHTML = '';
            const itemWrapper = document.createElement('div');
            itemWrapper.className = 'photo-input-wrapper';
            const uniqueId = `photo_${Date.now()}_${Math.random()}`;
            const previewId = `preview_${uniqueId}`;
            itemWrapper.innerHTML = `
                <div class="dynamic-list-item">
                    <input type="file" id="${uniqueId}" class="photo-input" accept="image/png, image/jpeg" onchange="handleFileChange(this, 'span_${uniqueId}', '${previewId}')">
                    <label for="${uniqueId}" class="file-upload-label">Choisir une photo</label>
                    <span id="span_${uniqueId}" class="file-name-display">Aucun fichier</span>
                    <button type="button" class="add-btn annotate-btn" style="display:none; margin-left:5px; background-color: var(--accent-blue);" onclick="openAnnotationModal('${previewId}')">Annoter</button>
                    ${!isSingle ? '<button type="button" class="remove-btn" onclick="this.closest(\'.photo-input-wrapper\').remove(); saveFormData();">❌</button>' : ''}
                </div>
                <img id="${previewId}" class="image-preview" style="display:none;" alt="Aperçu"/>`;
            container.appendChild(itemWrapper);
        }
        function handleFileChange(input, spanId, previewId) {
            const fileNameSpan = document.getElementById(spanId);
            const previewImg = document.getElementById(previewId);
            const annotateBtn = input.parentElement.querySelector('.annotate-btn');

            if (input.files.length > 0) {
                fileNameSpan.textContent = input.files[0].name;
                const reader = new FileReader();
                reader.onload = e => {
                    previewImg.src = e.target.result;
                    previewImg.dataset.originalSrc = e.target.result; // Stocke la source non annotée
                    previewImg.dataset.annotations = '[]'; // Réinitialise les annotations
                    previewImg.style.display = 'block';
                    if (annotateBtn) annotateBtn.style.display = 'inline-block';
                    saveFormData(); // Sauvegarder après le chargement du fichier
                }
                reader.readAsDataURL(input.files[0]);
            } else {
                fileNameSpan.textContent = 'Aucun fichier';
                previewImg.src = '';
                previewImg.dataset.originalSrc = '';
                previewImg.dataset.annotations = '[]';
                previewImg.style.display = 'none';
                if (annotateBtn) annotateBtn.style.display = 'none';
                saveFormData(); // Sauvegarder si on vide le champ
            }
        }
        function addDynamicField(containerId, value = '') {
            const container = document.getElementById(containerId);
            const item = document.createElement('div');
            item.className = 'dynamic-list-item';
            item.innerHTML = `<input type="text" class="dynamic-input" value="${value}" oninput="saveFormData()"><button type="button" class="remove-btn" onclick="this.parentElement.remove(); saveFormData();">❌</button>`;
            container.appendChild(item);
        }
        function addDynamicFieldWithSelect(containerId, options, value = '') {
            const container = document.getElementById(containerId);
            const item = document.createElement('div');
            item.className = 'dynamic-list-item';
            const selectId = `select_${containerId}_${Math.random().toString(36).substr(2, 9)}`;
            const inputId = `input_${containerId}_${Math.random().toString(36).substr(2, 9)}`;
            item.innerHTML = `<select id="${selectId}" onchange="document.getElementById('${inputId}').value = this.value; saveFormData();"><option value="">Sélection</option>${options.map(o => `<option value="${o}" ${o === value ? 'selected':''}>${o}</option>`).join('')}</select><input type="text" id="${inputId}" class="dynamic-input" placeholder="Ou personnalisé" value="${value}" oninput="document.getElementById('${selectId}').value = ''; saveFormData();"><button type="button" class="remove-btn" onclick="this.parentElement.remove(); saveFormData();">❌</button>`;
            container.appendChild(item);
        }
        function addMeField(value = '') {
            const container = document.getElementById('me_container');
            if (container.children.length >= 3) return;
            const item = document.createElement('div');
            item.className = 'dynamic-list-item';
            item.innerHTML = `<label>ME${container.children.length + 1}:</label><input type="text" class="me-input" value="${value}" oninput="saveFormData()"><button type="button" class="remove-btn" onclick="this.parentElement.remove(); saveFormData();">❌</button>`;
            container.appendChild(item);
        }
        
        function addTimeEvent(type_from_load, hour_from_load = '', desc_from_load) {
            const container = document.getElementById('time_events_container');
            const isLoadingFromFile = type_from_load !== undefined;

            let type, hour = hour_from_load, desc;

            if (isLoadingFromFile) {
                type = type_from_load;
                desc = desc_from_load;
            } else {
                const currentEventCount = container.children.length;
                const prefilledData = [
                    { type: 'T0', desc: 'Rasso PSIG' }, { type: 'T1', desc: 'Départ PR' },
                    { type: 'T2', desc: 'Départ LE' }, { type: 'T3', desc: 'MEP TERMINÉ' },
                    { type: 'T4', desc: 'TOP ACTION' },
                ];
                const defaultValues = prefilledData[currentEventCount] || { type: `T${currentEventCount}`, desc: ''};
                type = defaultValues.type;
                desc = defaultValues.desc;
            }

            const item = document.createElement('div');
            item.className = 'dynamic-list-item time-item draggable';
            item.id = `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            item.setAttribute('draggable', 'true');
            const optionsHtml = ['T0','T1','T2','T3','T4','T5'].map(t => 
                `<option value="${t}" ${t === type ? 'selected' : ''}>${t}</option>`
            ).join('');
            item.innerHTML = `<select class="time-type-select" onchange="saveFormData()">${optionsHtml}</select><input type="time" class="time-hour-input" value="${hour}" onchange="saveFormData()"><input type="text" class="time-description-input" placeholder="Description" value="${desc || ''}" oninput="saveFormData()"><button type="button" class="remove-btn" onclick="this.parentElement.remove(); saveFormData();">❌</button>`;
            container.appendChild(item);
        }

        // --- PATRACDVR & MEMBER MANAGEMENT ---
        function addPatracdvrRow(vehicleName, members = []) {
            const container = document.getElementById('patracdvr_container');
            // Vérifie si un véhicule avec ce nom existe déjà
            if (container.querySelector(`[data-vehicle-name="${vehicleName}"]`)) {
                alert(`Le véhicule "${vehicleName}" existe déjà. Veuillez choisir un nom unique.`);
                return;
            }
            const row = document.createElement('div');
            row.className = 'patracdvr-vehicle-row';
            row.dataset.vehicleName = vehicleName;

            row.innerHTML = `
                <div class="vehicle-header">
                    <span class="vehicle-name">${vehicleName}</span>
                    <button type="button" class="remove-btn" title="Supprimer le véhicule">❌</button>
                </div>
                <div class="patracdvr-members-container"></div>`;
            
            container.appendChild(row);

            const membersContainer = row.querySelector('.patracdvr-members-container');
            row.querySelector('.remove-btn').addEventListener('click', () => {
                const confirmation = confirm(`Voulez-vous vraiment supprimer le véhicule "${vehicleName}" et désattribuer ses membres ?`);
                if (confirmation) {
                    membersContainer.querySelectorAll('.patracdvr-member-btn').forEach(memberBtn => {
                        memberBtn.dataset.cellule = 'Sans';
                        memberBtn.dataset.fonction = 'Sans';
                        updateMemberButtonVisuals(memberBtn);
                        unassignedContainer.appendChild(memberBtn);
                    });
                    row.remove();
                    saveFormData();
                }
            });
            
            // Attacher les gestionnaires de drag and drop au nouveau conteneur de membres
            membersContainer.addEventListener('dragenter', handleDragEnter);
            membersContainer.addEventListener('dragleave', handleDragLeave);
            membersContainer.addEventListener('dragover', handleDragOver);
            membersContainer.addEventListener('drop', handleDrop);

            members.forEach(memberData => addPatracdvrMember(membersContainer, memberData));
            saveFormData();
        }
        
        // --- NOUVELLE FONCTION : Ajout de véhicule manuel ---
        function addManualVehicle() {
            let vehicleName = prompt("Veuillez saisir le nom du nouveau véhicule (ex: VW-Golf, VTC):");
            if (vehicleName) {
                vehicleName = vehicleName.trim();
                if (vehicleName.length > 0) {
                    addPatracdvrRow(vehicleName);
                }
            }
        }
        
        // --- NOUVELLE FONCTION : Ajout de membre manuel ---
        function addManualMember() {
            let trigramme = prompt("Veuillez saisir le trigramme du nouveau membre (ex: ABC):");
            if (trigramme) {
                trigramme = trigramme.trim().toUpperCase();
                // Vérifier si un membre avec ce trigramme existe déjà
                const existingMember = document.querySelector(`.patracdvr-member-btn[data-trigramme="${trigramme}"]`);
                if (existingMember) {
                    alert(`Le membre avec le trigramme "${trigramme}" existe déjà. Veuillez en choisir un autre.`);
                    return;
                }
                
                if (trigramme.length >= 2 && trigramme.length <= 4) {
                    // Crée le nouveau membre
                    addPatracdvrMember(unassignedContainer, { trigramme: trigramme, cellule: 'Sans', fonction: 'Sans' });
                    
                    // Sélectionne le nouveau membre pour édition rapide
                    const newMemberBtn = unassignedContainer.lastChild;
                    if (newMemberBtn) {
                        handleMemberSelection({ target: newMemberBtn });
                    }
                    saveFormData();
                } else {
                    alert("Le trigramme doit contenir entre 2 et 4 caractères.");
                }
            }
        }
        
        function addPatracdvrMember(containerElement, data = {}) {
            if (!containerElement) return;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'patracdvr-member-btn draggable';
            btn.id = `member_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            btn.setAttribute('draggable', 'true');
            const memberData = {
                trigramme: 'N/A', fonction: 'Sans', cellule: 'India 1', armement: 'Sans',
                equipement: 'Sans', equipement2: 'Sans',
                tenue: 'UBAS', gpb: 'GPBL', ...data
            };
            Object.keys(memberData).forEach(key => btn.dataset[key] = memberData[key]);
            updateMemberButtonVisuals(btn);
            containerElement.appendChild(btn);
        }
        function updateMemberButtonVisuals(btn) {
            const trigramme = btn.dataset.trigramme || 'N/A';
            const fonction = btn.dataset.fonction || '';
            const cellule = btn.dataset.cellule || '';
            // Si la cellule est "Sans", on affiche juste la fonction (ou rien si "Sans")
            const cellDisplay = cellule !== 'Sans' ? cellule : '';
            const functionDisplay = fonction !== 'Sans' ? ` / ${fonction}` : '';
            const separation = (cellDisplay && functionDisplay) ? '' : ''; // Si la cellule est Sans, on vire le /
            
            btn.innerHTML = `<span class="trigramme">${trigramme}</span><span class="fonction">${cellDisplay}${separation}${functionDisplay}</span>`;
            
            // Si le membre est dans la zone non assignée, on affiche uniquement le trigramme
            if (btn.closest('#unassigned_members_container')) {
                btn.innerHTML = `<span class="trigramme">${trigramme}</span>`;
            }
        }

        function openMemberModal(buttonId) {
            const modal = document.getElementById('editMemberModal');
            const form = document.getElementById('editMemberForm');
            const button = document.getElementById(buttonId);
            const deleteBtn = document.getElementById('modal_deleteBtn');
            
            if (!button) return;
            form.dataset.editingButtonId = buttonId;
            
            // Logique de modification du bouton de suppression/renvoi en attente/suppression définitive
            const isUnassigned = button.closest('#unassigned_members_container');
            
            if (isUnassigned) {
                deleteBtn.textContent = 'Supprimer Définitivement';
                deleteBtn.style.backgroundColor = '#FF0000'; // Rouge vif pour la suppression définitive
            } else {
                deleteBtn.textContent = 'Renvoyer en Attente';
                deleteBtn.style.backgroundColor = 'var(--danger-red)'; // Rouge normal
            }
            
            document.getElementById('modal_trigramme').value = button.dataset.trigramme;
            
            // Logique de peuplement des selects à partir de memberConfig
            for (const key in memberConfig) {
                const attrName = key.replace(/s$/, ''); // ex: fonctions -> fonction
                const selectId = 'modal_' + attrName;
                const select = document.getElementById(selectId);
                if (select) {
                    select.innerHTML = memberConfig[key].map(option => {
                        const selected = (button.dataset[attrName] === option) ? 'selected' : '';
                        return `<option value="${option}" ${option === button.dataset[attrName] ? 'selected':''}>${option}</option>`;
                    }).join('');
                    // Correction: Assurez-vous que la valeur est correctement sélectionnée si elle existe
                    select.value = button.dataset[attrName];
                }
            }
            
            modal.showModal();
        }
        
        // --- NOUVELLE FONCTION: Mise à jour de l'affichage de l'articulation ---
        function updateArticulationDisplay() {
            const indiaContainer = document.getElementById('india_composition_display');
            const aoContainer = document.getElementById('ao_composition_display');
            
            const indiaMembersByCell = {};
            const aoMembersByCell = {};

            document.querySelectorAll('.patracdvr-member-btn').forEach(btn => {
                const trigramme = btn.dataset.trigramme;
                const cellule = btn.dataset.cellule;
                if (!trigramme || !cellule || cellule.toLowerCase() === 'sans') return;

                if (cellule.toLowerCase().startsWith('india')) {
                    if (!indiaMembersByCell[cellule]) {
                        indiaMembersByCell[cellule] = [];
                    }
                    indiaMembersByCell[cellule].push(trigramme);
                } else if (cellule.toLowerCase().startsWith('ao')) {
                    if (!aoMembersByCell[cellule]) {
                        aoMembersByCell[cellule] = [];
                    }
                    aoMembersByCell[cellule].push(trigramme);
                }
            });

            const naturalSort = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
            
            let indiaHtml = '';
            const sortedIndiaKeys = Object.keys(indiaMembersByCell).sort(naturalSort);
            sortedIndiaKeys.forEach(cell => {
                indiaHtml += `<p><strong>${cell}:</strong> ${indiaMembersByCell[cell].join(', ')}</p>`;
            });
            indiaContainer.innerHTML = indiaHtml || `<p><i>Aucun membre assigné aux cellules India.</i></p>`;

            let aoHtml = '';
            const sortedAoKeys = Object.keys(aoMembersByCell).sort(naturalSort);
            sortedAoKeys.forEach(cell => {
                aoHtml += `<p><strong>${cell}:</strong> ${aoMembersByCell[cell].join(', ')}</p>`;
            });
            aoContainer.innerHTML = aoHtml || `<p><i>Aucun membre assigné aux cellules AO.</i></p>`;
        }


        // --- PANNEAU D'ÉDITION RAPIDE & MODALE LOGIC ---
        const quickEditMapping = {
            'Cellule': { key: 'cellules', attribute: 'cellule' },
            'Fonction': { key: 'fonctions', attribute: 'fonction' },
            'Armement': { key: 'armements', attribute: 'armement' },
            'Équip. 1': { key: 'equipements', attribute: 'equipement' },
            'Équip. 2': { key: 'equipements2', attribute: 'equipement2' },
            'Tenue': { key: 'tenues', attribute: 'tenue' },
            'GPB': { key: 'gpbs', attribute: 'gpb' }
        };
        
        function setupQuickEditPanel() {
            const contentContainer = document.querySelector('#quickEditPanel .quick-edit-content');
            contentContainer.innerHTML = '';
            
            for (const [title, config] of Object.entries(quickEditMapping)) {
                
                const tabPanel = document.createElement('div');
                tabPanel.className = 'quick-edit-tab-panel active';
                
                const panelTitle = document.createElement('h5');
                panelTitle.textContent = title;
                tabPanel.appendChild(panelTitle);
                
                const optionsContainer = document.createElement('div');
                optionsContainer.className = 'quick-edit-options';
                
                (memberConfig[config.key] || []).forEach(option => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'quick-edit-btn';
                    btn.textContent = option;
                    btn.dataset.attribute = config.attribute;
                    btn.dataset.value = option;
                    optionsContainer.appendChild(btn);
                });
                
                tabPanel.appendChild(optionsContainer);
                contentContainer.appendChild(tabPanel);
            }
        }
        
        function handleMemberSelection(event) {
            const clickedButton = event.target.closest('.patracdvr-member-btn');
            if (!clickedButton) return;

            if (activeMemberId === clickedButton.id) {
                clickedButton.classList.remove('member-active');
                activeMemberId = null;
                document.getElementById('quickEditPanel').style.display = 'none';
                return;
            }

            if (activeMemberId) {
                const oldActive = document.getElementById(activeMemberId);
                if (oldActive) oldActive.classList.remove('member-active');
            }
            
            activeMemberId = clickedButton.id;
            clickedButton.classList.add('member-active');
            
            if (window.innerWidth < 768) {
                openQuickEditModal(activeMemberId);
            } else {
                populateQuickEditPanel(activeMemberId);
                document.getElementById('quickEditPanel').style.display = 'block';
            }
        }
        
        function populateQuickEditPanel(memberId) {
            const member = document.getElementById(memberId);
            if (!member) return;
            document.getElementById('selectedMemberTrigramme').textContent = member.dataset.trigramme || 'N/A';
            document.querySelectorAll('#quickEditPanel .quick-edit-btn').forEach(btn => {
                const attribute = btn.dataset.attribute;
                const value = btn.dataset.value;
                btn.classList.toggle('selected', member.dataset[attribute] === value);
            });
        }

        function openQuickEditModal(memberId) {
            const modal = document.getElementById('quickEditModal');
            const title = document.getElementById('quick_modal_title');
            const content = document.getElementById('quick_modal_content');
            const member = document.getElementById(memberId);

            if (!member) return;

            title.textContent = `Édition Rapide: ${member.dataset.trigramme || 'N/A'}`;
            content.innerHTML = '';

            for (const [category, config] of Object.entries(quickEditMapping)) {
                 if (!memberConfig[config.key] || memberConfig[config.key].length === 0) continue;
                 
                const attributeName = config.attribute; 
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'quick-edit-category';
                
                const categoryTitle = document.createElement('h5');
                categoryTitle.textContent = category;
                categoryDiv.appendChild(categoryTitle);
                
                const optionsContainer = document.createElement('div');
                optionsContainer.className = 'quick-edit-options';
                
                (memberConfig[config.key] || []).forEach(option => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'quick-edit-btn';
                    btn.textContent = option;
                    btn.dataset.attribute = attributeName;
                    btn.dataset.value = option;
                    if (member.dataset[attributeName] === option) {
                        btn.classList.add('selected');
                    }
                    optionsContainer.appendChild(btn);
                });
                
                categoryDiv.appendChild(optionsContainer);
                content.appendChild(categoryDiv);
            }
            modal.showModal();
        }

        // --- DATA PERSISTENCE (SAVE/LOAD) ---
        function saveFormData() {
            try {
                const data = {};
                document.querySelectorAll('#oi-form input:not([type="file"]), #oi-form textarea, #oi-form select').forEach(field => {
                    if (field.id) data[field.id] = field.value;
                });
                
                // Collecte des données, y compris les images et leurs annotations
                document.querySelectorAll('.image-preview').forEach(img => {
                    if(img.id && img.src.startsWith('data:image')) {
                        data[img.id + '_src'] = img.src; // La source actuelle (annotée ou non)
                        data[img.id + '_original_src'] = img.dataset.originalSrc; // La source non annotée
                        data[img.id + '_annotations'] = img.dataset.annotations || '[]'; // Les annotations JSON
                    }
                });
                
                data.me_list = Array.from(document.querySelectorAll('#me_container .me-input')).map(i => i.value).filter(Boolean);
                data.etat_esprit_list = Array.from(document.querySelectorAll(`#etat_esprit_container .dynamic-input`)).map(i => i.value).filter(Boolean);
                data.volume_list = Array.from(document.querySelectorAll(`#volume_adversaire_container .dynamic-input`)).map(i => i.value).filter(Boolean);
                data.vehicules_list = Array.from(document.querySelectorAll(`#vehicules_container .dynamic-input`)).map(i => i.value).filter(Boolean);
                data.patracdvr_unassigned = Array.from(unassignedContainer.querySelectorAll('.patracdvr-member-btn')).map(btn => ({ ...btn.dataset }));
                data.patracdvr_rows = Array.from(document.querySelectorAll('#patracdvr_container .patracdvr-vehicle-row')).map(row => ({
                    vehicle: row.dataset.vehicleName,
                    members: Array.from(row.querySelectorAll('.patracdvr-member-btn')).map(btn => ({ ...btn.dataset }))
                }));
                data.time_events = Array.from(document.querySelectorAll('#time_events_container .time-item')).map(item => ({
                    type: item.querySelector('.time-type-select').value,
                    hour: item.querySelector('.time-hour-input').value,
                    description: item.querySelector('.time-description-input').value
                }));

                try {
                    // Tente la première sauvegarde (avec images)
                    localStorage.setItem('oiFormData', JSON.stringify(data));
                } catch (e) {
                    if (e.name === 'QuotaExceededError' || e.name === 'DOMException') {
                        
                        // --- DÉBUT DE LA CORRECTION POUR L'ALERTE UNIQUE ---
                        if (localStorage.getItem('quotaAlertShown') !== 'true') {
                            alert("Alerte: Espace de stockage (5Mo) atteint. Les données textuelles sont sauvegardées, mais les images ont été retirées de la sauvegarde locale pour éviter l'erreur. Veuillez exporter la session si vous souhaitez conserver les images pour la prochaine fois.");
                            localStorage.setItem('quotaAlertShown', 'true');
                        }
                        // --- FIN DE LA CORRECTION POUR L'ALERTE UNIQUE ---

                        // 1. Suppression des images dans l'objet de sauvegarde
                        Object.keys(data).forEach(key => {
                            if (key.endsWith('_src')) {
                                delete data[key];
                                delete data[key.replace('_src', '') + '_original_src'];
                                delete data[key.replace('_src', '') + '_annotations'];
                            }
                        });

                        // 2. Tente une seconde sauvegarde (sans images)
                        localStorage.setItem('oiFormData', JSON.stringify(data));
                    } else {
                        throw e; // Relaie d'autres erreurs
                    }
                }
                
                updateArticulationDisplay();
            } catch (e) { 
                console.error("Save error:", e); 
            }
        }

        function loadFormData() {
            const dataString = localStorage.getItem('oiFormData');
            if (!dataString) {
                return false; // Indique qu'aucune donnée n'a été chargée
            }
            try {
                const data = JSON.parse(dataString);
                // Retrouver les wrappers photo et appliquer les données stockées
                document.querySelectorAll('.photo-input-wrapper').forEach(wrapper => {
                    const previewImg = wrapper.querySelector('.image-preview');
                    const input = wrapper.querySelector('.photo-input');
                    const span = wrapper.querySelector('.file-name-display');
                    const annotateBtn = wrapper.querySelector('.annotate-btn');
                    
                    const srcKey = previewImg.id + '_src';
                    const originalSrcKey = previewImg.id + '_original_src';
                    const annotationsKey = previewImg.id + '_annotations';
                    
                    if (data[srcKey]) {
                        previewImg.src = data[srcKey];
                        previewImg.dataset.originalSrc = data[originalSrcKey];
                        previewImg.dataset.annotations = data[annotationsKey] || '[]';
                        previewImg.style.display = 'block';
                        if (annotateBtn) annotateBtn.style.display = 'inline-block';
                        if (span) span.textContent = 'Image chargée'; // Le nom original du fichier est perdu ici
                    }
                });

                Object.keys(data).forEach(key => {
                    if (key.endsWith('_src') || key.endsWith('_original_src') || key.endsWith('_annotations')) return;
                    if (['patracdvr_rows', 'patracdvr_unassigned', 'time_events', 'me_list', 'etat_esprit_list', 'volume_list', 'vehicules_list'].includes(key)) return; 
                    const el = document.getElementById(key);
                    if (el && !Array.isArray(data[key]) && typeof data[key] !== 'object') {
                        el.value = data[key];
                    }
                });
                // Suppression et recréation pour éviter les doublons lors du rechargement
                document.getElementById('me_container').innerHTML = '';
                document.getElementById('etat_esprit_container').innerHTML = '';
                document.getElementById('volume_adversaire_container').innerHTML = '';
                document.getElementById('vehicules_container').innerHTML = '';
                document.getElementById('time_events_container').innerHTML = '';
                
                (data.me_list || []).forEach(val => addMeField(val));
                (data.etat_esprit_list || []).forEach(val => addDynamicFieldWithSelect('etat_esprit_container', ['Serein', 'Hostile', 'Conciliant', 'Sur ses gardes'], val));
                (data.volume_list || []).forEach(val => addDynamicFieldWithSelect('volume_adversaire_container', ['Seul', 'Famille', 'BO', 'Conjointe'], val));
                (data.vehicules_list || []).forEach(val => addDynamicField('vehicules_container', val));
                (data.time_events || []).forEach(ev => addTimeEvent(ev.type, ev.hour, ev.description));
                initializePatracdvr(data);

                updateArticulationDisplay();
                return true; // Indique que les données ont été chargées
            } catch (e) { 
                console.error("Load error:", e); 
                return false;
            }
        }
        function initializePatracdvr(dataFromStorage) {
            unassignedContainer.innerHTML = '';
            patracdvrContainer.innerHTML = '';
            if (dataFromStorage && (dataFromStorage.patracdvr_rows?.length > 0 || dataFromStorage.patracdvr_unassigned?.length > 0)) {
                (dataFromStorage.patracdvr_unassigned || []).forEach(member => addPatracdvrMember(unassignedContainer, member));
                (dataFromStorage.patracdvr_rows || []).forEach(row => addPatracdvrRow(row.vehicle, row.members));
            }
        }
        // Fonction unique pour charger les membres et les options depuis un objet config
        function loadConfigObject(config) {
            if (config.options) {
                // Met à jour la configuration globale
                Object.assign(memberConfig, config.options);
                setupQuickEditPanel(); 
                // Assurez-vous que les selects d'édition complète sont également mis à jour
                const modal = document.getElementById('editMemberModal'); 
                const form = document.getElementById('editMemberForm');
                if (form.dataset.editingButtonId) {
                    openMemberModal(form.dataset.editingButtonId);
                }
            }
            
            if (config.members && Array.isArray(config.members)) {
                unassignedContainer.innerHTML = ''; 
                patracdvrContainer.innerHTML = '';
                config.members.forEach(memberData => { 
                    const defaultData = {
                        cellule: memberData.cellule || 'Sans',
                        fonction: memberData.fonction || 'Sans',
                        ...memberData
                    };
                    addPatracdvrMember(unassignedContainer, defaultData); 
                });
            }
            saveFormData(); 
        }

        // Fonction pour charger la config par défaut depuis le fichier
        async function loadDefaultConfig() {
            try {
                const response = await fetch(DEFAULT_CONFIG_FILE);
                if (!response.ok) {
                    throw new Error(`Échec du chargement de ${DEFAULT_CONFIG_FILE}`);
                }
                const config = await response.json();
                loadConfigObject(config);
            } catch (e) {
                console.warn(`[Config Info] Impossible de charger la configuration par défaut (${DEFAULT_CONFIG_FILE}). Utilisation de la configuration interne.`, e);
                setupQuickEditPanel(); // Au moins initialiser le panneau avec la config par défaut interne
            }
        }


        // --- DRAG & DROP ---
        let draggedItem = null;

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect(); const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) { return { offset: offset, element: child }; } 
                else { return closest; }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const targetContainer = e.currentTarget;
            if (draggedItem && draggedItem.classList.contains('patracdvr-member-btn')) {
                targetContainer.style.border = '2px dashed var(--accent-blue)';
            }
        }

        function handleDragOver(e) {
            e.preventDefault(); 
            const targetContainer = e.currentTarget;
            if (draggedItem && draggedItem.classList.contains('patracdvr-member-btn')) {
                const afterElement = getDragAfterElement(targetContainer, e.clientY);
                if (afterElement == null) { 
                    targetContainer.appendChild(draggedItem); 
                } else { 
                    targetContainer.insertBefore(draggedItem, afterElement); 
                }
            }
        }

        function handleDragLeave(e) {
            e.currentTarget.style.border = '1px dashed var(--border-color)';
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetContainer = e.currentTarget;
            targetContainer.style.border = '1px dashed var(--border-color)';

            if (draggedItem && draggedItem.classList.contains('patracdvr-member-btn')) {
                // Déplace l'élément (déjà fait par handleDragOver, mais on le fait ici pour confirmer)
                targetContainer.appendChild(draggedItem);

                // Détermine si le membre est dans un véhicule ou dans la zone non assignée
                const isUnassignedZone = targetContainer.id === 'unassigned_members_container';
                
                // Met à jour l'attribut de cellule de l'élément déplacé
                if (isUnassignedZone) {
                    draggedItem.dataset.cellule = 'Sans';
                    draggedItem.dataset.fonction = 'Sans';
                } else {
                    // Si le membre est déposé dans un véhicule
                    if (draggedItem.dataset.cellule === 'Sans') {
                         draggedItem.dataset.cellule = 'India 1'; // Valeur par défaut si non définie
                    }
                }
                
                updateMemberButtonVisuals(draggedItem);
                
                // Réinitialise l'état actif et l'affichage rapide si l'élément déplacé était sélectionné
                if (draggedItem.id === activeMemberId) {
                    draggedItem.classList.remove('member-active');
                    activeMemberId = null;
                    if (window.innerWidth >= 768) {
                        document.getElementById('quickEditPanel').style.display = 'none';
                    }
                }
                
                saveFormData();
                draggedItem = null; // Réinitialiser après le dépôt
            }
        }
        // --- FIN DRAG & DROP ---

        // --- TUTORIAL SYSTEM (MISE À JOUR) ---
        const tutorialSteps = [
            { text: "Bienvenue dans le générateur d'Ordre Initial. Ce guide vous assistera dans la création de votre document opérationnel.", selector: '.container', center: true },
            { text: "Cette barre de progression indique les différentes sections de l'O.I. Vous pouvez cliquer sur une étape pour y naviguer directement.", selector: '.wizard-progress' },
            { text: "Commencez par définir le contexte général et particulier de l'opération, ainsi que sa date.", selector: '#date_op', step: 0 },
            { text: "Détaillez ici toutes les informations relatives à l'adversaire. Chargez une photo, et le bouton 'Annoter' apparaîtra pour y ajouter des indications visuelles.", selector: '#adversary_photo_container', step: 1 },
            { text: "Renseignez les informations sur les unités amies, le terrain, la météo, la population et le cadre juridique de l'intervention.", selector: '#terrain_info', step: 2 },
            { text: "La mission principale de l'unité est pré-remplie dans cette section. Vous pouvez la modifier si nécessaire.", selector: '#missions_psig', step: 3 },
            { text: "Définissez la chronologie de l'action. Vous pouvez ajouter des événements et les réorganiser par glisser-déposer.", selector: '#time_events_container', step: 4 },
            { text: "Décrivez l'articulation des équipes. La composition est désormais automatiquement importée depuis l'onglet PATRACDVR.", selector: '.collapsible-container:first-of-type', step: 5 },
            { text: "Gérez la composition des équipes en cliquant sur un membre pour ouvrir le panneau d'édition rapide. Les changements seront visibles dans l'onglet Articulation.", selector: '#unassigned_members_container', step: 6 },
            { text: "Cette section permet d'ajouter des photos complémentaires (transport, effraction...) qui seront incluses dans le document final.", selector: '.wizard-step:nth-of-type(8)', step: 7 },
            { text: "Spécifiez les conduites à tenir générales, les conditions de désengagement (NO GO), et les procédures de liaison.", selector: '#cat_generales', step: 8 },
            { text: "Une fois le formulaire complété, cliquez ici pour visualiser le document (Mode Présentation) et le télécharger au format PDF.", selector: '#previewBtn', step: 9 },
            { text: "Ce menu flottant offre un accès rapide aux fonctions globales: sauvegarder (exporter) ou charger (importer) une session, changer le thème, réinitialiser le formulaire, ou relancer ce tutoriel.", selector: '#dockMenu' }
        ];
        
        let currentTutorialStep = 0;
        const tutorialPopup = document.getElementById('tutorial-popup'); const popupText = document.getElementById('popup-text');
        const nextPopupBtn = document.getElementById('next-popup-btn'); const closePopupBtn = tutorialPopup.querySelector('.close-btn');
        let currentHighlightedElement = null;
        function startTutorial() { if (tutorialPopup.style.display === 'flex') { hideTutorial(); return; } goToStep(0); currentTutorialStep = 0; showTutorialStep(currentTutorialStep); }
        function showTutorialStep(stepIndex) {
            if (stepIndex >= tutorialSteps.length) { hideTutorial(); return; }
            const step = tutorialSteps[stepIndex];
            if (step.step !== undefined && step.step !== currentStep) { goToStep(step.step); setTimeout(() => showTutorialStep(stepIndex), 600); return; }
            if (currentHighlightedElement) { currentHighlightedElement.classList.remove('highlight-element'); }
            popupText.textContent = step.text; nextPopupBtn.textContent = stepIndex === tutorialSteps.length - 1 ? 'Terminer' : 'Suivant';
            if (step.center) {
                tutorialPopup.style.top = '50%'; tutorialPopup.style.left = '50%'; tutorialPopup.style.transform = 'translate(-50%, -50%)';
                tutorialPopup.style.display = 'flex'; currentHighlightedElement = null; return;
            }
            const targetElement = document.querySelector(step.selector);
            if (!targetElement) { console.warn(`Element non trouvé: ${step.selector}`); currentTutorialStep++; showTutorialStep(currentTutorialStep); return; }
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            targetElement.classList.add('highlight-element'); currentHighlightedElement = targetElement;
            const rect = targetElement.getBoundingClientRect(); const popupWidth = tutorialPopup.offsetWidth; const popupHeight = tutorialPopup.offsetHeight;
            let popupX = rect.left + window.scrollX + (rect.width / 2) - (popupWidth / 2);
            let popupY = rect.top + window.scrollY - popupHeight - 20;
            if (popupY < window.scrollY + 10) { popupY = rect.bottom + window.scrollY + 20; }
            if (popupX < 10) popupX = 10;
            if (popupX + popupWidth > window.innerWidth - 10) { popupX = window.innerWidth - popupWidth - 10; }
            tutorialPopup.style.top = `${popupY}px`; tutorialPopup.style.left = `${popupX}px`;
            tutorialPopup.style.transform = 'none'; tutorialPopup.style.display = 'flex';
        }
        function hideTutorial() { if (currentHighlightedElement) { currentHighlightedElement.classList.remove('highlight-element'); } tutorialPopup.style.display = 'none'; }
        nextPopupBtn.addEventListener('click', () => { currentTutorialStep++; showTutorialStep(currentTutorialStep); });
        closePopupBtn.addEventListener('click', hideTutorial);
        
        // --- LOGIQUE D'ANNOTATION ---
        const annotationModal = document.getElementById('annotationModal');
        const canvas = document.getElementById('annotationCanvas');
        const ctx = canvas.getContext('2d');
        const baseImage = new Image();
        let annotations = [], currentTool = 'move', isDrawing = false, isDragging = false, startX, startY;
        let currentAnnotation = null, selectedAnnotation = null, dragOffsetX, dragOffsetY;
        const rotationInput = document.getElementById('rotation_input');
        // Ajout d'une variable de redimensionnement/déplacement (uniquement drag sur mobile)
        let isMovingAnnotation = false;

        function setContextualTools(selection) {
            const contextualTools = document.getElementById('contextual_tools');
            if (selection) {
                contextualTools.classList.add('active');
                contextualTools.classList.toggle('location-selected', selection.type === 'location');
                rotationInput.value = Math.round((selection.rotation || 0) * 180 / Math.PI) % 360;
                if (rotationInput.value < 0) rotationInput.value = 360 + parseInt(rotationInput.value);
            } else {
                contextualTools.classList.remove('active');
            }
        }
        
        function updateAnnotationRotation() {
            if (selectedAnnotation) {
                const degrees = parseFloat(rotationInput.value) || 0;
                selectedAnnotation.rotation = degrees * Math.PI / 180;
                redrawCanvas();
                saveFormData(); // Sauvegarder la rotation
            }
        }

        function setActiveTool(toolId) {
            currentTool = toolId;
            document.querySelectorAll('.tool-btn.active, .tool-controls.active').forEach(el => el.classList.remove('active'));
            const toolButton = document.getElementById(`tool_${toolId}`);
            if (toolButton) toolButton.classList.add('active');
            const toolControls = document.getElementById(`controls_${toolId}`);
            if (toolControls) toolControls.classList.add('active');
            canvas.style.cursor = toolId === 'move' ? 'grab' : 'crosshair'; // Cursor grab pour le déplacement
            selectedAnnotation = null;
            setContextualTools(null);
        }

        function openAnnotationModal(previewImgId) {
            const previewImg = document.getElementById(previewImgId);
            if (!previewImg || !previewImg.dataset.originalSrc) return;
            baseImage.onload = () => {
                canvas.width = baseImage.width;
                canvas.height = baseImage.height;
                // S'assurer de la présence des annotations, sinon créer un tableau vide
                annotations = JSON.parse(previewImg.dataset.annotations || '[]');
                setActiveTool('move');
                redrawCanvas();
                annotationModal.dataset.targetPreviewId = previewImgId;
                annotationModal.showModal();
            };
            baseImage.src = previewImg.dataset.originalSrc; // Charge TOUJOURS l'image originale
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(baseImage, 0, 0);
            annotations.forEach(drawAnnotation);
            if (isDrawing && currentAnnotation) {
                drawAnnotation(currentAnnotation);
            }
            if (selectedAnnotation) {
                drawSelectionBorder(selectedAnnotation);
            }
        }

        function drawSelectionBorder(annotation) {
            ctx.save();
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            let centerX, centerY;
            let x, y, width, height;

            if (annotation.type === 'location') {
                x = annotation.x - annotation.radius;
                y = annotation.y - annotation.radius;
                width = annotation.radius * 2;
                height = annotation.radius * 2;
                centerX = annotation.x;
                centerY = annotation.y;
            } else if (annotation.type === 'box') {
                x = annotation.x;
                y = annotation.y;
                width = annotation.width;
                height = annotation.height;
                centerX = annotation.x + annotation.width / 2;
                centerY = annotation.y + annotation.height / 2;
            } else if (annotation.type === 'arrow') {
                const minX = Math.min(annotation.startX, annotation.endX);
                const minY = Math.min(annotation.startY, annotation.endY);
                const maxX = Math.max(annotation.startX, annotation.endX);
                const maxY = Math.max(annotation.startY, annotation.endY);
                // On met une marge pour faciliter la sélection
                x = minX - 10;
                y = minY - 10;
                width = maxX - minX + 20;
                height = maxY - minY + 20;
                centerX = (annotation.startX + annotation.endX) / 2;
                centerY = (annotation.startY + annotation.endY) / 2;
            }

            if (annotation.rotation) {
                ctx.translate(centerX, centerY);
                ctx.rotate(annotation.rotation);
                ctx.translate(-centerX, -centerY);
            }
            
            ctx.strokeRect(x, y, width, height);
            ctx.restore();
        }

        function drawAnnotation(annotation) {
            ctx.save();
            let centerX, centerY;
            if (annotation.type === 'location') {
                centerX = annotation.x;
                centerY = annotation.y;
            } else if (annotation.type === 'box') {
                centerX = annotation.x + annotation.width / 2;
                centerY = annotation.y + annotation.height / 2;
            } else if (annotation.type === 'arrow') {
                centerX = (annotation.startX + annotation.endX) / 2;
                centerY = (annotation.startY + annotation.endY) / 2;
            }

            if (annotation.rotation) {
                ctx.translate(centerX, centerY);
                ctx.rotate(annotation.rotation);
                ctx.translate(-centerX, -centerY);
            }

            switch (annotation.type) {
                case 'location': {
                    const radius = annotation.radius || 0;
                    if (radius < 2) {
                        ctx.restore();
                        return;
                    }
                    ctx.beginPath();
                    ctx.arc(annotation.x, annotation.y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = `rgba(91, 155, 213, ${annotation.opacity || 0.5})`;
                    ctx.fill();
                    ctx.strokeStyle = '#5b9bd5';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    if (annotation.text) {
                        ctx.fillStyle = 'black';
                        ctx.font = `bold ${Math.max(12, radius / 2)}px Oswald`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(annotation.text, annotation.x, annotation.y);
                    }
                    break;
                }
                case 'arrow': {
                    drawArrow(annotation.startX, annotation.startY, annotation.endX, annotation.endY, annotation.thickness || 5);
                    break;
                }
                case 'box': {
                    ctx.strokeStyle = '#c0392b';
                    ctx.lineWidth = annotation.thickness || 5;
                    ctx.strokeRect(annotation.x, annotation.y, annotation.width, annotation.height);
                    break;
                }
            }
            ctx.restore();
        }

        // Fonction corrigée pour le dessin de la flèche
        function drawArrow(fromx, fromy, tox, toy, lineWidth) {
            if (fromx === tox && fromy === toy) return;
            
            ctx.strokeStyle = '#c0392b';
            ctx.fillStyle = '#c0392b';
            ctx.lineWidth = lineWidth;
            
            const dx = tox - fromx;
            const dy = toy - fromy;
            const angle = Math.atan2(dy, dx);
            const headlen = Math.max(lineWidth * 3, 10); // Taille de la tête de flèche
            const arrowLength = Math.sqrt(dx * dx + dy * dy);

            // On s'assure que la ligne s'arrête un peu avant la pointe pour qu'elle ne dépasse pas
            const lineToX = tox - (headlen * 0.7) * Math.cos(angle);
            const lineToY = toy - (headlen * 0.7) * Math.sin(angle);
            
            // Si la flèche est trop courte pour la tête
            if (arrowLength < headlen * 1.5) {
                // Simplification pour les flèches très courtes, dessiner une simple ligne épaisse
                ctx.beginPath();
                ctx.moveTo(fromx, fromy);
                ctx.lineTo(tox, toy);
                ctx.stroke();
                return;
            }

            // Dessin de la ligne
            ctx.beginPath();
            ctx.moveTo(fromx, fromy);
            ctx.lineTo(lineToX, lineToY);
            ctx.stroke();

            // Dessin de la tête de flèche
            ctx.beginPath();
            ctx.moveTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 7), toy - headlen * Math.sin(angle - Math.PI / 7));
            ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 7), toy - headlen * Math.sin(angle + Math.PI / 7));
            ctx.closePath();
            ctx.fill();
        }

        function getEventPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // Fonction utilitaire pour la rotation inverse
        function getRotatedPoint(x, y, centerX, centerY, angle) {
            const cos = Math.cos(-angle);
            const sin = Math.sin(-angle);
            const translatedX = x - centerX;
            const translatedY = y - centerY;
            return {
                x: translatedX * cos - translatedY * sin + centerX,
                y: translatedY * sin + translatedY * cos + centerY
            };
        }

        function getAnnotationAtPosition(x, y) {
            for (let i = annotations.length - 1; i >= 0; i--) {
                const annotation = annotations[i];
                const angle = annotation.rotation || 0;
                let centerX, centerY;
                
                if (annotation.type === 'location') { centerX = annotation.x; centerY = annotation.y; } 
                else if (annotation.type === 'box') { centerX = annotation.x + annotation.width / 2; centerY = annotation.y + annotation.height / 2; } 
                else if (annotation.type === 'arrow') { centerX = (annotation.startX + annotation.endX) / 2; centerY = (annotation.startY + annotation.endY) / 2; }

                // Inverse la rotation de la position du clic
                const rotatedPos = getRotatedPoint(x, y, centerX, centerY, angle);
                const testX = rotatedPos.x;
                const testY = rotatedPos.y;

                const tolerance = 15;
                let isInside = false;

                switch (annotation.type) {
                    case 'location':
                        isInside = Math.sqrt(Math.pow(testX - annotation.x, 2) + Math.pow(testY - annotation.y, 2)) <= annotation.radius + tolerance / 2;
                        break;
                    case 'box':
                        isInside = testX >= annotation.x - tolerance && testX <= annotation.x + annotation.width + tolerance &&
                            testY >= annotation.y - tolerance && testY <= annotation.y + annotation.height + tolerance;
                        break;
                    case 'arrow':
                        const dx = annotation.endX - annotation.startX;
                        const dy = annotation.endY - annotation.startY;
                        const lenSq = dx * dx + dy * dy;
                        if (lenSq === 0) break;
                        const t = ((testX - annotation.startX) * dx + (testY - annotation.startY) * dy) / lenSq;
                        const projX = annotation.startX + t * dx;
                        const projY = annotation.startY + t * dy;
                        if (t >= 0 && t <= 1) {
                            isInside = Math.pow(testX - projX, 2) + Math.pow(testY - projY, 2) <= Math.pow(annotation.thickness + tolerance, 2);
                        }
                        break;
                }

                if (isInside) return annotation;
            }
            return null;
        }

        function handleDrawStart(e) {
            e.preventDefault();
            const pos = getEventPos(canvas, e);
            startX = pos.x;
            startY = pos.y;
            if (currentTool === 'move') {
                selectedAnnotation = getAnnotationAtPosition(pos.x, pos.y);
                setContextualTools(selectedAnnotation);
                if (selectedAnnotation) {
                    isMovingAnnotation = true; // Renommage pour clarifier : on est en mode déplacement/modification.
                    document.body.style.overflow = 'hidden';
                    redrawCanvas(); // Redraw with border
                }
            } else {
                isDrawing = true;
                selectedAnnotation = null;
                setContextualTools(null);
                currentAnnotation = {
                    type: currentTool,
                    startX: startX,
                    startY: startY,
                    endX: startX,
                    endY: startY,
                    rotation: 0
                };
            }
        }

        function handleDrawMove(e) {
            e.preventDefault();
            if (!isDrawing && !isMovingAnnotation) return; // Utilise isMovingAnnotation
            const pos = getEventPos(canvas, e);
            
            if (isMovingAnnotation && selectedAnnotation) {
                // Logique de déplacement (simplifié pour le mobile : on bouge tout)
                const deltaX = pos.x - startX;
                const deltaY = pos.y - startY;

                if (selectedAnnotation.type === 'arrow') {
                    selectedAnnotation.startX += deltaX;
                    selectedAnnotation.startY += deltaY;
                    selectedAnnotation.endX += deltaX;
                    selectedAnnotation.endY += deltaY;
                } else {
                    // Pour Location et Box, on déplace x et y
                    selectedAnnotation.x += deltaX;
                    selectedAnnotation.y += deltaY;
                }
                
                // Met à jour la position de départ pour le prochain mouvement
                startX = pos.x;
                startY = pos.y;
                redrawCanvas();

            } else if (isDrawing && currentAnnotation) {
                currentAnnotation.endX = pos.x;
                currentAnnotation.endY = pos.y;
                redrawCanvas();
            }
        }

        function handleDrawEnd(e) {
            e.preventDefault();
            document.body.style.overflow = '';
            if (isMovingAnnotation) {
                isMovingAnnotation = false;
                redrawCanvas(); 
                saveFormData(); // Sauvegarde après le déplacement
            } else if (isDrawing) {
                isDrawing = false;
                const final = { ...currentAnnotation };
                if (final.type === 'box') {
                    final.x = Math.min(final.startX, final.endX);
                    final.y = Math.min(final.startY, final.endY);
                    final.width = Math.abs(final.startX - final.endX);
                    final.height = Math.abs(final.startY - final.endY);
                    final.thickness = document.getElementById('box_thickness').value;
                    if (final.width < 5 || final.height < 5) return;
                } else if (final.type === 'arrow') {
                    final.thickness = document.getElementById('arrow_thickness').value;
                    if (Math.abs(final.startX - final.endX) < 5 && Math.abs(final.startY - final.endY) < 5) return;
                } else if (final.type === 'location') {
                    final.x = final.startX;
                    final.y = final.startY;
                    final.radius = Math.sqrt(Math.pow(final.endX - final.startX, 2) + Math.pow(final.endY - final.startY, 2));
                    final.text = document.getElementById('circle_text').value || 'Zone';
                    final.opacity = document.getElementById('circle_opacity').value;
                    if (final.radius < 5) return;
                }
                annotations.push(final);
                currentAnnotation = null;
                selectedAnnotation = final; // Sélectionne la nouvelle annotation après la création
                setContextualTools(selectedAnnotation);
                redrawCanvas();
                saveFormData(); // Sauvegarde après la création
            }
        }
        
        // --- LOGIQUE CRITIQUE DE GÉNÉRATION D'IMAGE ANNOTÉE POUR PDF ---
        /**
         * Re-génère l'image avec toutes ses annotations et la retourne comme un ArrayBuffer.
         * @param {string} originalSrc L'URL de l'image de base non annotée (dataURL).
         * @param {Array} annotationsData L'array d'objets d'annotation.
         * @returns {Promise<ArrayBuffer>} L'ArrayBuffer de l'image annotée (JPEG).
         */
        function createAnnotatedImageBlob(originalSrc, annotationsData) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous'; 
                img.src = originalSrc;
                
                img.onload = () => {
                    tempCanvas.width = img.width;
                    tempCanvas.height = img.height;
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(img, 0, 0);

                    annotationsData.forEach(annotation => drawAnnotationOnContext(tempCtx, img.width, img.height, annotation));

                    tempCanvas.toBlob(blob => {
                        if (blob) {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result); // Résout avec ArrayBuffer
                            reader.readAsArrayBuffer(blob);
                        } else {
                            reject(new Error('La conversion de l\'image annotée en Blob a échoué.'));
                        }
                    }, 'image/jpeg', 0.9);
                };
                img.onerror = (e) => reject(new Error(`Impossible de charger l\'image de base pour l\'annotation: ${e}`));
            });
        }
        
        /**
         * Fonction de dessin d'annotation réutilisable (pour le canvas normal et le canvas temporaire PDF).
         * @param {CanvasRenderingContext2D} context Le contexte de dessin.
         * @param {number} canvasWidth Largeur du canvas.
         * @param {number} canvasHeight Hauteur du canvas.
         * @param {Object} annotation L'objet d'annotation.
         */
        function drawAnnotationOnContext(context, canvasWidth, canvasHeight, annotation) {
            context.save();
            let centerX, centerY;
            if (annotation.type === 'location') {
                centerX = annotation.x;
                centerY = annotation.y;
            } else if (annotation.type === 'box') {
                centerX = annotation.x + annotation.width / 2;
                centerY = annotation.y + annotation.height / 2;
            } else if (annotation.type === 'arrow') {
                centerX = (annotation.startX + annotation.endX) / 2;
                centerY = (annotation.startY + annotation.endY) / 2;
            }
            
            if (annotation.rotation) {
                context.translate(centerX, centerY);
                context.rotate(annotation.rotation);
                context.translate(-centerX, -centerY);
            }

            switch (annotation.type) {
                case 'location': {
                    const radius = annotation.radius || 0;
                    if (radius < 2) { context.restore(); return; }
                    context.beginPath(); context.arc(annotation.x, annotation.y, radius, 0, 2 * Math.PI);
                    context.fillStyle = `rgba(91, 155, 213, ${annotation.opacity || 0.5})`; context.fill();
                    context.strokeStyle = '#5b9bd5'; context.lineWidth = 2; context.stroke();
                    if (annotation.text) {
                        context.fillStyle = 'black'; context.font = `bold ${Math.max(12, radius / 2)}px Oswald`;
                        context.textAlign = 'center'; context.textBaseline = 'middle';
                        context.fillText(annotation.text, annotation.x, annotation.y);
                    }
                    break;
                }
                case 'arrow': {
                    // Utilise une version locale et simplifiée de drawArrow pour le contexte PDF
                    const drawArrowLocal = (fromx, fromy, tox, toy, lineWidth) => {
                         if (fromx === tox && fromy === toy) return;
                         context.strokeStyle = '#c0392b'; context.fillStyle = '#c0392b'; context.lineWidth = lineWidth;
                         const headlen = Math.max(lineWidth * 3, 10); 
                         const dx = tox - fromx; const dy = toy - fromy;
                         const angle = Math.atan2(dy, dx);
                         const lineToX = tox - (headlen * 0.7) * Math.cos(angle);
                         const lineToY = toy - (headlen * 0.7) * Math.sin(angle);
                         
                         context.beginPath(); context.moveTo(fromx, fromy); context.lineTo(lineToX, lineToY); context.stroke();
                         context.beginPath(); context.moveTo(tox, toy);
                         context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 7), toy - headlen * Math.sin(angle - Math.PI / 7));
                         context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 7), toy - headlen * Math.sin(angle + Math.PI / 7));
                         context.closePath(); context.fill();
                    };
                    drawArrowLocal(annotation.startX, annotation.startY, annotation.endX, annotation.endY, annotation.thickness || 5);
                    break;
                }
                case 'box': {
                    context.strokeStyle = '#c0392b'; context.lineWidth = annotation.thickness || 5;
                    context.strokeRect(annotation.x, annotation.y, annotation.width, annotation.height);
                    break;
                }
            }
            context.restore();
        }
        
        // --- EVENT LISTENERS & INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', async () => {
            
            // 1. Initialiser le champ photo (avant le chargement des données)
            if (document.querySelectorAll('#adversary_photo_container .photo-input-wrapper').length === 0) {
                 addPhotoInput('adversary_photo_container', true); 
            }
            
            // 2. Charger les données locales ou la config par défaut
            const isLocalDataLoaded = loadFormData();
            if (!isLocalDataLoaded) {
                 await loadDefaultConfig();
            }

            // 3. Initialiser l'UI (Quick Edit, etc.) après le chargement des options
            setupQuickEditPanel(); 

            document.querySelector('.container').addEventListener('click', (event) => {
                const header = event.target.closest('.collapsible-header');
                if (header) { const container = header.parentElement; if (container && container.classList.contains('collapsible-container')) { container.classList.toggle('open'); } }
            });
            const modal = document.getElementById('editMemberModal'); const form = document.getElementById('editMemberForm');
            document.getElementById('modal_saveBtn').addEventListener('click', () => {
                const buttonId = form.dataset.editingButtonId; const button = document.getElementById(buttonId);
                if (button) {
                    button.dataset.trigramme = document.getElementById('modal_trigramme').value;
                    
                    for (const key in memberConfig) {
                        const attrName = key.replace(/s$/, '');
                        const selectId = 'modal_' + attrName;
                        const select = document.getElementById(selectId);
                        if (select) {
                            button.dataset[attrName] = select.value;
                        }
                    }
                    
                    updateMemberButtonVisuals(button);
                    populateQuickEditPanel(buttonId);
                    saveFormData();
                }
                modal.close();
            });
            document.getElementById('modal_cancelBtn').addEventListener('click', () => modal.close());
            
            // Logique de renvoi en attente / suppression définitive
            document.getElementById('modal_deleteBtn').addEventListener('click', () => {
                const buttonId = form.dataset.editingButtonId; const button = document.getElementById(buttonId);
                const isUnassigned = button.closest('#unassigned_members_container');

                if (!button) return;

                if (isUnassigned) {
                    // Si dans 'Personnel à attribuer', on supprime définitivement
                    if(confirm(`Voulez-vous vraiment SUPPRIMER DÉFINITIVEMENT le membre ${button.dataset.trigramme || 'N/A'}? Cette action est irréversible.`)) {
                        button.remove(); 
                        saveFormData(); 
                        modal.close(); 
                        activeMemberId = null;
                        document.getElementById('quickEditPanel').style.display = 'none';
                    }
                } else {
                    // Si dans un véhicule, on renvoie dans 'Personnel à attribuer'
                    if(confirm(`Voulez-vous renvoyer le membre ${button.dataset.trigramme || 'N/A'} dans la section "Personnel à attribuer"?`)) {
                        button.dataset.cellule = 'Sans'; // On réinitialise sa cellule
                        button.dataset.fonction = 'Sans'; // On réinitialise sa fonction
                        updateMemberButtonVisuals(button);
                        unassignedContainer.appendChild(button);
                        saveFormData(); 
                        modal.close(); 
                        activeMemberId = null;
                        document.getElementById('quickEditPanel').style.display = 'none';
                    }
                }
            });
            
            const dockMenu = document.getElementById('dockMenu'); const dockToggleBtn = document.getElementById('dockToggleBtn');
            dockToggleBtn.addEventListener('click', (event) => { event.stopPropagation(); dockMenu.classList.toggle('collapsed'); localStorage.setItem('dockCollapsed', dockMenu.classList.contains('collapsed')); });
            document.getElementById('darkModeToggle').addEventListener('click', () => {
                document.body.classList.toggle('light-mode'); document.body.classList.toggle('dark-mode');
                const isDarkMode = document.body.classList.contains('dark-mode');
                localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
                document.getElementById('darkModeIcon').textContent = isDarkMode ? 'nightlight' : 'clear_day';
            });
            document.getElementById('settingsBtn').addEventListener('click', () => {
                const settingsModal = document.getElementById('settingsModal');
                document.getElementById('geminiApiKey').value = localStorage.getItem('geminiApiKey') || '';
                settingsModal.showModal();
            });
            document.getElementById('settings_closeBtn').addEventListener('click', () => {
                document.getElementById('settingsModal').close();
            });
            document.getElementById('settings_saveBtn').addEventListener('click', () => {
                const apiKey = document.getElementById('geminiApiKey').value;
                if (apiKey) {
                    localStorage.setItem('geminiApiKey', apiKey);
                    alert("Clé API sauvegardée.");
                    document.getElementById('settingsModal').close();
                } else {
                    alert("Veuillez saisir une clé API.");
                }
            });
            document.getElementById('resetBtn').addEventListener('click', () => { 
                if (confirm("Voulez-vous vraiment réinitialiser tout le formulaire?")) { 
                    localStorage.removeItem('oiFormData'); 
                    // Supprime le drapeau d'alerte pour qu'il s'affiche à nouveau si l'erreur se reproduit
                    localStorage.removeItem('quotaAlertShown'); 
                    location.reload(); 
                } 
            });
            document.getElementById('tutorialBtn').addEventListener('click', startTutorial);
            
            // Nouveau gestionnaire d'événement pour le bouton d'import JSON
            importJsonConfigBtn.addEventListener('click', () => {
                 jsonConfigInput.click();
            });
            
            jsonConfigInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) { return; }
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        if (config && (Array.isArray(config.members) || config.options)) {
                            // Supprime les données existantes avant de charger la nouvelle config
                            patracdvrContainer.innerHTML = ''; 
                            loadConfigObject(config); 
                        }
                        else { alert("Le fichier JSON est invalide ou ne contient pas de tableau 'members' ou d'objet 'options'."); }
                    } catch (err) { alert("Erreur de lecture du JSON."); console.error(err); }
                    location.reload(); // Rechargement forcé après l'import pour nettoyer l'état du formulaire
                };
                reader.readAsText(file);
                // Réinitialise l'input pour permettre l'import du même fichier si besoin
                event.target.value = null; 
            });

            // --- NOUVEAU: Chargement de la config par défaut sur clic ---
            importDefaultConfigBtn.addEventListener('click', () => {
                if(confirm("Ceci va remplacer la configuration PATRACDVR et les options d'équipement actuelles. Continuer?")) {
                    loadDefaultConfig();
                }
            });
            
            // --- Logique RETEX originale (Génération de lien externe) ---
            retexReportBtn.addEventListener('click', () => {
                 const dateOp = document.getElementById('date_op').value;
                 const nomAdversaire = document.getElementById('nom_adversaire').value;
                 if (!dateOp || !nomAdversaire) {
                    alert("Veuillez renseigner la date de l'opération et le nom de l'adversaire pour créer le lien RETEX.");
                    return;
                 }
                 const safeAdversaireName = nomAdversaire.trim().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                 const oiId = `${dateOp}_${safeAdversaireName}`;
                 const retexUrl = `${RETEX_BASE_URL}?oiId=${encodeURIComponent(oiId)}`;
                 window.open(retexUrl, '_blank');
            });
            // --- Fin Logique RETEX originale ---
            
            resetPatracdvrBtn.addEventListener('click', () => { 
                if (confirm("Voulez-vous vraiment effacer TOUS les véhicules et membres du PATRACDVR et vider la sauvegarde locale des membres ?")) { 
                    patracdvrContainer.innerHTML = ''; 
                    unassignedContainer.innerHTML = ''; 
                    localStorage.removeItem('oiFormData'); // Assurez-vous d'effacer les données du stockage local
                    saveFormData(); 
                    alert("PATRACDVR réinitialisé. La prochaine fois, une configuration par défaut sera chargée (si disponible).");
                } 
            });
            
            const vehicleCreationContainer = document.getElementById('vehicle_creation_buttons');
            availableVehicles.forEach(vehicle => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'add-btn add-vehicle-btn';
                btn.textContent = `➕ ${vehicle}`;
                btn.addEventListener('click', () => addPatracdvrRow(vehicle));
                vehicleCreationContainer.insertBefore(btn, document.getElementById('addManualVehicleBtn'));
            });

            // Ajout des écouteurs d'événements pour les nouveaux boutons manuels
            document.getElementById('addManualVehicleBtn').addEventListener('click', addManualVehicle);
            document.getElementById('addManualMemberBtn').addEventListener('click', addManualMember);

            document.querySelector('.wizard-step:has(#patracdvr_container)').addEventListener('click', handleMemberSelection);

            document.getElementById('quickEditPanel').addEventListener('click', (event) => {
                event.stopPropagation();
                const target = event.target;
                const quickEditButton = target.closest('.quick-edit-btn');
                const fullEditButton = target.closest('#fullEditBtn');

                if (quickEditButton && activeMemberId) {
                    const activeMember = document.getElementById(activeMemberId);
                    if (!activeMember) return;
                    const attribute = quickEditButton.dataset.attribute;
                    const value = quickEditButton.dataset.value;
                    activeMember.dataset[attribute] = value;
                    
                    // Si on change la cellule, mettre à jour la fonction si on passe à "Sans" ou vice-versa
                    if (attribute === 'cellule' && value === 'Sans') {
                        activeMember.dataset.fonction = 'Sans';
                    }
                    if (attribute === 'fonction' && value !== 'Sans' && activeMember.dataset.cellule === 'Sans') {
                        activeMember.dataset.cellule = 'India 1'; // Assure une cellule par défaut si on donne une fonction
                    }
                    
                    updateMemberButtonVisuals(activeMember);
                    const group = quickEditButton.parentElement;
                    group.querySelectorAll('.quick-edit-btn').forEach(btn => btn.classList.remove('selected'));
                    quickEditButton.classList.add('selected');
                    saveFormData();
                } else if (fullEditButton && activeMemberId) {
                    openMemberModal(activeMemberId);
                }
            });

            const quickEditModal = document.getElementById('quickEditModal');
            document.getElementById('quick_modal_closeBtn').addEventListener('click', () => quickEditModal.close());
            quickEditModal.addEventListener('click', (event) => {
                const target = event.target.closest('.quick-edit-btn');
                if (!target || !activeMemberId) return;

                const activeMember = document.getElementById(activeMemberId);
                if (!activeMember) return;

                const attribute = target.dataset.attribute;
                const value = target.dataset.value;

                activeMember.dataset[attribute] = value;
                
                // Logique de mise à jour de la cellule/fonction
                if (attribute === 'cellule' && value === 'Sans') {
                    activeMember.dataset.fonction = 'Sans';
                }
                if (attribute === 'fonction' && value !== 'Sans' && activeMember.dataset.cellule === 'Sans') {
                    activeMember.dataset.cellule = 'India 1';
                }
                
                updateMemberButtonVisuals(activeMember);
                
                const group = target.closest('.quick-edit-options');
                if(group) {
                    group.querySelectorAll('.quick-edit-btn').forEach(btn => btn.classList.remove('selected'));
                }
                target.classList.add('selected');

                saveFormData();
            });


            canvas.addEventListener('mousedown', handleDrawStart); canvas.addEventListener('mousemove', handleDrawMove);
            canvas.addEventListener('mouseup', handleDrawEnd); canvas.addEventListener('mouseout', handleDrawEnd);
            // Correction: Utiliser { passive: false } pour empêcher le défilement pendant le dessin/déplacement sur mobile
            canvas.addEventListener('touchstart', handleDrawStart, { passive: false }); 
            canvas.addEventListener('touchmove', handleDrawMove, { passive: false });
            canvas.addEventListener('touchend', handleDrawEnd);
            
            document.querySelectorAll('.toolbar-main-tools .tool-btn').forEach(btn => {
                btn.addEventListener('click', () => { const toolId = btn.id.split('_')[1]; if (['move', 'location', 'arrow', 'box'].includes(toolId)) setActiveTool(toolId); });
            });
            document.getElementById('tool_reset').addEventListener('click', () => { annotations = []; selectedAnnotation = null; setContextualTools(null); redrawCanvas(); saveFormData();});
            document.getElementById('annotation_cancel').addEventListener('click', () => annotationModal.close());
            document.getElementById('annotation_save').addEventListener('click', () => {
                const targetId = annotationModal.dataset.targetPreviewId; const previewImg = document.getElementById(targetId);
                if(previewImg) {
                    // La source affichée reste la dernière image annotée (ou l'originale si pas d'annotation)
                    // Mais on sauvegarde les annotations dans le dataset
                    previewImg.dataset.annotations = JSON.stringify(annotations);
                }
                // NOTE: La source du previewImg n'est plus mise à jour ici car l'image annotée sera re-générée DANS buildPdf.
                saveFormData(); annotationModal.close();
            });
            
            // Événement pour la rotation libre
            rotationInput.addEventListener('change', updateAnnotationRotation);

            document.getElementById('delete_btn').addEventListener('click', () => { if(selectedAnnotation){ annotations = annotations.filter(ann => ann !== selectedAnnotation); selectedAnnotation = null; setContextualTools(null); redrawCanvas(); saveFormData(); } });
            document.getElementById('edit_text_btn').addEventListener('click', () => { if(selectedAnnotation && selectedAnnotation.type === 'location'){ const newText = prompt('Modifier texte:', selectedAnnotation.text); if(newText !== null){ selectedAnnotation.text = newText; redrawCanvas(); saveFormData(); } } });
            
            const importSessionBtn = document.getElementById('importSessionBtn');
            const exportSessionBtn = document.getElementById('exportSessionBtn');
            const sessionFileInput = document.getElementById('sessionFileInput');
            importSessionBtn.addEventListener('click', () => sessionFileInput.click());
            exportSessionBtn.addEventListener('click', () => {
                saveFormData();
                const dataString = localStorage.getItem('oiFormData');
                if (!dataString) { alert("Aucune donnée à exporter."); return; }
                const blob = new Blob([dataString], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const date = new Date().toISOString().slice(0, 10);
                link.download = `OI_Session_${date}.json`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            });
            sessionFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const jsonContent = e.target.result;
                        JSON.parse(jsonContent);
                        localStorage.setItem('oiFormData', jsonContent);
                        alert("Session importée avec succès. Rechargement de la page.");
                        location.reload();
                    } catch (err) {
                        alert("Fichier invalide ou corrompu.");
                    }
                };
                reader.readAsText(file);
                event.target.value = null;
            });

            // --- GESTION DU DRAG AND DROP GLOBALE ---
            document.addEventListener('dragstart', e => { 
                const target = e.target.closest('.patracdvr-member-btn, .time-item');
                if (target && target.classList.contains('draggable')) { 
                    draggedItem = target; 
                    // Stocke l'ID ou toute info nécessaire pour identifier le membre
                    e.dataTransfer.setData('text/plain', target.id);
                    setTimeout(() => target.classList.add('dragging'), 0); 
                } 
            });

            document.addEventListener('dragend', () => { 
                if (draggedItem) { 
                    draggedItem.classList.remove('dragging'); 
                    draggedItem = null; 
                    // La sauvegarde se fait dans handleDrop
                } 
            });

            // Cibler les conteneurs de dépôt (à la fois les zones de véhicule et la zone non assignée)
            const dropContainers = document.querySelectorAll('.patracdvr-members-container, #unassigned_members_container');
            dropContainers.forEach(container => {
                container.addEventListener('dragenter', handleDragEnter);
                container.addEventListener('dragleave', handleDragLeave);
                container.addEventListener('dragover', handleDragOver); // Pour le tri visuel
                container.addEventListener('drop', handleDrop);
            });

            // Logique de dragover pour les événements temporels (gestion du tri à l'intérieur)
            document.addEventListener('dragover', e => {
                e.preventDefault();
                const targetContainer = e.target.closest('#time_events_container');
                if (targetContainer && draggedItem && draggedItem.classList.contains('time-item')) {
                    const afterElement = getDragAfterElement(targetContainer, e.clientY);
                    if (afterElement == null) { targetContainer.appendChild(draggedItem); } 
                    else { targetContainer.insertBefore(draggedItem, afterElement); }
                }
            });
            // --- FIN GESTION DRAG AND DROP GLOBALE ---
            
            // --- GESTION DU MODE PRÉSENTATION/TÉLÉCHARGEMENT PDF (MISE À JOUR) ---
            const presentationModal = document.getElementById('presentationModal');
            const closePresentationModalBtn = document.getElementById('closePresentationModalBtn');
            const downloadPdfBtn = document.getElementById('downloadPdfBtn');

            // 1. Fonction de téléchargement du PDF (appelée depuis la modale)
            async function downloadOiPdf() {
                if (typeof PDFLib === 'undefined') { alert("Erreur: La bibliothèque PDF n'est pas encore chargée."); return; }
                const btn = downloadPdfBtn;
                const originalText = btn.textContent;
                btn.textContent = 'Génération en cours...'; btn.disabled = true;
                
                try {
                    const result = await buildPdf();
                    if (!result) { 
                        alert("La génération a échoué. Vérifiez vos données.");
                        return; 
                    }
                    const { pdfBytes, formData } = result;
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const url = URL.createObjectURL(blob);
                    
                    const getVal = (id) => formData[id] || 'RAS';
                    const link = document.createElement('a');
                    link.href = url;
                    // Définir le nom du fichier
                    link.download = `OI_${getVal('date_op').replace(/[\/\\?%*:|"<>]/g, '-')}_${getVal('nom_adversaire').replace(/ /g, '_')}.pdf`;
                    document.body.appendChild(link); 
                    link.click(); 
                    document.body.removeChild(link);
                    
                    alert("Le document PDF a été téléchargé.");
                    
                } catch (error) {
                    console.error("Erreur critique lors de la génération du PDF:", error);
                    alert("Une erreur critique est survenue lors de la génération du PDF. Consultez la console (F12).");
                } finally {
                    btn.textContent = originalText; btn.disabled = false;
                }
            }

            // 2. Fonction d'ouverture du Mode Présentation (HTML + bouton PDF)
            function openPresentationMode() {
                const presentationContent = document.getElementById('presentation-content');
                
                if (!presentationModal) {
                    console.error("Modale 'presentationModal' non trouvée.");
                    return;
                }

                // Afficher le chargement pour les annotations éventuelles
                presentationContent.innerHTML = '<h2>Chargement de l\'aperçu...</h2><p style="text-align:center;">Veuillez patienter pendant la compilation des images annotées.</p>';

                // Ouvre la modale
                if(typeof presentationModal.showModal === 'function') {
                    presentationModal.showModal();
                } else {
                    presentationModal.style.display = 'block';
                }
                
                // Génère le contenu HTML avec les images annotées
                buildPresentationHtml().then(html => {
                    presentationContent.innerHTML = html;
                }).catch(err => {
                    console.error("Erreur lors de la construction de l'aperçu HTML:", err);
                    const dangerColor = document.body.classList.contains('dark-mode') ? '#c0392b' : '#c0392b';
                    presentationContent.innerHTML = '<h2>Erreur d\'affichage</h2><p style="color:' + dangerColor + ';">Une erreur est survenue lors de la compilation des images annotées pour l\'aperçu. Réessayez ou vérifiez la console.</p>';
                });
            }

            // 3. Configuration des événements
            previewBtn.addEventListener('click', openPresentationMode);
            downloadPdfBtn.addEventListener('click', downloadOiPdf);

            if (closePresentationModalBtn) {
                closePresentationModalBtn.addEventListener('click', () => {
                    if (presentationModal) {
                         if(typeof presentationModal.close === 'function') {
                            presentationModal.close();
                        } else {
                            presentationModal.style.display = 'none';
                        }
                    }
                });
            }

            // --- GESTION DES FICHIERS RETEX (LOGIQUE COMPLÉTÉE) ---

            // Fonction pour lire les fichiers sélectionnés et mettre à jour le tableau global
            retexFileInput.addEventListener('change', (event) => {
                retexFiles = []; // Réinitialiser le tableau des rapports
                const files = event.target.files;
                let fileNames = [];
                
                if (files.length === 0) {
                    retexFileNames.textContent = 'Aucun fichier sélectionné';
                    retexStatus.textContent = '';
                    generateRetexPdfBtn.style.display = 'none';
                    return;
                }

                const processFile = (file) => {
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const jsonContent = JSON.parse(e.target.result);
                                retexFiles.push(jsonContent);
                                resolve(file.name);
                            } catch (error) {
                                console.error(`Erreur de lecture du fichier JSON ${file.name}:`, error);
                                resolve(null); 
                            }
                        };
                        reader.onerror = () => {
                             console.error(`Erreur de lecture du fichier ${file.name}.`);
                             resolve(null);
                        };
                        reader.readAsText(file);
                    });
                };
                
                // Traiter tous les fichiers
                const filePromises = Array.from(files).map(processFile);
                Promise.all(filePromises).then(results => {
                    fileNames = results.filter(name => name !== null);
                    if (fileNames.length > 0) {
                        retexFileNames.textContent = fileNames.join(', ');
                        retexStatus.textContent = `${fileNames.length} fichier(s) JSON valide(s) chargé(s). Prêt pour l'analyse.`;
                        retexOutput.style.display = 'none'; // Cacher la sortie si de nouveaux fichiers sont chargés
                    } else {
                         retexFileNames.textContent = 'Aucun fichier JSON valide sélectionné.';
                         retexStatus.textContent = "Aucun rapport valide n'a pu être chargé.";
                         retexOutput.innerHTML = '';
                    }
                });
            });

            // Fonction pour générer l'analyse via Gemini (Logique fournie par l'utilisateur)
            async function generateGeminiAnalysis(reports) {
                const apiKey = localStorage.getItem('geminiApiKey');
                if (!apiKey) {
                    retexStatus.textContent = "Erreur: Clé API Gemini non configurée. Allez dans Paramètres.";
                    return null;
                }
                
                // Convertir les objets JSON en une chaîne de caractères lisible pour l'IA
                const formattedReports = reports.map(report => JSON.stringify(report, null, 2)).join('\n\n--- Rapport suivant ---\n\n');

                const prompt = `
                Tu es un analyste tactique de la Gendarmerie Française.
                Ton rôle est de synthétiser des rapports de retour d'expérience (RETEX) suite à des opérations de police judiciaire.
                L'objectif est de produire une analyse impartiale et objective, en te basant uniquement sur les faits rapportés, sans émettre de jugement personnel.

                **Tâche:**
                Prends en compte les comptes-rendus RETEX fournis ci-dessous.
                Identifie les points clés et les enseignements à tirer de l'opération.
                Classe et structure ta synthèse en trois sections principales, chacune avec des sous-sections claires:
                1.  **Points Forts:** Ce qui a bien fonctionné.
                    * Coordination:
                    * Matériel/Équipement:
                    * Tactique:
                2.  **Points Faibles:** Ce qui a posé problème.
                    * Communication:
                    * Préparation:
                    * Exécution:
                3.  **Axe d'Amélioration:** Recommandations concrètes et concises pour de futures opérations.
                    * Formation:
                    * Procédure:
                    * Équipement:

                **Contenu des rapports RETEX:**
                ${formattedReports}

                **Format de la réponse:**
                Utilise le format Markdown pour ta réponse. Respecte scrupuleusement les en-têtes et sous-en-têtes demandés.
                Ne te base que sur les informations que je te donne et ne spécule pas sur des éléments extérieurs.
                S'il n'y a pas d'informations pour une section, écris "RAS" (Rien À Signaler).
                Reste professionnel et factuel. N'utilise pas de phrases trop longues.
                Commence ta réponse par "### Rapport d'Analyse Opérationnelle".
                `;

                try {
                    retexStatus.textContent = "Analyse en cours par l'IA...";
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'x-goog-api-key': apiKey
                        },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Erreur API: ${response.status} - ${JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    const textOutput = data?.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (textOutput) {
                        retexStatus.textContent = "Analyse terminée.";
                        // Utilise marked.js pour convertir le Markdown en HTML
                        return marked.parse(textOutput);
                    } else {
                        retexStatus.textContent = "Analyse terminée, mais aucune réponse significative n'a été reçue.";
                        return "<p>Aucune réponse significative de l'IA.</p>";
                    }
                } catch (error) {
                    console.error("Erreur lors de la génération de l'analyse:", error);
                    retexStatus.textContent = `Erreur: ${error.message}`;
                    return null;
                }
            }

            // Fonction pour générer le PDF du rapport Retex (Utilisation de jspdf et html2canvas)
            async function generateRetexPdf() {
                if (typeof window.jspdf === 'undefined' || typeof window.html2canvas === 'undefined') {
                    alert("Erreur: Les bibliothèques de génération PDF ne sont pas chargées.");
                    return;
                }
                const btn = generateRetexPdfBtn;
                const originalText = btn.textContent;
                btn.textContent = 'Génération PDF en cours...'; 
                btn.disabled = true;

                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF('p', 'pt', 'a4', true);
                    const content = document.getElementById('retex_output');
                    
                    // Assurer que le contenu est visible pour html2canvas
                    const originalDisplay = content.style.display;
                    content.style.display = 'block';

                    // Utiliser html2canvas pour obtenir la capture d'écran du contenu
                    const canvas = await html2canvas(content, {
                        scale: 2, // Améliorer la qualité d'image
                        logging: false,
                        useCORS: true
                    });

                    content.style.display = originalDisplay; // Rétablir l'affichage

                    const imgData = canvas.toDataURL('image/jpeg', 1.0);
                    const imgWidth = 550; 
                    const pageHeight = 842; 
                    const imgHeight = canvas.height * imgWidth / canvas.width;
                    let heightLeft = imgHeight;

                    let position = 0; // Position initiale du contenu sur la page (haut)
                    const margin = 20;

                    // Ajouter la première page
                    doc.addImage(imgData, 'JPEG', margin, margin, imgWidth, imgHeight);
                    heightLeft -= pageHeight;

                    // Gérer le contenu sur plusieurs pages
                    while (heightLeft >= 0) {
                        position = heightLeft - imgHeight;
                        doc.addPage();
                        doc.addImage(imgData, 'JPEG', margin, position + margin, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }

                    doc.save('Rapport_Retex.pdf');
                    retexStatus.textContent = 'Rapport PDF généré et téléchargé.';

                } catch (error) {
                    console.error("Erreur lors de la génération du PDF RETEX:", error);
                    alert("Une erreur est survenue lors de la génération du PDF du rapport. Consultez la console (F12).");
                } finally {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }
            }

            // Fonction de lancement de l'analyse (Contrôleur)
            launchRetexAnalysisBtn.addEventListener('click', async (event) => {
                event.preventDefault(); // Empêche la soumission du formulaire
                
                const files = retexFileInput.files;
                if (files.length === 0) {
                    retexStatus.textContent = "Veuillez sélectionner au moins un fichier JSON.";
                    return;
                }
                retexOutput.innerHTML = '';
                retexOutput.style.display = 'none';
                generateRetexPdfBtn.style.display = 'none';
                retexStatus.textContent = 'Lecture et analyse des fichiers en cours...';

                let allReports = [];
                const promises = [];
                
                // 1. Lecture des fichiers (Lecture asynchrone pour chaque fichier)
                for (const file of files) {
                    promises.push(new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const jsonData = JSON.parse(e.target.result);
                                allReports.push(jsonData);
                                resolve();
                            } catch (error) {
                                console.error(`Erreur de lecture du fichier ${file.name}:`, error);
                                // On résout pour ne pas bloquer les autres fichiers
                                resolve(); 
                            }
                        };
                        reader.onerror = (e) => {
                            console.error(`Erreur de lecture du fichier ${file.name}:`, e);
                            resolve(); // On résout pour ne pas bloquer les autres fichiers
                        }
                        reader.readAsText(file);
                    }));
                }

                try {
                    await Promise.all(promises);

                    // 2. Lancement de l'analyse Gemini
                    if (allReports.length > 0) {
                        const htmlOutput = await generateGeminiAnalysis(allReports);
                        
                        if (htmlOutput) {
                            retexOutput.innerHTML = htmlOutput;
                            retexOutput.style.display = 'block';
                            generateRetexPdfBtn.style.display = 'inline-block';
                            retexStatus.textContent = `Analyse terminée. ${allReports.length} rapport(s) traité(s).`;
                        } else {
                            retexOutput.innerHTML = "<p>Impossible de générer le rapport. Veuillez vérifier la console pour plus de détails.</p>";
                        }
                    } else {
                        retexStatus.textContent = "Erreur: Aucun rapport JSON valide n'a pu être chargé.";
                        retexOutput.innerHTML = '';
                    }
                } catch (error) {
                    retexStatus.textContent = `Erreur critique: ${error.message}`;
                    console.error("Erreur générale lors du processus d'analyse:", error);
                }
            });

            generateRetexPdfBtn.addEventListener('click', generateRetexPdf);

            if (localStorage.getItem('theme') === 'light') { document.body.classList.replace('dark-mode', 'light-mode'); document.getElementById('darkModeIcon').textContent = 'clear_day'; }
            if (localStorage.getItem('dockCollapsed') === 'true') { dockMenu.classList.add('collapsed'); }
            
            showStep(currentStep);
            
        });
        
        // --- LOGIQUE DE PRÉSENTATION (RÉUTILISÉE) ---

        /**
         * Construit le contenu HTML pour le mode présentation, en nettoyant les **.
         * @returns {Promise<string>} Le contenu HTML stylisé de l'O.I.
         */
        async function buildPresentationHtml() {
            saveFormData();
            const formDataString = localStorage.getItem('oiFormData');
            if (!formDataString) { return "<h2>Aucune donnée à présenter.</h2>"; }
            const formData = JSON.parse(formDataString);
            const getVal = (id) => formData[id] || '';
            const isDarkMode = document.body.classList.contains('dark-mode');
            
            // Couleurs et styles pour simuler le rendu
            const accentColor = isDarkMode ? '#5b9bd5' : '#0033a0';
            const primaryText = isDarkMode ? '#e0e0e0' : '#212529';
            const secondaryText = isDarkMode ? '#95a5a6' : '#6c757d';
            const dangerColor = '#c0392b';

            let htmlContent = `<div style="font-family: 'Oswald', sans-serif; color: ${primaryText};">`;

            // Fonction pour retirer les marqueurs de gras Markdown (**)
            const cleanText = (text) => String(text || '').replace(/\*\*(.*?)\*\*/g, '$1').trim();
            
            const wrapHtml = (text, tag = 'p', style = {}) => {
                const styleString = Object.entries(style).map(([key, value]) => `${key}:${value}`).join(';');
                // Retirer les ** du texte pour le HTML et remplacer \n par <br>
                const formattedText = String(text || '')
                    .replace(/\*\*/g, '') 
                    .replace(/\n/g, '<br>');
                return `<${tag} style="${styleString}">${formattedText}</${tag}>`;
            };

            const drawTitleHtml = (text) => wrapHtml(cleanText(text), 'h2', { 'color': accentColor, 'font-size': '1.8em', 'margin-top': '20px', 'padding-bottom': '5px', 'border-bottom': `2px solid ${accentColor}` });
            const drawSubTitleHtml = (text) => wrapHtml(cleanText(text), 'h3', { 'color': accentColor, 'font-size': '1.3em', 'margin-top': '15px', 'margin-bottom': '10px' });
            const drawTextHtml = (text, bold = false, color = primaryText, size = '1.1em', indent = '15px') => wrapHtml(text, 'p', { 'font-weight': bold ? '500' : '400', 'color': color, 'font-size': size, 'margin-bottom': '8px', 'padding-left': indent, 'white-space': 'pre-wrap' });
            
            const drawTableHtml = (headers, rows) => {
                let table = `<table style="width: 100%; border-collapse: collapse; margin-top: 15px; margin-bottom: 20px;">`;
                table += `<thead style="background-color: ${accentColor}; color: white;"><tr>`;
                headers.forEach(h => { table += `<th style="padding: 10px; border: 1px solid ${primaryText}; text-align: left;">${h}</th>`; });
                table += `</tr></thead><tbody>`;
                rows.forEach(row => {
                    table += `<tr style="background-color: ${isDarkMode ? '#2a2a2a' : '#f8f9fa'};">`;
                    row.forEach(cell => { 
                        // Assure que le contenu des cellules est nettoyé des **
                        const cellContent = String(cell || '').replace(/\*\*/g, '').replace(/\n/g, '<br>');
                        table += `<td style="padding: 10px; border: 1px solid ${secondaryText}; vertical-align: top;">${cellContent}</td>`; 
                    });
                    table += `</tr>`;
                });
                table += `</tbody></table>`;
                return table;
            };

            // Fonction pour gérer le dessin de l'image (PDFLib n'est pas utilisé ici, on utilise le canvas temp)
            const drawImageHtml = async (id, title) => {
                let imageHtml = '';
                const wrappers = document.querySelectorAll(`#${id} .photo-input-wrapper`);
                
                for(let i = 0; i < wrappers.length; i++) {
                    const wrapper = wrappers[i];
                    const previewImg = wrapper.querySelector('.image-preview');
                    if (!previewImg || !previewImg.dataset.originalSrc) continue;

                    const originalSrc = previewImg.dataset.originalSrc;
                    const annotationsJson = previewImg.dataset.annotations;
                    const annotations = JSON.parse(annotationsJson || '[]');
                    
                    let dataSrcToDisplay = originalSrc;
                    if (annotations.length > 0) {
                        try {
                             // Générer l'image annotée en base64 pour l'affichage dans le HTML
                            const arrayBuffer = await createAnnotatedImageBlob(originalSrc, annotations);
                            const base64String = btoa(new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), ''));
                            dataSrcToDisplay = `data:image/jpeg;base64,${base64String}`;
                        } catch (e) {
                            console.error(`Erreur de génération d'image annotée pour ${title} (index ${i}):`, e);
                            dataSrcToDisplay = originalSrc; // Revenir à l'original si la génération échoue
                        }
                    }

                    const finalTitle = wrappers.length > 1 ? `${title} (${i+1})` : title;
                    imageHtml += `<div class="image-container" style="text-align: center; margin: 20px 0; border: 1px solid ${accentColor}; padding: 10px; background-color: ${isDarkMode ? '#1e1e1e' : '#ffffff'};">`;
                    htmlContent += `<h4 style="color: ${accentColor}; margin-bottom: 10px;">${finalTitle}</h4>`;
                    imageHtml += `<img src="${dataSrcToDisplay}" alt="${finalTitle}" style="max-width: 100%; height: auto; border-radius: 4px; box-shadow: 0 4px 8px rgba(0,0,0,${isDarkMode ? 0.4 : 0.1});">`;
                    imageHtml += `</div>`;
                }
                return imageHtml;
            };
            
            // --- EXTRACTION DES COMPOSITIONS (SIMPLIFIÉE) ---
            const getCompositionHtml = (teamPrefix) => {
                const membersByCell = {};
                const allMembers = (formData.patracdvr_rows || []).flatMap(row => row.members);
                
                allMembers.forEach(member => {
                    if (member.cellule && member.cellule.toLowerCase().startsWith(teamPrefix)) {
                        if (!membersByCell[member.cellule]) membersByCell[member.cellule] = [];
                        // Format: TRIGRAMME (Fonction)
                        member.trigramme && membersByCell[member.cellule].push(
                            `<span style="color: ${primaryText};">${member.trigramme}</span>` + 
                            (member.fonction && member.fonction !== 'Sans' ? ` (${member.fonction})` : '')
                        );
                    }
                });

                const naturalSort = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
                const sortedKeys = Object.keys(membersByCell).sort(naturalSort);
                
                let compositionHtml = '<div style="padding-left: 15px; margin-bottom: 15px;">';
                sortedKeys.forEach(cell => {
                    compositionHtml += `<p style="margin-bottom: 5px;"><strong style="color: ${dangerColor}; font-size: 1.1em;">${cell.toUpperCase()}</strong> : ${membersByCell[cell].join(', ')}</p>`;
                });
                compositionHtml += '</div>';
                return sortedKeys.length > 0 ? compositionHtml : drawTextHtml('Aucun membre assigné.', false, secondaryText);
            };
            
            // --- CONSTRUCTION DU CONTENU ASYNCHRONE ---
            
            // 1. SITUATION
            htmlContent += drawTitleHtml(`Ordre Initial - ${getVal('nom_adversaire') || 'OPÉRATION'}`);
            htmlContent += drawTextHtml(`Date de l'opération : ${getVal('date_op') || 'N/A'}`, true, primaryText, '1.2em', '0');
            htmlContent += drawTitleHtml("1. SITUATION");
            htmlContent += drawSubTitleHtml("1.1 Situation Générale"); htmlContent += drawTextHtml(getVal('situation_generale'));
            htmlContent += drawSubTitleHtml("1.2 Situation Particulière"); htmlContent += drawTextHtml(getVal('situation_particuliere'));

            // 1.3 ADVERSAIRE (Image principale)
            htmlContent += drawTitleHtml("1.3 ADVERSAIRE");
            htmlContent += await drawImageHtml('adversary_photo_container', "Photo de l'objectif"); 

            const meText = (formData.me_list || []).map((me, i) => `ME${i+1}: ${me}`).join(' | ');
            const adversaireRows = [
                ['Nom/Prénom', getVal('nom_adversaire')], ['Domicile', getVal('domicile_adversaire')],
                ['Naissance', `${getVal('date_naissance')} à ${getVal('lieu_naissance')}`],
                ['Description', `${getVal('stature_adversaire')} / ${getVal('ethnie_adversaire')}`],
                ['Signes particuliers', getVal('signes_particuliers')], ['Profession', getVal('profession_adversaire')],
                ['Antécédents', getVal('antecedents_adversaire')], ['État d\'esprit', (formData.etat_esprit_list || []).join(', ')],
                ['Attitude (connue)', getVal('attitude_adversaire')], ['Volume (renfort)', (formData.volume_list || []).join(', ')],
                ['Substances', getVal('substances_adversaire')], ['Véhicules', (formData.vehicules_list || []).join(', ')],
                ['Armes connues', getVal('armes_connues')], ['Moyens Employés', meText],
            ].filter(row => row[1] && String(row[1]).trim() !== 'à');

            if (adversaireRows.length > 0) {
                htmlContent += drawTableHtml(["Information", "Détail"], adversaireRows);
            } else {
                 htmlContent += drawTextHtml("Aucune information détaillée sur l'adversaire.");
            }

            htmlContent += await drawImageHtml('adversary_extra_photos_container', 'Photo Supplémentaire - Adversaire');
            htmlContent += await drawImageHtml('renforts_photo_container', 'Photo - Renfort Potentiel');


            // 1.4 ENVIRONNEMENT
            htmlContent += drawTitleHtml("1.4 ENVIRONNEMENT");
            htmlContent += drawSubTitleHtml("Ami(e)s (soutien)"); htmlContent += drawTextHtml(getVal('amies'));
            htmlContent += drawSubTitleHtml("Terrain / Météo"); htmlContent += drawTextHtml(getVal('terrain_info'));
            htmlContent += drawSubTitleHtml("Population"); htmlContent += drawTextHtml(getVal('population'));
            htmlContent += drawSubTitleHtml("Cadre juridique"); htmlContent += drawTextHtml(getVal('cadre_juridique'));

            // 2. MISSION & 3. EXÉCUTION
            htmlContent += drawTitleHtml("2. MISSION DU PSIG");
            htmlContent += drawTextHtml(getVal('missions_psig'), true, dangerColor, '1.6em', '0');
            
            htmlContent += drawTitleHtml("3. EXÉCUTION");
            const execText = `En vue d'appréhender le mis en cause et empêcher la déperdition des preuves,<br>Je veux, le ${getVal('date_execution') || '(date)'} à partir de ${getVal('heure_execution') || '(heure)'}, pour une action ${getVal('type_action') || '(type d\'action)'} investir le domicile<br>présumé de ${getVal('nom_adversaire') || '(nom de l\'adversaire)'} après avoir bouclé celui-ci.`;
            htmlContent += wrapHtml(execText, 'p', { 'font-size': '1.4em', 'margin-bottom': '15px', 'padding-left': '0' });

            htmlContent += drawSubTitleHtml("Chronologie des temps");
            const chronoHeaders = ["Type", "Heure", "Description"];
            const chronoRows = (formData.time_events || []).map(e => [e.type || 'N/A', e.hour || 'N/A', e.description || 'N/A']);
            htmlContent += drawTableHtml(chronoHeaders, chronoRows);

            htmlContent += drawSubTitleHtml("Hypothèses");
            // CORRECTION: H1, H2, H3 en rouge gras
            htmlContent += drawTextHtml(`<span style="color: ${dangerColor}; font-weight: bold;">H1</span>: ${getVal('hypothese_h1')}<br><span style="color: ${dangerColor}; font-weight: bold;">H2</span>: ${getVal('hypothese_h2')}<br><span style="color: ${dangerColor}; font-weight: bold;">H3</span>: ${getVal('hypothese_h3')}`, true, primaryText, '1.2em');
            
            htmlContent += await drawImageHtml('photo_container_transport_pr', 'Transport PSIG vers PR');
            htmlContent += await drawImageHtml('photo_container_transport_domicile', 'Transport PR vers Domicile');
            htmlContent += await drawImageHtml('photo_container_bapteme_terrain', 'Baptême terrain');


            // 4. ARTICULATION
            htmlContent += drawTitleHtml("4. ARTICULATION (MOIPC/ZMSPCP)");
            htmlContent += drawTextHtml(`Place du Chef (Générale): ${getVal('place_chef')}`, true, primaryText, '1.2em', '0');

            // Équipe INDIA
            htmlContent += drawSubTitleHtml(`<span style="color: ${accentColor}; font-weight: bold;">Équipe INDIA (INTER)</span>`);
            htmlContent += wrapHtml('<strong style="color: ' + accentColor + ';">Composition:</strong>', 'h4', { 'padding-left': '15px', 'margin-top': '10px' });
            htmlContent += getCompositionHtml('india');
             // NOUVEAU BLOC: MOIPC (Mission, Objectif, Itinéraire, Points Particuliers, Conduite à Tenir)
            const moipcText = `<p style="padding-left:15px; margin-bottom: 8px;">
                <span style="color: ${dangerColor}; font-weight: bold;">M</span>ission : ${getVal('india_mission')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">O</span>bjectif : ${getVal('india_objectif')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">I</span>tinéraire : ${getVal('india_itineraire')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">P</span>oints Particuliers : ${getVal('india_points_particuliers')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">C</span>onduite à Tenir : ${getVal('india_cat')}
            </p>`;
            htmlContent += moipcText;
            
            htmlContent += await drawImageHtml('photo_container_itineraire_exterieur', 'Itinéraire Extérieur India');
            htmlContent += await drawImageHtml('photo_container_itineraire_interieur', 'Itinéraire Intérieur India');
            htmlContent += await drawImageHtml('photo_container_cellule_effraction', 'Cellule Effraction');

            // Équipe AO (avec acronymes en rouge)
            htmlContent += drawSubTitleHtml(`<span style="color: ${accentColor}; font-weight: bold;">Équipe Appui/Observation (AO) - ZMSPCP</span>`);
            htmlContent += wrapHtml('<strong style="color: ' + accentColor + ';">Composition:</strong>', 'h4', { 'padding-left': '15px', 'margin-top': '10px' });
            htmlContent += getCompositionHtml('ao');
            
           
            
            // CORRECTION: Mettre la première lettre des acronymes ZMSPCP en rouge
            const aoText = `<p style="padding-left:15px; margin-bottom: 8px;">
                <span style="color: ${dangerColor}; font-weight: bold;">Z</span>one d'installation : ${getVal('ao_zone_installation')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">M</span>ission : ${getVal('ao_mission')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">S</span>ecteur de surveillance : ${getVal('ao_secteur_surveillance')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">P</span>oints Particuliers : ${getVal('ao_points_particuliers')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">C</span>onduite à Tenir : ${getVal('ao_cat')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">P</span>lace du Chef : ${getVal('ao_place_chef')}
            </p>`;
            htmlContent += aoText;
            
            htmlContent += await drawImageHtml('photo_container_emplacement_ao', 'Emplacement AO');

            // 5. PATRACDVR
            htmlContent += drawTitleHtml("5. PATRACDVR (Détail de la Composition)");
            const patracHeaders = ["Trigramme", "Fonction", "Cellule", "Armement", "Équip. 1", "Équip. 2", "Tenue", "GPB"];
            for (const row of (formData.patracdvr_rows || [])) {
                if(row.vehicle && row.members && row.members.length > 0) {
                    htmlContent += drawSubTitleHtml(`Véhicule: ${row.vehicle}`);
                    const patracRows = row.members.filter(m => m.trigramme).map(m => [m.trigramme, m.fonction, m.cellule, m.armement, m.equipement, m.equipement2, m.tenue, m.gpb]);
                    if (patracRows.length > 0) { htmlContent += drawTableHtml(patracHeaders, patracRows); }
                }
            }
            
            // 6. CAT
            htmlContent += drawTitleHtml("6. CONDUITES À TENIR");
            htmlContent += drawSubTitleHtml("Générales"); htmlContent += drawTextHtml(getVal('cat_generales'), true);
            const noGoText = getVal('no_go');
            if (noGoText) {
                htmlContent += drawSubTitleHtml("NO GO");
                htmlContent += drawTextHtml(noGoText, true, dangerColor, '1.2em');
            }
            htmlContent += drawSubTitleHtml("Liaison"); htmlContent += drawTextHtml(getVal('cat_liaison'), true);
            
            // LIEN RETEX (Conservation pour la complétude)
            const dateOp = getVal('date_op');
            const nomAdversaire = getVal('nom_adversaire');
            if (dateOp && nomAdversaire) {
                const safeAdversaireName = nomAdversaire.trim().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                const oiId = `${dateOp}_${safeAdversaireName}`;
                const retexUrl = `${RETEX_BASE_URL}?oiId=${encodeURIComponent(oiId)}`;
                htmlContent += drawTitleHtml("LIEN RETEX");
                htmlContent += drawTextHtml("Lien d'accès au formulaire de Retour d'Expérience:", false);
                htmlContent += wrapHtml(`<a href="${retexUrl}" target="_blank" style="color: ${accentColor}; font-weight: bold; font-size: 1.1em; text-decoration: none;">${retexUrl}</a>`, 'p', { 'padding-left': '15px' });
            }

            htmlContent += `</div>`;
            return htmlContent;
        }
    </script>
</body>
</html>
