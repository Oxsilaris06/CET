<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gilette Takedown: Black Ops Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        :root {
            --ui-color: #3b82f6;
            --danger-color: #ef4444;
            --success-color: #10b981;
            --bg-dark: #0f172a;
        }
        
        body {
            background-color: #000;
            color: #e2e8f0;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }
        
        /* --- CRT & Scanlines Effect --- */
        #game-wrapper {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #0b0f19;
            overflow: hidden;
        }

        canvas { display: block; }

        .scanlines {
            position: absolute; inset: 0; pointer-events: none; z-index: 10;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            animation: scrollLines 10s linear infinite;
        }
        .vignette {
            position: absolute; inset: 0; pointer-events: none; z-index: 11;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
        }

        /* --- UI Elements --- */
        .hud-panel {
            backdrop-filter: blur(4px);
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid rgba(59, 130, 246, 0.3);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        
        .stencil { font-family: 'Black Ops One', cursive; }
        
        .btn-tac {
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-tac:active { transform: scale(0.95); }
        .btn-tac::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 2px;
            background: rgba(255,255,255,0.3);
        }

        /* Animations */
        @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }
        .animate-pulse-red { animation: pulse-red 2s infinite; }

        .modal-enter { animation: modalPop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        @keyframes modalPop { from { opacity: 0; transform: scale(0.9) translateY(20px); } to { opacity: 1; transform: scale(1) translateY(0); } }

        /* Custom Scrollbar for context menu if needed */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 2px; }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <canvas id="worldCanvas"></canvas> <!-- World & Shadows -->
        <canvas id="uiCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas> <!-- High Res UI overlays -->
        
        <div class="scanlines"></div>
        <div class="vignette"></div>

        <!-- MAIN HUD -->
        <div class="absolute inset-0 pointer-events-none p-4 flex flex-col justify-between z-20">
            
            <!-- TOP BAR -->
            <div class="flex justify-between items-start">
                <div class="flex flex-col gap-1">
                    <h1 class="stencil text-3xl text-blue-500 tracking-wider drop-shadow-lg leading-none">TAKEDOWN</h1>
                    <div id="phase-indicator" class="flex items-center gap-2 text-xs font-bold text-yellow-400 bg-yellow-900/30 px-2 py-1 rounded border border-yellow-500/30 w-max">
                        <span class="w-2 h-2 rounded-full bg-yellow-400 animate-pulse"></span>
                        <span id="phase-text">PLANIFICATION</span>
                    </div>
                </div>

                <div class="flex gap-3">
                    <div class="hud-panel px-4 py-2 rounded-lg flex flex-col items-center">
                        <span class="text-[10px] text-slate-400 tracking-widest uppercase">Hostiles</span>
                        <span id="hud-hostiles" class="text-2xl font-bold text-red-500 leading-none">0</span>
                    </div>
                    <div class="hud-panel px-4 py-2 rounded-lg flex flex-col items-center">
                        <span class="text-[10px] text-slate-400 tracking-widest uppercase">Civils</span>
                        <span id="hud-civils" class="text-2xl font-bold text-green-500 leading-none">0</span>
                    </div>
                </div>
            </div>

            <!-- CONTEXT ACTIONS (Right Side) -->
            <div id="context-layer" class="absolute right-4 bottom-32 flex flex-col gap-3 items-end pointer-events-none">
                <!-- Injected via JS -->
            </div>

            <!-- BOTTOM CONTROL BAR -->
            <div class="pointer-events-auto flex flex-col gap-3">
                
                <!-- Unit Specific Controls -->
                <div id="unit-controls" class="flex justify-center gap-6 transition-all duration-300 opacity-0 translate-y-10">
                    <button id="btn-flash" class="btn-tac group relative w-14 h-14 rounded-xl bg-slate-800 border border-slate-600 flex items-center justify-center hover:bg-slate-700 hover:border-yellow-400 transition-colors">
                        <span class="material-icons text-yellow-400 group-hover:scale-110 transition-transform">flash_on</span>
                        <div class="absolute -bottom-6 text-[10px] font-bold text-slate-400 bg-slate-900 px-2 py-0.5 rounded">STUN</div>
                        <div id="cd-flash" class="absolute inset-0 bg-black/60 origin-bottom transition-all duration-75" style="height:0%"></div>
                    </button>
                    
                    <button id="btn-reload" class="btn-tac group relative w-14 h-14 rounded-xl bg-slate-800 border border-slate-600 flex items-center justify-center hover:bg-slate-700 hover:border-blue-400 transition-colors">
                        <span class="material-icons text-blue-400 group-hover:rotate-180 transition-transform duration-500">sync</span>
                        <div class="absolute -bottom-6 text-[10px] font-bold text-slate-400 bg-slate-900 px-2 py-0.5 rounded">MAG</div>
                    </button>
                </div>

                <!-- Main Play/Pause -->
                <div class="hud-panel p-2 rounded-xl flex items-center justify-between gap-4">
                    <button onclick="Game.resetLevel()" class="btn-tac p-3 text-slate-400 hover:text-white rounded-lg hover:bg-white/5">
                        <span class="material-icons">restart_alt</span>
                    </button>

                    <div class="flex-1 flex justify-center">
                        <button id="btn-clear" class="btn-tac text-xs font-bold text-slate-400 hover:text-white uppercase tracking-widest px-4 py-2 hover:bg-white/5 rounded">
                            Reset Paths
                        </button>
                    </div>

                    <button id="btn-execute" class="btn-tac bg-blue-600 hover:bg-blue-500 text-white px-8 py-3 rounded-lg shadow-[0_0_20px_rgba(37,99,235,0.5)] flex items-center gap-2 font-bold text-xl tracking-wider min-w-[160px] justify-center border-b-4 border-blue-800 active:border-b-0 active:translate-y-1">
                        <span class="material-icons">play_arrow</span> EXECUTE
                    </button>
                </div>
            </div>
        </div>

        <!-- MODAL -->
        <div id="modal-overlay" class="absolute inset-0 bg-slate-900/95 z-50 flex items-center justify-center hidden">
            <div class="modal-enter max-w-md w-full mx-4 bg-slate-800 border border-slate-700 p-8 rounded-2xl shadow-2xl text-center relative overflow-hidden">
                <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-blue-500 to-transparent"></div>
                <h2 id="modal-title" class="stencil text-5xl text-white mb-2 uppercase drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">BRIEFING</h2>
                <div class="w-16 h-1 bg-blue-500 mx-auto mb-6"></div>
                <p id="modal-desc" class="text-lg text-slate-300 mb-8 leading-relaxed font-light"></p>
                <button id="modal-btn" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded-xl text-xl tracking-widest uppercase transition-all shadow-lg hover:shadow-blue-500/25">
                    Compris
                </button>
            </div>
        </div>
    </div>

    <script>
        /**
         * GILETTE TAKEDOWN V3 - REMASTERED (FIXED)
         * - Fixed collision geometry in levels
         * - Smoother path drawing logic
         * - Fixed unplayable input bugs
         */

        // --- UTILS & MATH ---
        const Vec2 = (x, y) => ({x, y});
        const Dist = (v1, v2) => Math.hypot(v2.x - v1.x, v2.y - v1.y);
        const AngleTo = (v1, v2) => Math.atan2(v2.y - v1.y, v2.x - v1.x);
        const Lerp = (a, b, t) => a + (b - a) * t;
        const LerpAngle = (a, b, t) => {
            let d = b - a;
            while (d > Math.PI) d -= 2*Math.PI;
            while (d < -Math.PI) d += 2*Math.PI;
            return a + d * t;
        };
        // Line-Line Intersection
        const Intersect = (p1, p2, p3, p4) => {
            const d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
            if (d === 0) return null;
            const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;
            const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) return { x: p1.x + ua * (p2.x - p1.x), y: p1.y + ua * (p2.y - p1.y) };
            return null;
        };

        // --- CONFIG ---
        const CFG = {
            colors: {
                wall: '#1e293b', floor: '#0f172a', op: '#3b82f6', enemy: '#ef4444', hostage: '#10b981',
                grid: 'rgba(59, 130, 246, 0.05)'
            },
            op: { speed: 2.5, rad: 16, view: 350, fov: Math.PI / 1.8 },
            enemy: { speed: 1.2, rad: 16, view: 280, fov: Math.PI / 2.2 },
            w: 0, h: 0 // set on resize
        };

        // --- ENGINE CLASSES ---

        class Camera {
            constructor() { this.x = 0; this.y = 0; this.shake = 0; }
            addShake(amount) { this.shake = Math.min(this.shake + amount, 20); }
            update() {
                if(this.shake > 0) {
                    this.x = (Math.random() - 0.5) * this.shake;
                    this.y = (Math.random() - 0.5) * this.shake;
                    this.shake *= 0.9;
                    if(this.shake < 0.5) this.shake = 0;
                } else { this.x = 0; this.y = 0; }
            }
        }

        class Particle {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.life = 1.0;
                const speed = type === 'blood' ? 2 : (type === 'spark' ? 6 : 1);
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * Math.random() * speed;
                this.vy = Math.sin(angle) * Math.random() * speed;
                this.size = Math.random() * 3 + 1;
                this.decay = Math.random() * 0.03 + 0.02;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= this.decay;
                if(this.type === 'blood') { this.vx *= 0.8; this.vy *= 0.8; } // Blood splatters stick
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.type === 'blood' ? '#991b1b' : (this.type === 'spark' ? '#fbbf24' : '#ffffff');
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class Door {
            constructor(x, y, w, vertical) {
                this.x = x; this.y = y; this.w = w; this.vertical = vertical;
                this.open = false; this.progress = 0;
            }
            get center() { return this.vertical ? {x: this.x, y: this.y + this.w/2} : {x: this.x + this.w/2, y: this.y}; }
            update() {
                if(this.open && this.progress < 1) this.progress += 0.1;
                else if(!this.open && this.progress > 0) this.progress -= 0.1;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                if(this.vertical) {
                    ctx.translate(0, this.open ? 0 : 0); // Pivot logic
                    ctx.rotate(this.progress * -Math.PI/2.2);
                    ctx.fillStyle = '#b45309'; ctx.fillRect(-2, 0, 4, this.w);
                    ctx.fillStyle = '#451a03'; ctx.fillRect(-1, 2, 2, this.w-4);
                } else {
                    ctx.rotate(this.progress * -Math.PI/2.2);
                    ctx.fillStyle = '#b45309'; ctx.fillRect(0, -2, this.w, 4);
                    ctx.fillStyle = '#451a03'; ctx.fillRect(2, -1, this.w-4, 2);
                }
                ctx.restore();
            }
        }

        class Entity {
            constructor(x, y, team) {
                this.pos = Vec2(x, y); this.team = team;
                this.active = true; this.angle = 0; this.hp = 100;
                this.flashTimer = 0;
            }
            hit(dmg, sourcePos) {
                this.hp -= dmg;
                Game.spawnParticles(this.pos.x, this.pos.y, 5, 'blood');
                if(this.hp <= 0) {
                    this.active = false;
                    // Leave body
                    Game.corpses.push({x: this.pos.x, y: this.pos.y, angle: this.angle, team: this.team});
                }
            }
        }

        class Operator extends Entity {
            constructor(x, y) {
                super(x, y, 'blue');
                this.path = []; this.pathIdx = 0;
                this.mag = 30; this.reloadTimer = 0; this.cooldown = 0;
            }
            update() {
                if(!this.active) return;
                
                // Movement
                if(Game.state === 'RUNNING' && this.path.length > 0 && this.pathIdx < this.path.length) {
                    let target = this.path[this.pathIdx];
                    let d = Dist(this.pos, target);
                    let angle = AngleTo(this.pos, target);
                    this.angle = LerpAngle(this.angle, angle, 0.2);
                    
                    if(d < CFG.op.speed) {
                        this.pos = target; this.pathIdx++;
                    } else {
                        this.pos.x += Math.cos(angle) * CFG.op.speed;
                        this.pos.y += Math.sin(angle) * CFG.op.speed;
                    }
                }

                // Combat
                this.cooldown--; this.reloadTimer--;
                if(this.mag <= 0 && this.reloadTimer <= 0) { this.mag = 30; this.reloadTimer = 120; }
                if(this.reloadTimer > 0) return;

                // Auto-Target
                let targets = Game.enemies.filter(e => e.active);
                let bestT = null; let minD = Infinity;

                for(let t of targets) {
                    if(Dist(this.pos, t.pos) < CFG.op.view && Game.checkLOS(this.pos, t.pos)) {
                        let aToT = AngleTo(this.pos, t.pos);
                        let diff = Math.abs(LerpAngle(0, aToT - this.angle, 1)); // Normalized diff
                        if(diff < CFG.op.fov/2) {
                            if(Dist(this.pos, t.pos) < minD) { minD = Dist(this.pos, t.pos); bestT = t; }
                        }
                    }
                }

                if(bestT) {
                    this.angle = AngleTo(this.pos, bestT.pos);
                    if(this.cooldown <= 0 && this.mag > 0) {
                        Game.shoot(this, bestT);
                        this.cooldown = 8; this.mag--;
                    }
                }
            }
            draw(ctx) {
                if(!this.active) return;
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                // Selection Circle
                if(this === Game.selected) {
                    ctx.beginPath(); ctx.strokeStyle = '#fbbf24'; ctx.lineWidth=2;
                    ctx.arc(0,0, 22, 0, Math.PI*2); ctx.stroke();
                }
                ctx.rotate(this.angle);
                // Body
                ctx.fillStyle = CFG.colors.op;
                ctx.beginPath(); ctx.arc(0,0, CFG.op.rad, 0, Math.PI*2); ctx.fill();
                // Arms/Gun
                ctx.fillStyle = '#1e293b'; ctx.fillRect(0, -6, 24, 12);
                ctx.restore();
            }
        }

        class Enemy extends Entity {
            constructor(x, y, patrol) {
                super(x, y, 'red');
                this.patrol = patrol; this.pIdx = 0;
                this.state = 'PATROL'; // PATROL, ALERT, COMBAT, STUNNED
                this.stunTimer = 0; this.shootTimer = 0;
                if(patrol.length) this.angle = AngleTo(this.pos, patrol[0]);
            }
            update() {
                if(!this.active || Game.state !== 'RUNNING') return;
                
                if(this.stunTimer > 0) { this.stunTimer--; return; }

                // Check Vision
                let target = null;
                for(let op of Game.ops) {
                    if(op.active && Game.checkLOS(this.pos, op.pos) && Dist(this.pos, op.pos) < CFG.enemy.view) {
                        let a = AngleTo(this.pos, op.pos);
                        let diff = Math.abs(LerpAngle(0, a - this.angle, 1));
                        if(diff < CFG.enemy.fov/2 || this.state === 'ALERT') target = op;
                    }
                }

                if(target) {
                    this.state = 'COMBAT';
                    this.angle = AngleTo(this.pos, target.pos);
                    this.shootTimer--;
                    if(this.shootTimer <= 0) {
                        Game.shoot(this, target);
                        this.shootTimer = 40; // Slower than Ops
                    }
                } else {
                    if(this.state === 'COMBAT') this.state = 'ALERT'; // Lost visual
                    
                    if(this.state === 'PATROL' && this.patrol.length > 0) {
                        let dest = this.patrol[this.pIdx];
                        let d = Dist(this.pos, dest);
                        this.angle = LerpAngle(this.angle, AngleTo(this.pos, dest), 0.1);
                        if(d < 5) this.pIdx = (this.pIdx + 1) % this.patrol.length;
                        else {
                            this.pos.x += Math.cos(this.angle) * CFG.enemy.speed;
                            this.pos.y += Math.sin(this.angle) * CFG.enemy.speed;
                        }
                    }
                }
            }
            draw(ctx) {
                if(!this.active) return;
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = CFG.colors.enemy;
                ctx.beginPath(); ctx.arc(0,0, CFG.enemy.rad, 0, Math.PI*2); ctx.fill();
                // Mask
                ctx.fillStyle = '#000'; ctx.fillRect(4, -5, 8, 10);
                if(this.state === 'COMBAT') {
                    ctx.fillStyle = '#fbbf24'; ctx.font="bold 20px Arial"; ctx.fillText("!", -5, -20);
                } else if (this.stunTimer > 0) {
                    ctx.fillStyle = '#fff'; ctx.font="bold 16px Arial"; ctx.fillText("@@", -8, -20);
                }
                ctx.restore();
            }
        }

        class Hostage extends Entity {
            constructor(x, y) { super(x, y, 'civil'); this.evacuated = false; }
            draw(ctx) {
                if(!this.active || this.evacuated) return;
                ctx.fillStyle = CFG.colors.hostage;
                ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 14, 0, Math.PI*2); ctx.fill();
                // Hands tied
                ctx.fillStyle = '#d1fae5'; ctx.beginPath(); ctx.arc(this.pos.x-8, this.pos.y-8, 5, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(this.pos.x+8, this.pos.y-8, 5, 0, Math.PI*2); ctx.fill();
            }
        }

        // --- GAME SYSTEM ---

        const Game = {
            canvas: document.getElementById('worldCanvas'),
            ctx: document.getElementById('worldCanvas').getContext('2d'),
            uiCanvas: document.getElementById('uiCanvas'),
            uictx: document.getElementById('uiCanvas').getContext('2d'),
            
            state: 'PLANNING',
            levelIdx: 0,
            
            // Entities
            walls: [], doors: [], ops: [], enemies: [], hostages: [], corpses: [], particles: [], bullets: [],
            camera: new Camera(),
            selected: null,
            drag: null,

            levels: [
                {
                    name: "ZONE D'ENTRAÎNEMENT",
                    desc: "Tracez un chemin pour votre opérateur. La porte est fermée : ouvrez-la avant d'entrer ou passez en mode Assaut.",
                    setup: (w, h) => {
                        // FIXED GEOMETRY: Spaced out walls to avoid collision at spawn
                        let cw = w/2;
                        Game.walls = [
                            {x: cw-10, y: 250, w: 20, h: h}, // Central Wall starts lower
                            {x:0, y:250, w:cw-60, h:20},     // Left horiz
                            {x:cw+60, y:250, w:w, h:20}      // Right horiz
                        ];
                        Game.doors = [new Door(cw-60, 250, 60, false)];
                        
                        // Operator spaced away from walls
                        Game.ops = [new Operator(cw, h-100)];
                        Game.enemies = [new Enemy(cw, 100, [Vec2(100,100), Vec2(w-100,100)])];
                        Game.hostages = [];
                    }
                },
                {
                    name: "EXTRACTION VIP",
                    desc: "Plusieurs pièces. Des patrouilles hostiles. Le VIP est retenu à l'arrière. Silence recommandé.",
                    setup: (w, h) => {
                        Game.walls = [
                            {x:300, y:0, w:20, h:h/2}, {x:300, y:h/2+80, w:20, h:h}, // Vertical Split
                            {x:0, y:h/2, w:300, h:20}, {x:320, y:h/3, w:w, h:20} // Horizontals
                        ];
                        Game.doors = [new Door(300, h/2, 80, true), new Door(500, h/3, 80, false)];
                        Game.ops = [new Operator(50, h-50), new Operator(100, h-50)];
                        Game.enemies = [
                            new Enemy(150, 150, []), 
                            new Enemy(w-100, 100, [Vec2(w-100, 100), Vec2(w-100, h-100)]),
                            new Enemy(w-150, h/2+50, [])
                        ];
                        Game.hostages = [new Hostage(w-50, 50)];
                    }
                }
            ],

            init() {
                window.addEventListener('resize', this.resize.bind(this));
                this.resize();
                
                // Input - Unified Handlers
                const tHandler = (e) => this.handleInput(e);
                
                // Add event listeners with passive: false to allow preventing default scroll
                this.canvas.addEventListener('mousedown', tHandler);
                this.canvas.addEventListener('mousemove', tHandler);
                window.addEventListener('mouseup', (e) => { this.drag = null; });
                
                this.canvas.addEventListener('touchstart', tHandler, {passive: false});
                this.canvas.addEventListener('touchmove', tHandler, {passive: false});
                window.addEventListener('touchend', (e) => { this.drag = null; });

                // UI binds
                document.getElementById('btn-execute').onclick = () => this.toggleState();
                document.getElementById('btn-clear').onclick = () => { if(this.state === 'PLANNING') this.ops.forEach(o => o.path = []); };
                document.getElementById('btn-flash').onclick = () => this.useSkill('flash');
                document.getElementById('btn-reload').onclick = () => this.useSkill('reload');

                this.loadLevel(0);
                this.loop();
            },

            resize() {
                CFG.w = window.innerWidth; CFG.h = window.innerHeight;
                this.canvas.width = CFG.w; this.canvas.height = CFG.h;
                this.uiCanvas.width = CFG.w; this.uiCanvas.height = CFG.h;
                if(this.walls.length === 0) this.loadLevel(this.levelIdx); // Reload if empty
            },

            loadLevel(idx) {
                this.levelIdx = idx;
                if(idx >= this.levels.length) { this.showModal("MISSION ACCOMPLIE", "Bon travail, commandant. Retour à la base.", () => location.reload()); return; }
                
                this.walls=[]; this.doors=[]; this.ops=[]; this.enemies=[]; this.hostages=[]; this.corpses=[]; this.bullets=[];
                this.levels[idx].setup(CFG.w, CFG.h);
                
                this.state = 'PLANNING';
                this.updateUIPhase();
                this.showModal(this.levels[idx].name, this.levels[idx].desc, () => document.getElementById('modal-overlay').classList.add('hidden'));
            },

            toggleState() {
                if(this.state === 'PLANNING') { this.state = 'RUNNING'; this.selected = null; }
                else if (this.state === 'RUNNING') { this.state = 'PLANNING'; }
                this.updateUIPhase();
            },

            updateUIPhase() {
                const ind = document.getElementById('phase-indicator');
                const txt = document.getElementById('phase-text');
                const btn = document.getElementById('btn-execute');
                
                if(this.state === 'PLANNING') {
                    ind.className = "flex items-center gap-2 text-xs font-bold text-yellow-400 bg-yellow-900/30 px-2 py-1 rounded border border-yellow-500/30 w-max";
                    txt.innerText = "PLANIFICATION";
                    btn.innerHTML = '<span class="material-icons">play_arrow</span> ASSAUT';
                    btn.className = "btn-tac bg-blue-600 hover:bg-blue-500 text-white px-8 py-3 rounded-lg font-bold text-xl tracking-wider min-w-[160px] flex items-center gap-2 justify-center border-b-4 border-blue-800 active:border-b-0 active:translate-y-1";
                } else {
                    ind.className = "flex items-center gap-2 text-xs font-bold text-red-500 bg-red-900/30 px-2 py-1 rounded border border-red-500/30 w-max animate-pulse";
                    txt.innerText = "EN COURS";
                    btn.innerHTML = '<span class="material-icons">pause</span> PAUSE';
                    btn.className = "btn-tac bg-slate-700 hover:bg-slate-600 text-white px-8 py-3 rounded-lg font-bold text-xl tracking-wider min-w-[160px] flex items-center gap-2 justify-center border-b-4 border-slate-900 active:border-b-0 active:translate-y-1";
                }
                document.getElementById('context-layer').innerHTML = ''; // Clear context
            },

            handleInput(e) {
                if(e.type === 'touchstart' || e.type === 'touchmove') e.preventDefault(); // Prevent scroll
                
                const r = this.canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const pos = Vec2(clientX - r.left, clientY - r.top);

                if(e.type === 'mousedown' || e.type === 'touchstart') {
                    // Selection Logic
                    let clickedOp = this.ops.find(o => Dist(pos, o.pos) < 40); // Increased radius for touch
                    if(clickedOp) {
                        this.selected = clickedOp;
                        this.drag = clickedOp;
                        if(this.state === 'PLANNING') {
                             clickedOp.path = [clickedOp.pos];
                             clickedOp.pathIdx = 0;
                        }
                    } else {
                        // Deselect if clicking empty space
                        // But check buttons context first (handled by UI layer)
                        this.selected = null;
                    }
                    this.updateUnitUI();
                } 
                else if ((e.type === 'mousemove' || e.type === 'touchmove') && this.drag && this.state === 'PLANNING') {
                    // Drawing Logic
                    let last = this.drag.path[this.drag.path.length-1];
                    // Smoother drawing: Reduced distance threshold from 20 to 10
                    if(Dist(pos, last) > 10) {
                        if(this.checkLOS(last, pos)) {
                            this.drag.path.push(pos);
                        }
                    }
                }
            },

            // --- GAMEPLAY LOGIC ---
            checkLOS(p1, p2) {
                // Safety: If start point is inside a wall (bug), allow drawing out
                // But generally prevent drawing THROUGH walls
                for(let w of this.walls) {
                    const edges = [
                        [Vec2(w.x, w.y), Vec2(w.x+w.w, w.y)], [Vec2(w.x+w.w, w.y), Vec2(w.x+w.w, w.y+w.h)],
                        [Vec2(w.x+w.w, w.y+w.h), Vec2(w.x, w.y+w.h)], [Vec2(w.x, w.y+w.h), Vec2(w.x, w.y)]
                    ];
                    for(let edge of edges) if(Intersect(p1, p2, edge[0], edge[1])) return false;
                }
                for(let d of this.doors) {
                    if(!d.open) {
                        let dc = d.vertical ? 
                            [Vec2(d.x, d.y), Vec2(d.x, d.y+d.w)] : 
                            [Vec2(d.x, d.y), Vec2(d.x+d.w, d.y)];
                        if(Intersect(p1, p2, dc[0], dc[1])) return false;
                    }
                }
                return true;
            },

            shoot(shooter, target) {
                this.bullets.push({s: {...shooter.pos}, e: {...target.pos}, life: 5});
                this.camera.addShake(3);
                this.spawnParticles(shooter.pos.x + Math.cos(shooter.angle)*20, shooter.pos.y + Math.sin(shooter.angle)*20, 5, 'spark');
                
                // Hit Calc
                let d = Dist(shooter.pos, target.pos);
                let acc = 1 - (d / 400); // Accuracy drops with range
                if(Math.random() < acc) target.hit(35);
                
                // Alert nearby
                this.enemies.forEach(e => {
                    if(Dist(e.pos, shooter.pos) < 300 && e.state === 'PATROL') e.state = 'ALERT';
                });
            },

            spawnParticles(x, y, count, type) {
                for(let i=0; i<count; i++) this.particles.push(new Particle(x, y, type));
            },

            useSkill(type) {
                if(!this.selected || this.state !== 'RUNNING') return;
                const u = this.selected;
                if(type === 'flash') {
                    // Logic: Flashbang at cursor or simple radial stun around unit for demo
                    this.spawnParticles(u.pos.x, u.pos.y, 30, 'spark');
                    this.enemies.forEach(e => {
                        if(Dist(u.pos, e.pos) < 200 && this.checkLOS(u.pos, e.pos)) e.stunTimer = 180;
                    });
                } else if (type === 'reload') {
                    u.mag = 30; u.reloadTimer = 120;
                }
            },

            updateUnitUI() {
                const p = document.getElementById('unit-controls');
                if(this.selected) {
                    p.classList.remove('opacity-0', 'translate-y-10');
                    
                    // Context buttons
                    const ctxLayer = document.getElementById('context-layer');
                    ctxLayer.innerHTML = '';
                    
                    // Check near interactions
                    this.doors.forEach(d => {
                        if(Dist(this.selected.pos, d.center) < 50) {
                            let btn = document.createElement('button');
                            btn.className = "pointer-events-auto bg-slate-800 border border-orange-500 text-orange-500 px-4 py-2 rounded font-bold flex items-center gap-2 animate-bounce";
                            btn.innerHTML = `<span class="material-icons">meeting_room</span> ${d.open ? 'FERMER' : 'OUVRIR'}`;
                            btn.onclick = () => d.open = !d.open;
                            ctxLayer.appendChild(btn);
                        }
                    });
                    this.hostages.forEach(h => {
                         if(!h.evacuated && Dist(this.selected.pos, h.pos) < 50) {
                            let btn = document.createElement('button');
                            btn.className = "pointer-events-auto bg-green-600 text-white px-4 py-2 rounded font-bold flex items-center gap-2";
                            btn.innerHTML = `<span class="material-icons">accessibility_new</span> ÉVACUER`;
                            btn.onclick = () => { h.evacuated = true; this.updateStats(); };
                            ctxLayer.appendChild(btn);
                         }
                    });

                } else {
                    p.classList.add('opacity-0', 'translate-y-10');
                    document.getElementById('context-layer').innerHTML = '';
                }
            },

            updateStats() {
                document.getElementById('hud-hostiles').innerText = this.enemies.filter(e => e.active).length;
                document.getElementById('hud-civils').innerText = this.hostages.filter(h => !h.evacuated).length;
                
                // Check Win/Loss
                if(this.state === 'RUNNING') {
                    if(this.enemies.filter(e=>e.active).length === 0 && this.hostages.filter(h=>!h.evacuated).length === 0) {
                        setTimeout(() => this.loadLevel(this.levelIdx+1), 2000);
                    }
                    if(this.ops.filter(o=>o.active).length === 0) {
                        setTimeout(() => this.loadLevel(this.levelIdx), 2000);
                    }
                }
            },

            showModal(t, d, cb) {
                document.getElementById('modal-title').innerText = t;
                document.getElementById('modal-desc').innerText = d;
                const btn = document.getElementById('modal-btn');
                btn.onclick = cb;
                document.getElementById('modal-overlay').classList.remove('hidden');
            },

            // --- RENDER LOOP ---
            loop() {
                this.camera.update();
                
                // Logic
                this.doors.forEach(d => d.update());
                this.ops.forEach(o => o.update());
                this.enemies.forEach(e => e.update());
                this.particles.forEach((p, i) => { p.update(); if(p.life<=0) this.particles.splice(i,1); });
                this.bullets.forEach((b, i) => { b.life--; if(b.life<=0) this.bullets.splice(i,1); });

                this.updateStats();

                // DRAW WORLD
                const ctx = this.ctx;
                ctx.save();
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0,0,CFG.w, CFG.h);
                
                // Camera Shake apply
                ctx.translate(this.camera.x, this.camera.y);

                // Grid Floor
                ctx.strokeStyle = CFG.colors.grid; ctx.lineWidth = 1;
                ctx.beginPath();
                for(let x=0; x<CFG.w; x+=40) { ctx.moveTo(x,0); ctx.lineTo(x,CFG.h); }
                for(let y=0; y<CFG.h; y+=40) { ctx.moveTo(0,y); ctx.lineTo(CFG.w,y); }
                ctx.stroke();

                // Dead bodies
                this.corpses.forEach(c => {
                    ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(c.angle);
                    ctx.fillStyle = '#334155'; ctx.beginPath(); ctx.arc(0,0,14,0,Math.PI*2); ctx.fill();
                    // Blood pool
                    ctx.fillStyle = '#450a0a'; ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
                    ctx.restore();
                });

                // Paths (Planning)
                if(this.state === 'PLANNING' || this.selected) {
                    this.ops.forEach(o => {
                        if(o.path.length) {
                            ctx.beginPath();
                            ctx.strokeStyle = (o === this.selected) ? '#fbbf24' : 'rgba(59, 130, 246, 0.4)';
                            ctx.lineWidth = 2; ctx.setLineDash([5,5]);
                            ctx.moveTo(o.pos.x, o.pos.y);
                            for(let p of o.path) ctx.lineTo(p.x, p.y);
                            ctx.stroke(); ctx.setLineDash([]);
                            // Waypoints
                            ctx.fillStyle = ctx.strokeStyle;
                            for(let p of o.path) { ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); }
                        }
                    });
                    
                    // Input Feedback Circle
                    if(this.drag && this.drag.path.length > 0) {
                        let last = this.drag.path[this.drag.path.length-1];
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                        ctx.beginPath(); ctx.arc(last.x, last.y, 8, 0, Math.PI*2); ctx.stroke();
                    }
                }

                // Entities
                this.hostages.forEach(h => h.draw(ctx));
                this.ops.forEach(o => o.draw(ctx));
                this.enemies.forEach(e => e.draw(ctx));

                // Particles & Bullets
                this.particles.forEach(p => p.draw(ctx));
                this.bullets.forEach(b => {
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(b.s.x, b.s.y); ctx.lineTo(b.e.x, b.e.y); ctx.stroke();
                });

                // FOG OF WAR / SHADOWS (The "Pro" Look)
                // Draw darkness everywhere
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(-10, -10, CFG.w+20, CFG.h+20);
                
                // Cut out vision cones
                ctx.globalCompositeOperation = 'destination-out';
                
                // Operator Vision
                this.ops.forEach(o => {
                    if(!o.active) return;
                    ctx.save(); ctx.translate(o.pos.x, o.pos.y); ctx.rotate(o.angle);
                    
                    // Main cone
                    ctx.beginPath(); ctx.moveTo(0,0);
                    ctx.arc(0,0, CFG.op.view, -CFG.op.fov/2, CFG.op.fov/2);
                    ctx.closePath(); ctx.fill();
                    
                    // Small radius around unit
                    ctx.beginPath(); ctx.arc(0,0, 60, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                });
                
                ctx.restore();

                // Walls & Doors (On top of shadows for clarity, or below for realism. Top is better for gameplay)
                ctx.shadowColor = 'black'; ctx.shadowBlur = 10;
                this.walls.forEach(w => {
                    ctx.fillStyle = '#1e293b'; ctx.fillRect(w.x, w.y, w.w, w.h);
                    ctx.strokeStyle = '#334155'; ctx.strokeRect(w.x, w.y, w.w, w.h);
                });
                this.doors.forEach(d => d.draw(ctx));
                ctx.shadowBlur = 0;

                ctx.restore();
                
                // UI Canvas Draw (Selection reticles etc)
                // ... (Separated for cleaner rendering if needed)

                requestAnimationFrame(() => this.loop());
            }
        };

        // Boot
        Game.init();

    </script>
</body>
</html>
