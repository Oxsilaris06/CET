<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gilette Takedown V2 - Advanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Saira+Stencil+One&family=Oswald:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        /* --- GLOBAL & UI --- */
        body {
            background-color: #0f172a;
            color: #e2e8f0;
            font-family: 'Oswald', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #1e293b;
            background-image: 
                linear-gradient(rgba(51, 65, 85, 0.5) 1px, transparent 1px),
                linear-gradient(90deg, rgba(51, 65, 85, 0.5) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        canvas { display: block; touch-action: none; }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 10px;
        }
        
        .interactive { pointer-events: auto; }
        .stencil { font-family: 'Saira Stencil One', cursive; }
        
        .crt-overlay {
            position: absolute; inset: 0; pointer-events: none; z-index: 20;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
        }

        /* Action Buttons */
        .action-btn {
            background: rgba(30, 41, 59, 0.9);
            border: 2px solid #475569;
            color: white;
            border-radius: 50%;
            width: 60px; height: 60px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            transition: all 0.2s;
            position: relative;
        }
        .action-btn:active { transform: scale(0.9); }
        .action-btn.primary { border-color: #3b82f6; color: #3b82f6; background: rgba(59, 130, 246, 0.15); }
        .action-btn.danger { border-color: #ef4444; color: #ef4444; background: rgba(239, 68, 68, 0.15); }
        .action-btn.warning { border-color: #eab308; color: #eab308; background: rgba(234, 179, 8, 0.15); }
        
        .cooldown-overlay {
            position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(0,0,0,0.5);
            border-radius: 50%; transition: height 0.1s;
        }

        /* Modal */
        #modal-screen {
            position: absolute; inset: 0; background: rgba(15, 23, 42, 0.98); z-index: 50;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.3s;
        }
        .hidden-modal { opacity: 0; pointer-events: none; }

        .context-menu {
            position: absolute;
            bottom: 90px; right: 20px; /* Position fixe mobile friendly */
            display: flex; flex-direction: column; gap: 10px;
            align-items: flex-end;
            pointer-events: none;
        }
        .context-btn {
            pointer-events: auto;
            opacity: 0; transform: translateY(20px); transition: all 0.3s;
            background: #0f172a; color: white; padding: 10px 20px; border-radius: 8px;
            border: 1px solid #334155; font-weight: bold;
            display: flex; align-items: center; gap: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .context-btn.visible { opacity: 1; transform: translateY(0); }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="crt-overlay"></div>

        <!-- UI LAYER -->
        <div class="ui-layer">
            <!-- Top Info -->
            <div class="flex justify-between items-start w-full pointer-events-none">
                <div class="flex flex-col gap-1">
                    <div class="bg-slate-900/90 border border-slate-700 px-3 py-1 rounded text-blue-500 stencil text-lg shadow-lg">
                        GILETTE TAKEDOWN
                    </div>
                    <div id="status-badge" class="bg-yellow-500/20 border border-yellow-500/50 px-2 py-1 rounded text-yellow-400 text-xs font-bold text-center shadow-lg">
                        PLANIFICATION
                    </div>
                </div>
                <div class="flex gap-2">
                    <div class="bg-slate-900/90 border border-slate-700 px-3 py-1 rounded text-center shadow-lg">
                        <div class="text-[10px] text-slate-400">HOSTILES</div>
                        <div id="ui-hostiles" class="text-red-500 font-bold text-xl leading-none">0</div>
                    </div>
                    <div class="bg-slate-900/90 border border-slate-700 px-3 py-1 rounded text-center shadow-lg">
                        <div class="text-[10px] text-slate-400">CIVILS</div>
                        <div id="ui-civils" class="text-green-500 font-bold text-xl leading-none">0</div>
                    </div>
                </div>
            </div>

            <!-- Contextual Actions (Floating Right) -->
            <div class="context-menu" id="context-menu">
                <button id="btn-evac" class="context-btn bg-green-600 border-green-400">
                    <span class="material-icons">accessibility_new</span> ÉVACUER CIVIL
                </button>
                <button id="btn-breach" class="context-btn bg-orange-600 border-orange-400">
                    <span class="material-icons">meeting_room</span> OUVRIR PORTE
                </button>
            </div>

            <!-- Bottom Controls -->
            <div class="w-full flex flex-col gap-2 interactive mt-auto">
                
                <!-- Selected Unit Actions -->
                <div id="unit-actions" class="flex justify-center gap-4 mb-2 transition-all duration-300 opacity-0 translate-y-10">
                    <div class="flex flex-col items-center">
                        <button id="btn-grenade" class="action-btn warning">
                            <span class="material-icons">flash_on</span>
                            <div class="coherence-overlay" id="cd-grenade" style="height:0%"></div>
                        </button>
                        <span class="text-[10px] text-slate-300 bg-slate-900 px-1 rounded mt-1">FLASHBANG</span>
                    </div>
                    <div class="flex flex-col items-center">
                        <button id="btn-reload" class="action-btn primary">
                            <span class="material-icons">refresh</span>
                        </button>
                        <span class="text-[10px] text-slate-300 bg-slate-900 px-1 rounded mt-1">RECHARGER</span>
                    </div>
                </div>

                <!-- Main Bar -->
                <div class="flex justify-between items-center bg-slate-900/80 p-2 rounded-xl border border-slate-700 backdrop-blur-md">
                    <button id="btn-reset" class="p-3 text-slate-400 hover:text-white transition" title="Reset Level">
                        <span class="material-icons">restart_alt</span>
                    </button>

                    <div class="flex gap-4">
                        <button id="btn-clear" class="text-slate-400 text-xs uppercase font-bold tracking-wider hover:text-white transition px-2">
                            EFFACER TRACÉS
                        </button>
                        <button id="btn-action" class="bg-blue-600 hover:bg-blue-500 text-white px-8 py-3 rounded-lg shadow-lg font-bold stencil text-xl tracking-widest active:scale-95 transition border-b-4 border-blue-800 active:border-b-0 active:translate-y-1 flex items-center gap-2">
                            <span class="material-icons" id="icon-action">play_arrow</span>
                            <span id="text-action">ACTION</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal -->
        <div id="modal-screen">
            <div class="relative w-full max-w-md p-6 text-center">
                <img src="android-icon-192x192.png" class="w-20 h-20 mx-auto mb-4 opacity-90 drop-shadow-[0_0_10px_rgba(59,130,246,0.5)]">
                <h2 id="modal-title" class="stencil text-4xl text-white mb-2 tracking-widest">BRIEFING</h2>
                <div id="modal-content" class="text-gray-300 mb-8 text-sm bg-slate-800/50 p-4 rounded border border-slate-700"></div>
                <button id="btn-modal-action" class="bg-blue-600 hover:bg-blue-500 text-white w-full py-4 rounded text-xl font-bold stencil tracking-widest shadow-lg border-t border-blue-400">
                    LANCER
                </button>
            </div>
        </div>
    </div>

    <script>
        const CANVAS = document.getElementById('gameCanvas');
        const CTX = CANVAS.getContext('2d');
        const ICON_IMG = new Image();
        ICON_IMG.src = 'android-icon-192x192.png';

        const STATES = { PLANNING: 0, RUNNING: 1, PAUSED: 2, ENDED: 3 };
        let appState = STATES.PLANNING;

        const CFG = {
            opSpeed: 2.0,
            opRadius: 18,
            opViewDist: 280,
            opFov: Math.PI / 2.2,
            enemySpeed: 1.0,
            enemyRadius: 18,
            enemyViewDist: 220,
            enemyFov: Math.PI / 2.5,
            bulletSpeed: 15,
            fireRate: 20
        };

        let currentLevel = 0;
        let entities = [];
        let walls = [];
        let doors = [];
        let particles = [];
        let bullets = [];
        let activeDrag = null;
        let selectedUnit = null;
        let frameCount = 0;

        // --- VECTORS ---
        const Vec2 = (x, y) => ({x, y});
        const dist = (v1, v2) => Math.hypot(v2.x - v1.x, v2.y - v1.y);
        const angleTo = (v1, v2) => Math.atan2(v2.y - v1.y, v2.x - v1.x);

        // --- PHYSICS ---
        function lineIntersect(p1, p2, p3, p4) {
            const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
            if (denom === 0) return null;
            const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;
            const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                return { x: p1.x + ua * (p2.x - p1.x), y: p1.y + ua * (p2.y - p1.y) };
            }
            return null;
        }

        function checkLineOfSight(start, end) {
            if (dist(start, end) > CFG.opViewDist * 1.2) return false;
            // Check Walls
            for (let w of walls) {
                const lines = [
                    [Vec2(w.x, w.y), Vec2(w.x + w.w, w.y)],
                    [Vec2(w.x + w.w, w.y), Vec2(w.x + w.w, w.y + w.h)],
                    [Vec2(w.x + w.w, w.y + w.h), Vec2(w.x, w.y + w.h)],
                    [Vec2(w.x, w.y + w.h), Vec2(w.x, w.y)]
                ];
                for (let l of lines) if (lineIntersect(start, end, l[0], l[1])) return false;
            }
            // Check Doors
            for (let d of doors) {
                if (!d.open) {
                    // Simplified door collision (line segment)
                    let p1 = d.vertical ? Vec2(d.x, d.y) : Vec2(d.x, d.y);
                    let p2 = d.vertical ? Vec2(d.x, d.y + d.size) : Vec2(d.x + d.size, d.y);
                    if (lineIntersect(start, end, p1, p2)) return false;
                }
            }
            return true;
        }

        // --- CLASSES ---

        class Door {
            constructor(x, y, size, vertical) {
                this.x = x; this.y = y;
                this.size = size;
                this.vertical = vertical;
                this.open = false;
                this.id = Math.random().toString(36).substr(2, 9);
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                if (this.open) {
                    // Opened door visual
                    if (this.vertical) ctx.rotate(-Math.PI/2.5);
                    else ctx.rotate(-Math.PI/2.5);
                }
                ctx.fillStyle = this.open ? '#475569' : '#b45309'; // Brown closed, Gray open
                ctx.fillRect(0, 0, this.vertical ? 6 : this.size, this.vertical ? this.size : 6);
                ctx.strokeStyle = '#fcd34d';
                ctx.strokeRect(0, 0, this.vertical ? 6 : this.size, this.vertical ? this.size : 6);
                ctx.restore();
            }
            interact() {
                this.open = !this.open;
                // Noise triggers enemies
                if(this.open) alertEnemies(Vec2(this.x, this.y), 400);
            }
        }

        class Entity {
            constructor(x, y, team) {
                this.pos = Vec2(x, y);
                this.team = team; 
                this.angle = 0;
                this.active = true;
                this.hp = 100;
                this.radius = CFG.opRadius;
            }
            hit(dmg, angle) {
                this.hp -= dmg;
                spawnParticles(this.pos.x, this.pos.y, 8, 'blood', angle);
                if (this.hp <= 0) {
                    this.active = false;
                    this.hp = 0;
                    if (this.team === 'red') updateUI();
                }
            }
        }

        class Operator extends Entity {
            constructor(x, y) {
                super(x, y, 'blue');
                this.path = [];
                this.pathIdx = 0;
                this.mag = 30;
                this.reloading = 0;
                this.grenades = 2;
                this.cooldown = 0;
            }

            update() {
                if (!this.active) return;
                
                // Reload Logic
                if (this.reloading > 0) {
                    this.reloading--;
                    if (this.reloading === 0) this.mag = 30;
                    return; // No move/shoot while reloading
                }

                if (appState === STATES.RUNNING) {
                    // Movement
                    if (this.path.length > 0 && this.pathIdx < this.path.length) {
                        let target = this.path[this.pathIdx];
                        let d = dist(this.pos, target);
                        let moveAngle = angleTo(this.pos, target);
                        this.angle = lerpAngle(this.angle, moveAngle, 0.15);

                        if (d < CFG.opSpeed) {
                            this.pos = target;
                            this.pathIdx++;
                        } else {
                            this.pos.x += Math.cos(moveAngle) * CFG.opSpeed;
                            this.pos.y += Math.sin(moveAngle) * CFG.opSpeed;
                        }
                        
                        // Stop if door closed in front
                        for (let door of doors) {
                             if (!door.open && dist(this.pos, Vec2(door.x, door.y)) < 40) {
                                 // Simple check: pause movement if very close to closed door
                                 // Allow player to open it
                             }
                        }
                    }

                    // Combat
                    this.cooldown--;
                    if (this.mag <= 0 && this.reloading === 0) this.reload();

                    let enemies = entities.filter(e => e.team === 'red' && e.active);
                    let target = null;
                    let minDist = Infinity;

                    for (let e of enemies) {
                        if (checkLineOfSight(this.pos, e.pos)) {
                            let ang = angleTo(this.pos, e.pos);
                            let diff = Math.abs(normalizeAngle(ang - this.angle));
                            if (diff < CFG.opFov / 2 && dist(this.pos, e.pos) < minDist) {
                                minDist = dist(this.pos, e.pos);
                                target = e;
                            }
                        }
                    }

                    if (target) {
                        this.angle = angleTo(this.pos, target.pos); // Snap aim
                        if (this.cooldown <= 0 && this.mag > 0) {
                            shoot(this, target);
                            this.cooldown = CFG.fireRate;
                            this.mag--;
                        }
                    }
                }
            }

            draw(ctx) {
                // Path
                if (this.path.length > 0 && this.active) {
                    ctx.strokeStyle = (this === selectedUnit) ? '#fbbf24' : 'rgba(59, 130, 246, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x, this.pos.y);
                    let start = (appState === STATES.PLANNING || appState === STATES.PAUSED) ? 0 : this.pathIdx;
                    for(let i=start; i<this.path.length; i++) ctx.lineTo(this.path[i].x, this.path[i].y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    if(this.path.length > 0) {
                        let end = this.path[this.path.length-1];
                        ctx.fillStyle = (this === selectedUnit) ? '#fbbf24' : '#3b82f6';
                        ctx.beginPath(); ctx.arc(end.x, end.y, 4, 0, Math.PI*2); ctx.fill();
                    }
                }

                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                
                // Selection Halo
                if (this === selectedUnit) {
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0,0, this.radius + 5, 0, Math.PI*2); ctx.stroke();
                }

                if (!this.active) {
                    ctx.rotate(this.angle);
                    ctx.fillStyle = '#334155';
                    ctx.beginPath(); ctx.arc(0,0, this.radius, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(-10,-10); ctx.lineTo(10,10); ctx.moveTo(10,-10); ctx.lineTo(-10,10); ctx.stroke();
                } else {
                    // Reloading indicator
                    if (this.reloading > 0) {
                        ctx.fillStyle = 'rgba(0,0,0,0.5)';
                        ctx.fillRect(-20, -35, 40, 6);
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillRect(-20, -35, 40 * (1 - this.reloading/120), 6);
                    }

                    ctx.rotate(this.angle);
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.15)';
                    ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, this.viewRange, -CFG.opFov/2, CFG.opFov/2); ctx.fill();

                    ctx.rotate(Math.PI/2);
                    try { ctx.drawImage(ICON_IMG, -this.radius, -this.radius, this.radius*2, this.radius*2); } 
                    catch(e) { ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(0,0, this.radius, 0, Math.PI*2); ctx.fill(); }
                }
                ctx.restore();
            }

            reload() {
                if (this.reloading === 0) this.reloading = 120; // 2s @ 60fps
            }
            
            throwGrenade(targetPos) {
                if (this.grenades > 0) {
                    this.grenades--;
                    // Visual FX + Stun logic
                    spawnParticles(targetPos.x, targetPos.y, 20, 'flashbang');
                    // Stun enemies in range
                    entities.forEach(e => {
                        if (e.team === 'red' && e.active && dist(e.pos, targetPos) < 150) {
                            e.cooldown = 180; // 3s stun
                            e.state = 'ALERT'; // Alerted but stunned
                        }
                    });
                    return true;
                }
                return false;
            }
        }

        class Enemy extends Entity {
            constructor(x, y, patrolPoints = []) {
                super(x, y, 'red');
                this.patrolPoints = patrolPoints;
                this.patrolIdx = 0;
                this.state = 'PATROL'; 
                this.alertTimer = 0;
                this.cooldown = 0;
                this.angle = patrolPoints.length > 0 ? angleTo(this.pos, patrolPoints[0]) : Math.random() * Math.PI * 2;
            }
            update() {
                if (!this.active || appState !== STATES.RUNNING) return;
                
                // Stunned?
                if (this.cooldown > 0 && this.state !== 'COMBAT') {
                    this.cooldown--;
                    return; 
                }

                // Vision Check
                let target = null;
                let operators = entities.filter(e => e.team === 'blue' && e.active);
                for (let op of operators) {
                    if (checkLineOfSight(this.pos, op.pos)) {
                        let ang = angleTo(this.pos, op.pos);
                        let diff = Math.abs(normalizeAngle(ang - this.angle));
                        let currentFov = (this.state === 'ALERT') ? Math.PI : CFG.enemyFov;
                        if (diff < currentFov / 2 && dist(this.pos, op.pos) < CFG.enemyViewDist) {
                            target = op;
                        }
                    }
                }

                if (target) {
                    this.state = 'COMBAT';
                    this.angle = angleTo(this.pos, target.pos);
                    this.cooldown--;
                    if (this.cooldown <= 0) {
                        shoot(this, target);
                        this.cooldown = CFG.fireRate * 1.5;
                    }
                } else {
                     if (this.state === 'COMBAT') {
                        this.state = 'ALERT';
                        this.alertTimer = 120;
                    } else if (this.state === 'ALERT') {
                        this.alertTimer--;
                        this.angle += 0.05; // Scan
                        if (this.alertTimer <= 0) this.state = 'PATROL';
                    } else if (this.patrolPoints.length > 0) {
                        let dest = this.patrolPoints[this.patrolIdx];
                        if (dist(this.pos, dest) < 5) this.patrolIdx = (this.patrolIdx + 1) % this.patrolPoints.length;
                        else {
                            let ang = angleTo(this.pos, dest);
                            this.angle = lerpAngle(this.angle, ang, 0.1);
                            this.pos.x += Math.cos(ang) * CFG.enemySpeed;
                            this.pos.y += Math.sin(ang) * CFG.enemySpeed;
                        }
                    }
                }
            }
            draw(ctx) {
                if (!this.active) {
                    ctx.fillStyle = '#450a0a'; ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2); ctx.fill();
                    return;
                }
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);
                
                // Vision
                ctx.fillStyle = this.state === 'COMBAT' ? 'rgba(239, 68, 68, 0.3)' : 'rgba(239, 68, 68, 0.1)';
                let currentFov = (this.state === 'ALERT') ? Math.PI : CFG.enemyFov;
                ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0, CFG.enemyViewDist, -currentFov/2, currentFov/2); ctx.fill();
                
                // Body
                ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(0,0, this.radius, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#1e293b'; ctx.fillRect(0, -4, 25, 8);
                
                if (this.cooldown > 0 && this.state !== 'COMBAT') { // Stunned visual
                     ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText('ZZZ', -10, -25);
                } else if (this.state === 'COMBAT' || this.state === 'ALERT') {
                    ctx.fillStyle = 'yellow'; ctx.font = 'bold 20px Arial'; ctx.fillText('!', -5, -25);
                }
                ctx.restore();
            }
        }

        class Hostage extends Entity {
            constructor(x, y) {
                super(x, y, 'civil');
                this.evacuated = false;
            }
            draw(ctx) {
                if (this.evacuated) return;
                if (!this.active) {
                     ctx.fillStyle = '#14532d'; ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2); ctx.fill();
                     return;
                }
                ctx.fillStyle = '#22c55e'; 
                ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#bbf7d0'; // Hands up
                ctx.beginPath(); ctx.arc(this.pos.x - 12, this.pos.y - 8, 6, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(this.pos.x + 12, this.pos.y - 8, 6, 0, Math.PI*2); ctx.fill();
            }
        }

        // --- FX ---
        function spawnParticles(x, y, count, type, angle = 0) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x, y, type,
                    vx: (Math.random()-0.5)*(type==='flashbang'?15:5),
                    vy: (Math.random()-0.5)*(type==='flashbang'?15:5),
                    life: type === 'flash' ? 2 : (type==='flashbang'?30:40),
                    color: type==='blood'?'#991b1b':(type==='flashbang'?'#ffffff':'#fbbf24'),
                    size: Math.random()*3+1
                });
            }
        }

        function alertEnemies(pos, range) {
             entities.forEach(e => {
                if (e.team === 'red' && e.active && e.state === 'PATROL' && dist(e.pos, pos) < range) {
                    e.state = 'ALERT'; e.alertTimer = 100; e.angle = angleTo(e.pos, pos);
                }
            });
        }
        
        function shoot(shooter, target) {
            spawnParticles(shooter.pos.x + Math.cos(shooter.angle)*20, shooter.pos.y + Math.sin(shooter.angle)*20, 5, 'flash');
            bullets.push({start: {...shooter.pos}, end: {...target.pos}, life: 5});
            
            let d = dist(shooter.pos, target.pos);
            let hitChance = 1 - (d/shooter.viewRange)*0.4;
            if (Math.random() < hitChance) {
                target.hit(35, shooter.angle);
                alertEnemies(target.pos, 400);
            } else {
                spawnParticles(target.pos.x + (Math.random()-0.5)*40, target.pos.y + (Math.random()-0.5)*40, 3, 'dust');
            }
        }

        // --- LEVELS ---
        const LEVELS = [
            {
                name: "INITIATION",
                brief: "Prise en main. Neutralisez la sentinelle et évacuez le VIP.",
                setup: (cw, ch) => {
                    walls = [ {x: cw/2-10, y: 150, w: 20, h: ch}, {x: 0, y: 150, w: cw/2-60, h: 20}, {x: cw/2+60, y: 150, w: cw, h: 20} ];
                    doors = [ new Door(cw/2-60, 150, 60, false) ];
                    entities = [
                        new Operator(cw/2, ch-50),
                        new Enemy(cw/2, 50, [Vec2(cw/2-100, 50), Vec2(cw/2+100, 50)]),
                        new Hostage(100, 50)
                    ];
                }
            },
            {
                name: "DOUBLE IMPACT",
                brief: "Deux pièces. Nettoyez méthodiquement.",
                setup: (cw, ch) => {
                    walls = [ 
                        {x: cw/3, y:0, w:20, h:ch}, 
                        {x: cw*0.66, y:0, w:20, h:ch},
                        {x: 0, y: ch/2, w: cw, h: 20}
                    ];
                    doors = [ 
                        new Door(cw/3, ch/4, 60, true),
                        new Door(cw*0.66, ch*0.75, 60, true)
                    ];
                    entities = [
                        new Operator(50, ch-50),
                        new Operator(cw-50, ch-50),
                        new Enemy(cw/2, ch/4, []),
                        new Enemy(cw/6, 50, [Vec2(cw/6, 50), Vec2(cw/6, ch/2-50)]),
                        new Hostage(cw/2, 50)
                    ];
                }
            }
        ];

        // --- CORE ---
        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            CANVAS.addEventListener('mousedown', onPointerDown);
            CANVAS.addEventListener('mousemove', onPointerMove);
            window.addEventListener('mouseup', onPointerUp);
            CANVAS.addEventListener('touchstart', onPointerDown, {passive: false});
            CANVAS.addEventListener('touchmove', onPointerMove, {passive: false});
            window.addEventListener('touchend', onPointerUp);

            loadLvl(0);
            requestAnimationFrame(loop);
        }

        function resize() { CANVAS.width = window.innerWidth; CANVAS.height = window.innerHeight; }
        
        function loadLvl(i) {
            if (i >= LEVELS.length) { showModal("TERMINÉ", "Bravo !", "REJOUER", () => loadLvl(0)); return; }
            currentLevel = i;
            walls=[]; doors=[]; entities=[]; particles=[]; bullets=[];
            LEVELS[i].setup(CANVAS.width, CANVAS.height);
            setState(STATES.PLANNING);
            showModal(`MISSION ${i+1}`, LEVELS[i].name + "<br>" + LEVELS[i].brief, "GO", () => hideModal());
            updateUI();
        }

        function setState(s) {
            appState = s;
            const badge = document.getElementById('status-badge');
            const btnMain = document.getElementById('btn-action');
            const iconAction = document.getElementById('icon-action');
            const textAction = document.getElementById('text-action');

            if (s === STATES.PLANNING) {
                badge.innerText = "PLANIFICATION"; 
                badge.className = "bg-yellow-500/20 border border-yellow-500/50 px-2 py-1 rounded text-yellow-400 text-xs font-bold text-center shadow-lg";
                btnMain.classList.remove('danger'); 
                btnMain.classList.add('play');
                iconAction.innerText = "play_arrow";
                textAction.innerText = "ACTION";
            } else if (s === STATES.RUNNING) {
                badge.innerText = "ASSAUT"; 
                badge.className = "bg-red-500/20 border border-red-500/50 px-2 py-1 rounded text-red-500 text-xs font-bold text-center shadow-lg animate-pulse";
                btnMain.classList.remove('play');
                btnMain.classList.add('danger');
                iconAction.innerText = "pause";
                textAction.innerText = "PAUSE";
                selectedUnit = null; 
                updateContextUI();
            } else if (s === STATES.PAUSED) {
                badge.innerText = "PAUSE"; 
                badge.className = "bg-blue-500/20 border border-blue-500/50 px-2 py-1 rounded text-blue-400 text-xs font-bold text-center shadow-lg";
                btnMain.classList.remove('danger');
                btnMain.classList.add('play');
                iconAction.innerText = "play_arrow";
                textAction.innerText = "REPRENDRE";
            }
            updateActionUI();
        }

        // --- INPUT ---
        function getPos(e) {
            const r = CANVAS.getBoundingClientRect();
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            return Vec2(x - r.left, y - r.top);
        }

        function onPointerDown(e) {
            if (appState === STATES.ENDED) return;
            e.preventDefault();
            let p = getPos(e);
            let clickedUnit = null;

            // Check Operators
            for (let op of entities.filter(e=>e.team==='blue' && e.active)) {
                if (dist(p, op.pos) < 40) {
                    clickedUnit = op;
                    break;
                }
            }

            // Planning Phase: Drag path
            if (clickedUnit && (appState === STATES.PLANNING || appState === STATES.PAUSED)) {
                selectedUnit = clickedUnit;
                if (appState === STATES.PAUSED) {
                     // Cut path at current pos to redraw future
                     op.path = op.path.slice(0, op.pathIdx);
                     op.path.push({...op.pos});
                } else {
                     clickedUnit.path = [clickedUnit.pos];
                     clickedUnit.pathIdx = 0;
                }
                activeDrag = clickedUnit;
            } 
            // Running Phase: Select only
            else if (clickedUnit && appState === STATES.RUNNING) {
                selectedUnit = clickedUnit;
            }
            // Click empty space: Deselect
            else if (!clickedUnit) {
                selectedUnit = null;
            }
            
            updateActionUI();
            updateContextUI();
        }

        function onPointerMove(e) {
            if (!activeDrag) return;
            e.preventDefault();
            let p = getPos(e);
            let last = activeDrag.path[activeDrag.path.length-1];
            if (dist(p, last) > 15 && !checkWallCollisionLine(last, p)) {
                activeDrag.path.push(p);
            }
        }

        function onPointerUp() { activeDrag = null; }

        // --- UI UPDATES ---
        function updateActionUI() {
            const panel = document.getElementById('unit-actions');
            if (selectedUnit && selectedUnit.team === 'blue') {
                panel.classList.remove('opacity-0', 'translate-y-10');
            } else {
                panel.classList.add('opacity-0', 'translate-y-10');
            }
        }

        function updateContextUI() {
            const btnEvac = document.getElementById('btn-evac');
            const btnBreach = document.getElementById('btn-breach');
            btnEvac.classList.remove('visible');
            btnBreach.classList.remove('visible');

            if (selectedUnit && selectedUnit.active) {
                // Check Hostages
                let nearHostage = entities.some(e => e.team === 'civil' && e.active && !e.evacuated && dist(selectedUnit.pos, e.pos) < 60);
                if (nearHostage) btnEvac.classList.add('visible');

                // Check Doors
                let nearDoor = doors.some(d => dist(selectedUnit.pos, Vec2(d.x + (d.vertical?0:d.size/2), d.y + (d.vertical?d.size/2:0))) < 60);
                if (nearDoor) btnBreach.classList.add('visible');
            }
        }

        // --- GAME LOOP ---
        function loop() {
            // Logic
            if (appState === STATES.RUNNING) {
                entities.forEach(e => e.update());
                // Check Win
                let enemies = entities.filter(e => e.team === 'red' && e.active);
                let hostages = entities.filter(e => e.team === 'civil' && e.active && !e.evacuated);
                let ops = entities.filter(e => e.team === 'blue' && e.active);
                
                if (enemies.length === 0 && hostages.length === 0) {
                    setAppState(STATES.ENDED);
                    setTimeout(()=>showModal("ZONE SÉCURISÉE", "Tous les objectifs atteints.", "NIVEAU SUIVANT", () => loadLvl(currentLevel+1)), 1000);
                } else if (ops.length === 0) {
                    setAppState(STATES.ENDED);
                    setTimeout(()=>showModal("ÉCHEC", "Opérateurs à terre.", "RÉESSAYER", () => loadLvl(currentLevel)), 1000);
                }
                
                // Update real time UI
                if (selectedUnit) updateContextUI();
            }

            // Draw
            CTX.fillStyle = '#1e293b'; CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
            CTX.strokeStyle='rgba(255,255,255,0.05)'; CTX.beginPath();
            for(let i=0; i<CANVAS.width; i+=40){CTX.moveTo(i,0);CTX.lineTo(i,CANVAS.height)}
            for(let i=0; i<CANVAS.height; i+=40){CTX.moveTo(0,i);CTX.lineTo(CANVAS.width,i)}
            CTX.stroke();

            doors.forEach(d => d.draw(CTX));
            CTX.fillStyle='rgba(0,0,0,0.5)'; walls.forEach(w=>CTX.fillRect(w.x+5,w.y+5,w.w,w.h));
            CTX.fillStyle='#0f172a'; CTX.strokeStyle='#64748b'; CTX.lineWidth=3;
            walls.forEach(w=>{CTX.fillRect(w.x,w.y,w.w,w.h); CTX.strokeRect(w.x,w.y,w.w,w.h)});

            entities.forEach(e => e.draw(CTX));
            
            // Particles / Bullets
            bullets.forEach((b,i) => {
                b.life--; CTX.strokeStyle='#fbbf24'; CTX.lineWidth=2; CTX.beginPath(); 
                CTX.moveTo(b.start.x, b.start.y); CTX.lineTo(b.end.x, b.end.y); CTX.stroke();
                if(b.life<=0) bullets.splice(i,1);
            });
            particles.forEach((p,i) => {
                p.life--; p.x+=p.vx; p.y+=p.vy; CTX.globalAlpha=p.life/20; CTX.fillStyle=p.color;
                CTX.beginPath(); CTX.arc(p.x,p.y,p.size,0,Math.PI*2); CTX.fill();
                if(p.life<=0) particles.splice(i,1);
            });
            CTX.globalAlpha=1;

            requestAnimationFrame(loop);
        }

        // --- HELPERS ---
        function lerpAngle(a, b, t) {
            let d = b - a;
            while (d > Math.PI) d -= 2*Math.PI; while (d < -Math.PI) d += 2*Math.PI;
            return a + d * t;
        }
        function normalizeAngle(a) { while (a > Math.PI) a -= 2*Math.PI; while (a < -Math.PI) a += 2*Math.PI; return a; }
        function checkWallCollisionLine(p1, p2) { return false; /* Simplification for brevity, add back if needed */ }
        
        function updateUI() {
            document.getElementById('ui-hostiles').innerText = entities.filter(e=>e.team==='red' && e.active).length;
            document.getElementById('ui-civils').innerText = entities.filter(e=>e.team==='civil' && !e.evacuated).length;
        }

        const modal = document.getElementById('modal-screen');
        function showModal(t, c, b, cb) {
            document.getElementById('modal-title').innerText = t;
            document.getElementById('modal-content').innerHTML = c;
            const btn = document.getElementById('btn-modal-action');
            btn.innerText = b;
            btn.onclick = cb;
            modal.classList.remove('hidden-modal');
        }
        function hideModal() { modal.classList.add('hidden-modal'); }

        // --- BUTTONS ---
        document.getElementById('btn-action').onclick = () => {
            if (appState === STATES.PLANNING || appState === STATES.PAUSED) setState(STATES.RUNNING);
            else if (appState === STATES.RUNNING) setState(STATES.PAUSED);
        };
        document.getElementById('btn-reset').onclick = () => loadLvl(currentLevel);
        document.getElementById('btn-clear').onclick = () => {
            if (appState === STATES.PLANNING) entities.filter(e=>e.team==='blue').forEach(e => { e.path=[]; e.pathIdx=0; });
        };

        // Actions
        document.getElementById('btn-reload').onclick = () => {
            if(selectedUnit) selectedUnit.reload();
        };
        document.getElementById('btn-grenade').onclick = () => {
            if(selectedUnit) {
                // Throw towards looking direction
                let target = {
                    x: selectedUnit.pos.x + Math.cos(selectedUnit.angle)*150,
                    y: selectedUnit.pos.y + Math.sin(selectedUnit.angle)*150
                };
                selectedUnit.throwGrenade(target);
            }
        };
        document.getElementById('btn-evac').onclick = () => {
            if(selectedUnit) {
                entities.forEach(e => {
                    if (e.team === 'civil' && !e.evacuated && dist(selectedUnit.pos, e.pos) < 60) {
                        e.evacuated = true;
                        spawnParticles(e.pos.x, e.pos.y, 20, 'flash'); // Poof effect
                        updateUI();
                    }
                });
                updateContextUI();
            }
        };
        document.getElementById('btn-breach').onclick = () => {
            if(selectedUnit) {
                doors.forEach(d => {
                    if (dist(selectedUnit.pos, Vec2(d.x+(d.vertical?0:d.size/2), d.y+(d.vertical?d.size/2:0))) < 60) {
                        d.interact();
                    }
                });
            }
        };

        init();

    </script>
</body>
</html>
