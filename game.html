<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gilette Takedown: Black Ops Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        :root {
            --ui-color: #3b82f6;
            --danger-color: #ef4444;
            --success-color: #10b981;
            --bg-dark: #0f172a;
        }
        
        body {
            background-color: #000;
            color: #e2e8f0;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }
        
        /* --- CRT & Scanlines Effect --- */
        #game-wrapper {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #0b0f19;
            overflow: hidden;
            display: flex; /* Center canvas */
            align-items: center;
            justify-content: center;
        }

        /* Fixed canvas size constraint for better geometry predictability */
        #worldCanvas, #uiCanvas {
            max-width: 900px; 
            max-height: 900px;
            width: 100%;
            height: 100%;
            display: block;
            margin: auto;
        }

        .scanlines {
            position: absolute; inset: 0; pointer-events: none; z-index: 10;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            animation: scrollLines 10s linear infinite;
        }
        .vignette {
            position: absolute; inset: 0; pointer-events: none; z-index: 11;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
        }

        /* --- UI Elements --- */
        .hud-panel {
            backdrop-filter: blur(4px);
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid rgba(59, 130, 246, 0.3);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        
        .stencil { font-family: 'Black Ops One', cursive; }
        
        .btn-tac {
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .btn-tac:active { transform: scale(0.95); }
        .btn-tac::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 2px;
            background: rgba(255,255,255,0.3);
        }

        /* Animations */
        @keyframes modalPop { from { opacity: 0; transform: scale(0.9) translateY(20px); } to { opacity: 1; transform: scale(1) translateY(0); } }
        .modal-enter { animation: modalPop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }

        /* Cooldown visualization */
        .cooldown-bar {
            position: absolute; inset: 0; background: linear-gradient(to top, rgba(0,0,0,0.8), rgba(0,0,0,0.4));
            transform-origin: bottom; transition: height 0.1s linear;
        }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <!-- Canvas for the world geometry, entities, and shadows -->
        <canvas id="worldCanvas"></canvas> 
        <!-- Canvas for the high-resolution, camera-independent UI overlays (currently unused, keeping for future separation) -->
        <canvas id="uiCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas> 
        
        <div class="scanlines"></div>
        <div class="vignette"></div>

        <!-- MAIN HUD -->
        <div class="absolute inset-0 pointer-events-none p-4 flex flex-col justify-between z-20">
            
            <!-- TOP BAR -->
            <div class="flex justify-between items-start">
                <div class="flex flex-col gap-1">
                    <h1 class="stencil text-3xl text-blue-500 tracking-wider drop-shadow-lg leading-none">TAKEDOWN</h1>
                    <div id="phase-indicator" class="flex items-center gap-2 text-xs font-bold text-yellow-400 bg-yellow-900/30 px-2 py-1 rounded border border-yellow-500/30 w-max">
                        <span class="w-2 h-2 rounded-full bg-yellow-400 animate-pulse"></span>
                        <span id="phase-text">PLANIFICATION</span>
                    </div>
                </div>

                <div class="flex gap-3">
                    <div class="hud-panel px-4 py-2 rounded-lg flex flex-col items-center">
                        <span class="text-[10px] text-slate-400 tracking-widest uppercase">Hostiles</span>
                        <span id="hud-hostiles" class="text-2xl font-bold text-red-500 leading-none">0</span>
                    </div>
                    <div class="hud-panel px-4 py-2 rounded-lg flex flex-col items-center">
                        <span class="text-[10px] text-slate-400 tracking-widest uppercase">Civils</span>
                        <span id="hud-civils" class="text-2xl font-bold text-green-500 leading-none">0</span>
                    </div>
                </div>
            </div>

            <!-- CONTEXT ACTIONS (Right Side) -->
            <div id="context-layer" class="absolute right-4 bottom-32 flex flex-col gap-3 items-end pointer-events-none">
                <!-- Injected via JS (Door/Hostage interactions) -->
            </div>

            <!-- BOTTOM CONTROL BAR -->
            <div class="pointer-events-auto flex flex-col gap-3">
                
                <!-- Unit Specific Controls (Only visible when a unit is selected) -->
                <div id="unit-controls" class="flex justify-center gap-6 transition-all duration-300 opacity-0 translate-y-10">
                    <button id="btn-flash" class="btn-tac group relative w-14 h-14 rounded-xl bg-slate-800 border border-slate-600 flex items-center justify-center hover:bg-slate-700 hover:border-yellow-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                        <span class="material-icons text-yellow-400 group-hover:scale-110 transition-transform">flash_on</span>
                        <div class="absolute -bottom-6 text-[10px] font-bold text-slate-400 bg-slate-900 px-2 py-0.5 rounded">STUN</div>
                        <div id="cd-flash" class="cooldown-bar" style="height:0%"></div>
                    </button>
                    
                    <button id="btn-reload" class="btn-tac group relative w-14 h-14 rounded-xl bg-slate-800 border border-slate-600 flex items-center justify-center hover:bg-slate-700 hover:border-blue-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                        <span class="material-icons text-blue-400 group-hover:rotate-180 transition-transform duration-500">sync</span>
                        <div class="absolute -bottom-6 text-[10px] font-bold text-slate-400 bg-slate-900 px-2 py-0.5 rounded">MAG</div>
                        <div id="cd-reload" class="cooldown-bar" style="height:0%"></div>
                    </button>
                </div>

                <!-- Main Play/Pause -->
                <div class="hud-panel p-2 rounded-xl flex items-center justify-between gap-4">
                    <button onclick="Game.resetLevel()" class="btn-tac p-3 text-slate-400 hover:text-white rounded-lg hover:bg-white/5">
                        <span class="material-icons">restart_alt</span>
                    </button>

                    <div class="flex-1 flex justify-center">
                        <button id="btn-clear" class="btn-tac text-xs font-bold text-slate-400 hover:text-white uppercase tracking-widest px-4 py-2 hover:bg-white/5 rounded">
                            Réinitialiser chemins
                        </button>
                    </div>

                    <button id="btn-execute" class="btn-tac bg-blue-600 hover:bg-blue-500 text-white px-8 py-3 rounded-lg shadow-[0_0_20px_rgba(37,99,235,0.5)] flex items-center gap-2 font-bold text-xl tracking-wider min-w-[160px] justify-center border-b-4 border-blue-800 active:border-b-0 active:translate-y-1">
                        <span class="material-icons">play_arrow</span> ASSAUT
                    </button>
                </div>
            </div>
        </div>

        <!-- MODAL -->
        <div id="modal-overlay" class="absolute inset-0 bg-slate-900/95 z-50 flex items-center justify-center hidden">
            <div class="modal-enter max-w-md w-full mx-4 bg-slate-800 border border-slate-700 p-8 rounded-2xl shadow-2xl text-center relative overflow-hidden">
                <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-blue-500 to-transparent"></div>
                <h2 id="modal-title" class="stencil text-5xl text-white mb-2 uppercase drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">BRIEFING</h2>
                <div class="w-16 h-1 bg-blue-500 mx-auto mb-6"></div>
                <p id="modal-desc" class="text-lg text-slate-300 mb-8 leading-relaxed font-light"></p>
                <button id="modal-btn" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded-xl text-xl tracking-widest uppercase transition-all shadow-lg hover:shadow-blue-500/25">
                    Compris
                </button>
            </div>
        </div>
    </div>

    <script>
        /**
         * GILETTE TAKEDOWN V3 - PROFESSIONAL REMASTER
         * * IMPROVEMENTS (02/12/2025):
         * - Ensured all entity spawns (Operators, Enemies, Hostages) are in safe, non-colliding areas.
         * - Improved map boundary checks in checkCollision.
         * - Retained and refined tactical pathing logic for Operators.
         */

        // --- UTILS & MATH ---
        const Vec2 = (x, y) => ({x, y});
        const Dist = (v1, v2) => Math.hypot(v2.x - v1.x, v2.y - v1.y);
        const AngleTo = (v1, v2) => Math.atan2(v2.y - v1.y, v2.x - v1.x);
        const Lerp = (a, b, t) => a + (b - a) * t;
        const LerpAngle = (a, b, t) => {
            let d = b - a;
            while (d > Math.PI) d -= 2*Math.PI;
            while (d < -Math.PI) d += 2*Math.PI;
            return a + d * t;
        };
        // Line-Line Intersection (Returns point or null)
        const Intersect = (p1, p2, p3, p4) => {
            const d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
            if (d === 0) return null;
            const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;
            const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) return { x: p1.x + ua * (p2.x - p1.x), y: p1.y + ua * (p2.y - p1.y) };
            return null;
        };

        // --- CONFIG ---
        const CFG = {
            colors: {
                wall: '#1e293b', floor: '#0f172a', op: '#3b82f6', enemy: '#ef4444', hostage: '#10b981',
                grid: 'rgba(59, 130, 246, 0.05)', bullet: '#fbbf24'
            },
            op: { speed: 2.5, rad: 16, view: 350, fov: Math.PI / 1.8, reloadTime: 120, flashCD: 300, turnPauseDuration: 15 }, // 15 frames for tactical pause
            enemy: { speed: 1.2, rad: 16, view: 280, fov: Math.PI / 2.2, fireRate: 40 },
            bullet: { speed: 20, damage: 35 },
            w: 0, h: 0, // set on resize
            mapW: 800, mapH: 600 // Fixed map size for consistent geometry
        };

        // --- ENGINE CLASSES ---

        class Camera {
            constructor() { this.x = 0; this.y = 0; this.shake = 0; }
            addShake(amount) { this.shake = Math.min(this.shake + amount, 20); }
            update() {
                if(this.shake > 0) {
                    this.x = (Math.random() - 0.5) * this.shake;
                    this.y = (Math.random() - 0.5) * this.shake;
                    this.shake *= 0.8;
                    if(this.shake < 0.5) this.shake = 0;
                } else { this.x = 0; this.y = 0; }
            }
        }

        class Particle {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.life = 1.0;
                const speed = type === 'blood' ? 2 : (type === 'spark' ? 6 : 1);
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * Math.random() * speed;
                this.vy = Math.sin(angle) * Math.random() * speed;
                this.size = Math.random() * 3 + 1;
                this.decay = Math.random() * 0.03 + 0.02;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= this.decay;
                if(this.type === 'blood') { this.vx *= 0.9; this.vy *= 0.9; }
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.type === 'blood' ? '#991b1b' : (this.type === 'spark' ? CFG.colors.bullet : '#ffffff');
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class Door {
            constructor(x, y, w, vertical) {
                this.x = x; this.y = y; this.w = w; this.vertical = vertical;
                this.open = false; this.progress = 0; // 0 = closed, 1 = open
            }
            get center() { return this.vertical ? {x: this.x, y: this.y + this.w/2} : {x: this.x + this.w/2, y: this.y}; }
            update() {
                const speed = 0.05;
                if(this.open && this.progress < 1) this.progress = Math.min(1, this.progress + speed);
                else if(!this.open && this.progress > 0) this.progress = Math.max(0, this.progress - speed);
            }
            draw(ctx) {
                ctx.save();
                // Find hinge/pivot point
                const pivotX = this.vertical ? this.x : this.x + 2;
                const pivotY = this.vertical ? this.y + 2 : this.y;
                
                ctx.translate(pivotX, pivotY);

                // Rotate around the pivot point
                if(this.progress > 0) {
                    const angle = this.progress * -Math.PI/2.2;
                    if(this.vertical) {
                        ctx.translate(0, -2); // Translate to start of door segment (visual offset)
                        ctx.rotate(angle);
                        ctx.translate(0, 2);
                    } else {
                        ctx.translate(-2, 0);
                        ctx.rotate(angle);
                        ctx.translate(2, 0);
                    }
                }
                
                // Draw the door slab
                ctx.fillStyle = '#b45309'; 
                if(this.vertical) {
                    ctx.fillRect(-3, 0, 6, this.w);
                    ctx.fillStyle = '#451a03'; ctx.fillRect(-1, 2, 2, this.w-4);
                } else {
                    ctx.fillRect(0, -3, this.w, 6);
                    ctx.fillStyle = '#451a03'; ctx.fillRect(2, -1, this.w-4, 2);
                }
                ctx.restore();
            }
        }

        class Entity {
            constructor(x, y, team) {
                this.pos = Vec2(x, y); this.team = team;
                this.active = true; this.angle = 0; this.hp = 100;
                this.flashTimer = 0; this.rad = CFG.op.rad;
            }
            hit(dmg) {
                if(!this.active) return;
                this.hp -= dmg;
                Game.spawnParticles(this.pos.x, this.pos.y, 8, 'blood');
                Game.camera.addShake(1);
                if(this.hp <= 0) {
                    this.active = false;
                    Game.corpses.push({x: this.pos.x, y: this.pos.y, angle: this.angle, team: this.team});
                }
            }
        }

        class Operator extends Entity {
            constructor(x, y) {
                super(x, y, 'blue');
                this.rad = CFG.op.rad;
                this.path = []; this.pathIdx = 0;
                this.mag = 30; this.reloadTimer = 0; this.cooldown = 0;
                this.flashCD = 0;
                this.turnPause = 0; // New: Timer for tactical turning pause
            }
            update() {
                if(!this.active) return;

                // Handle status timers
                this.cooldown = Math.max(0, this.cooldown - 1);
                this.reloadTimer = Math.max(0, this.reloadTimer - 1);
                this.flashCD = Math.max(0, this.flashCD - 1);
                this.turnPause = Math.max(0, this.turnPause - 1);

                if(this.flashTimer > 0) { this.flashTimer--; return; }
                if(Game.state !== 'RUNNING') return;
                
                // Movement
                if(this.path.length > 0 && this.pathIdx < this.path.length) {
                    let target = this.path[this.pathIdx];
                    let d = Dist(this.pos, target);
                    let targetAngle = AngleTo(this.pos, target);
                    let angleDiff = Math.abs(LerpAngle(0, targetAngle - this.angle, 1)); 

                    // Tactical pause logic
                    if (this.turnPause > 0) {
                        this.angle = LerpAngle(this.angle, targetAngle, 0.4); // Still turn while paused
                        return; // Halt movement
                    }
                    
                    // Smooth rotation towards the target
                    this.angle = LerpAngle(this.angle, targetAngle, 0.2);
                    
                    if(d < CFG.op.speed) {
                        this.pos = target; 
                        this.pathIdx++;
                        
                        // Check if new destination exists and requires significant turn
                        if (this.pathIdx < this.path.length) {
                             let nextTargetAngle = AngleTo(this.pos, this.path[this.pathIdx]);
                             let nextAngleDiff = Math.abs(LerpAngle(0, nextTargetAngle - this.angle, 1));
                             if (nextAngleDiff > Math.PI / 4) { // Pause if turning more than 45 degrees
                                 this.turnPause = CFG.op.turnPauseDuration;
                             }
                        }

                    } else {
                        const newX = this.pos.x + Math.cos(this.angle) * CFG.op.speed;
                        const newY = this.pos.y + Math.sin(this.angle) * CFG.op.speed;
                        
                        // Collision Check
                        if(Game.checkCollision({x: newX, y: newY}, this.rad)) {
                            // Hit a wall or closed door, stop moving on this segment
                            this.pathIdx++; 
                        } else {
                            this.pos.x = newX;
                            this.pos.y = newY;
                        }
                    }
                }

                // Combat Logic (Only fire if not reloading)
                if(this.reloadTimer > 0) return;

                // Auto-Target
                let targets = Game.enemies.filter(e => e.active && e.hp > 0);
                let bestT = null; let minD = Infinity;

                for(let t of targets) {
                    // Op needs good LOS, door must be almost open (0.99)
                    if(Dist(this.pos, t.pos) < CFG.op.view && Game.checkLOS(this.pos, t.pos, false, 0.99)) { 
                        let aToT = AngleTo(this.pos, t.pos);
                        // Check if target is in the field of view cone
                        let angleDiff = Math.abs(LerpAngle(0, aToT - this.angle, 1)); 
                        if(angleDiff < CFG.op.fov/2) {
                            if(Dist(this.pos, t.pos) < minD) { minD = Dist(this.pos, t.pos); bestT = t; }
                        }
                    }
                }

                if(bestT) {
                    this.angle = AngleTo(this.pos, bestT.pos);
                    if(this.cooldown <= 0 && this.mag > 0) {
                        Game.shoot(this, bestT);
                        this.cooldown = 8; this.mag--;
                    }
                }
            }
            draw(ctx) {
                if(!this.active) return;
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                
                // Selection Circle
                if(this === Game.selected) {
                    ctx.beginPath(); ctx.strokeStyle = '#fbbf24'; ctx.lineWidth=2;
                    ctx.arc(0,0, this.rad + 6, 0, Math.PI*2); ctx.stroke();
                    
                    // Draw state text
                    ctx.fillStyle = this.reloadTimer > 0 ? '#ef4444' : '#ffffff'; 
                    ctx.font = "bold 16px 'Rajdhani'";
                    const magText = this.reloadTimer > 0 ? "RELOAD" : `${this.mag}`;
                    ctx.fillText(magText, -15, -30);
                }
                
                ctx.rotate(this.angle);
                // Body
                ctx.fillStyle = this.flashTimer > 0 ? 'rgba(255, 255, 255, 0.5)' : CFG.colors.op;
                ctx.beginPath(); ctx.arc(0,0, this.rad, 0, Math.PI*2); ctx.fill();
                // Arms/Gun
                ctx.fillStyle = '#1e293b'; ctx.fillRect(0, -6, 24, 12);
                
                // Muzzle Flash
                if (this.cooldown > 0 && this.cooldown < 4) {
                    ctx.fillStyle = 'yellow';
                    ctx.beginPath(); ctx.arc(28, 0, 5, -Math.PI/2, Math.PI/2); ctx.fill();
                }

                ctx.restore();
            }
        }

        class Enemy extends Entity {
            constructor(x, y, patrol) {
                super(x, y, 'red');
                this.rad = CFG.enemy.rad;
                this.patrol = patrol; this.pIdx = 0;
                this.state = 'PATROL'; // PATROL, ALERT, COMBAT, STUNNED
                this.stunTimer = 0; this.shootTimer = 0;
                if(patrol.length) this.angle = AngleTo(this.pos, patrol[0]);
            }
            update() {
                if(!this.active || Game.state !== 'RUNNING') return;
                
                // Handle status timers
                this.stunTimer = Math.max(0, this.stunTimer - 1);
                this.shootTimer = Math.max(0, this.shootTimer - 1);

                if(this.stunTimer > 0) { this.state = 'STUNNED'; return; }
                else if (this.state === 'STUNNED') { this.state = 'PATROL'; }

                // Check Vision
                let target = null;
                for(let op of Game.ops) {
                    // Enemy needs less progress on door opening to see (0.1)
                    if(op.active && Game.checkLOS(this.pos, op.pos, false, 0.1)) { 
                        if (Dist(this.pos, op.pos) < CFG.enemy.view) {
                            let a = AngleTo(this.pos, op.pos);
                            let angleDiff = Math.abs(LerpAngle(0, a - this.angle, 1));
                            // Alert state widens the FOV slightly
                            const fov = this.state === 'ALERT' ? Math.PI : CFG.enemy.fov;
                            if(angleDiff < fov/2) target = op;
                        }
                    }
                }

                if(target) {
                    this.state = 'COMBAT';
                    this.angle = AngleTo(this.pos, target.pos);
                    if(this.shootTimer <= 0) {
                        Game.shoot(this, target);
                        this.shootTimer = CFG.enemy.fireRate;
                    }
                } else {
                    if(this.state === 'COMBAT') this.state = 'ALERT'; // Lost visual
                    
                    if(this.state === 'PATROL' && this.patrol.length > 0) {
                        let dest = this.patrol[this.pIdx];
                        let d = Dist(this.pos, dest);
                        this.angle = LerpAngle(this.angle, AngleTo(this.pos, dest), 0.1);
                        
                        if(d < 5) {
                            this.pIdx = (this.pIdx + 1) % this.patrol.length;
                        } else {
                            const speed = CFG.enemy.speed;
                            const newX = this.pos.x + Math.cos(this.angle) * speed;
                            const newY = this.pos.y + Math.sin(this.angle) * speed;

                            if(!Game.checkCollision({x: newX, y: newY}, this.rad)) {
                                this.pos.x = newX;
                                this.pos.y = newY;
                            }
                        }
                    }
                }
            }
            draw(ctx) {
                if(!this.active) return;
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = this.stunTimer > 0 ? 'rgba(128, 128, 128, 0.8)' : CFG.colors.enemy;
                ctx.beginPath(); ctx.arc(0,0, this.rad, 0, Math.PI*2); ctx.fill();
                // Mask / Face
                ctx.fillStyle = '#000'; ctx.fillRect(4, -5, 8, 10);
                
                if(this.state === 'COMBAT') {
                    ctx.fillStyle = '#fbbf24'; ctx.font="bold 20px Rajdhani"; ctx.fillText("!", -5, -20);
                } else if (this.state === 'ALERT') {
                     ctx.fillStyle = '#fef08a'; ctx.font="bold 16px Rajdhani"; ctx.fillText("?", -5, -20);
                } else if (this.stunTimer > 0) {
                    ctx.fillStyle = '#fff'; ctx.font="bold 16px Rajdhani"; ctx.fillText("Zz", -8, -20);
                }
                ctx.restore();
            }
        }

        class Hostage extends Entity {
            constructor(x, y) { super(x, y, 'civil'); this.rad = 14; this.evacuated = false; }
            draw(ctx) {
                if(!this.active || this.evacuated) return;
                ctx.fillStyle = CFG.colors.hostage;
                ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.rad, 0, Math.PI*2); ctx.fill();
                // Hands tied visual
                ctx.fillStyle = '#d1fae5'; ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI*2); ctx.stroke();
            }
        }
        
        class Bullet {
            constructor(start, end, shooter) {
                this.pos = {...start};
                this.shooter = shooter;
                this.targetPos = {...end};
                this.angle = AngleTo(start, end);
                this.vx = Math.cos(this.angle) * CFG.bullet.speed;
                this.vy = Math.sin(this.angle) * CFG.bullet.speed;
                this.active = true;
            }
            update() {
                if(!this.active) return;

                const nextX = this.pos.x + this.vx;
                const nextY = this.pos.y + this.vy;
                const nextPos = Vec2(nextX, nextY);

                // 1. Check entity collision (Only target the opposite team)
                const targets = this.shooter.team === 'blue' ? 
                                Game.enemies.filter(e => e.active) : 
                                Game.ops.filter(o => o.active);
                
                for(let t of targets) {
                    if(Dist(nextPos, t.pos) < t.rad) {
                        t.hit(CFG.bullet.damage);
                        Game.spawnParticles(t.pos.x, t.pos.y, 5, 'blood');
                        this.active = false;
                        return;
                    }
                }

                // 2. Check wall collision (Line segment from current pos to next pos)
                // Use a high minDoorProgress (0.99) for bullets to hit doors unless fully open.
                if(!Game.checkLOS(this.pos, nextPos, true, 0.99)) { 
                    Game.spawnParticles(nextX, nextY, 5, 'spark');
                    Game.camera.addShake(2);
                    this.active = false;
                    return;
                }
                
                this.pos = nextPos;
                
                // 3. Cleanup if far outside map (Safety)
                if (this.pos.x < 0 || this.pos.x > CFG.mapW || this.pos.y < 0 || this.pos.y > CFG.mapH) {
                    this.active = false;
                }
            }
            draw(ctx) {
                if(!this.active) return;
                ctx.fillStyle = CFG.colors.bullet;
                ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 2, 0, Math.PI*2); ctx.fill();
            }
        }


        // --- GAME SYSTEM ---

        const Game = {
            canvas: document.getElementById('worldCanvas'),
            ctx: document.getElementById('worldCanvas').getContext('2d'),
            uiCanvas: document.getElementById('uiCanvas'),
            uictx: document.getElementById('uiCanvas').getContext('2d'),
            
            state: 'PLANNING',
            levelIdx: 0,
            
            // Entities
            walls: [], doors: [], ops: [], enemies: [], hostages: [], corpses: [], particles: [], bullets: [],
            camera: new Camera(),
            selected: null,
            drag: null,
            mapOffset: Vec2(0, 0), // To center the fixed map size

            levels: [
                {
                    name: "ZONE D'ENTRAÎNEMENT",
                    desc: "Tracez un chemin pour votre opérateur. La porte est fermée: utilisez 'OUVRIR' en phase d'Assaut ou lancez un assaut dynamique (clic sur la porte pendant l'assaut). Éliminez l'hostile.",
                    setup: (w, h) => {
                        const cw = w/2; const ch = h/2;
                        Game.walls = [
                            // Outer box
                            {x:0, y:0, w:w, h:10}, {x:0, y:h-10, w:w, h:10}, {x:0, y:10, w:10, h:h-20}, {x:w-10, y:10, w:10, h:h-20},
                            // Central structure
                            {x:cw-10, y:ch-150, w:20, h:300}, // Center Vertical
                            {x:10, y:ch-50, w:cw-120, h:20}, // Left Horizontal 
                            {x:cw+110, y:ch-50, w:w-(cw+120), h:20} // Right Horizontal
                        ];
                        Game.doors = [new Door(cw-120, ch-50, 110, false)];
                        
                        // SAFE SPAWNS: Op starts in open area at bottom
                        Game.ops = [new Operator(cw, h - 50)];
                        // SAFE SPAWNS: Enemy starts in open area at top patroling
                        Game.enemies = [new Enemy(cw-100, 100, [Vec2(cw+100, 100), Vec2(cw-100, 100)])];
                        Game.hostages = [];
                    }
                },
                {
                    name: "EXTRACTION VIP",
                    desc: "Plusieurs pièces. Des patrouilles hostiles. Le VIP est retenu à l'arrière. Silence et coordination entre opérateurs sont recommandés.",
                    setup: (w, h) => {
                        const cw = w/2; const ch = h/2;
                        Game.walls = [
                            // Outer box
                            {x:0, y:0, w:w, h:10}, {x:0, y:h-10, w:w, h:10}, {x:0, y:10, w:10, h:h-20}, {x:w-10, y:10, w:10, h:h-20},
                            // Internal Walls
                            {x:cw-100, y:10, w:20, h:ch+50}, // Left room vertical
                            {x:cw+100, y:ch-50, w:20, h:h-ch+40}, // Right room vertical
                            {x:10, y:ch-100, w:w-20, h:20} // Long horizontal split
                        ];
                        // Doors
                        Game.doors = [
                            new Door(cw-100, ch+50, 80, true), // Door 1
                            new Door(cw-50, ch-100, 100, false) // Door 2
                        ];
                        // SAFE SPAWNS: Ops start in the large bottom-left room
                        Game.ops = [new Operator(50, h-50), new Operator(cw, h-50)]; 
                        
                        // SAFE SPAWNS: Enemies in various strategic locations
                        Game.enemies = [
                            // Patrol in bottom-left room
                            new Enemy(cw-200, h-50, [Vec2(50, h-50), Vec2(cw-150, h-50)]), 
                            // Static in upper-left room
                            new Enemy(cw-200, 50, []),
                            // Static near hostage room entrance
                            new Enemy(cw+150, ch+50, [])
                        ];
                        // SAFE SPAWNS: Hostage in the upper-right corner room
                        Game.hostages = [new Hostage(w-50, 50)];
                    }
                }
            ],

            init() {
                window.addEventListener('resize', this.resize.bind(this));
                
                // Get the maximum canvas dimensions based on fixed map size
                CFG.w = CFG.mapW; CFG.h = CFG.mapH;
                this.canvas.width = CFG.w; this.canvas.height = CFG.h;
                this.uiCanvas.width = CFG.w; this.uiCanvas.height = CFG.h;
                
                this.resize(); // Initial placement of canvas and UI

                // Input - Unified Handlers
                const tHandler = (e) => this.handleInput(e);
                
                this.canvas.addEventListener('mousedown', tHandler);
                this.canvas.addEventListener('mousemove', tHandler);
                window.addEventListener('mouseup', (e) => { this.drag = null; this.updateUnitUI(); });
                
                this.canvas.addEventListener('touchstart', tHandler, {passive: false});
                this.canvas.addEventListener('touchmove', tHandler, {passive: false});
                window.addEventListener('touchend', (e) => { this.drag = null; this.updateUnitUI(); });

                // UI binds
                document.getElementById('btn-execute').onclick = () => this.toggleState();
                document.getElementById('btn-clear').onclick = () => { if(this.state === 'PLANNING') this.ops.forEach(o => o.path = []); };
                document.getElementById('btn-flash').onclick = () => this.useSkill('flash');
                document.getElementById('btn-reload').onclick = () => this.useSkill('reload');

                this.loadLevel(0);
                this.loop();
            },

            resize() {
                // Adjust canvas display size to fit screen while maintaining ratio and center
                const wrapper = document.getElementById('game-wrapper');
                const ratio = CFG.mapW / CFG.mapH;
                const screenW = wrapper.clientWidth;
                const screenH = wrapper.clientHeight;
                
                let canvasW, canvasH;

                if (screenW / screenH > ratio) {
                    canvasH = screenH;
                    canvasW = screenH * ratio;
                } else {
                    canvasW = screenW;
                    canvasH = screenW / ratio;
                }
                
                // Apply visual size (Canvas internal resolution remains CFG.mapW/H)
                this.canvas.style.width = `${canvasW}px`;
                this.canvas.style.height = `${canvasH}px`;
                this.uiCanvas.style.width = `${canvasW}px`;
                this.uiCanvas.style.height = `${canvasH}px`;
                
                // Calculate map offset for centering if needed
                this.mapOffset.x = (screenW - canvasW) / 2;
                this.mapOffset.y = (screenH - canvasH) / 2;
            },
            
            // Converts screen coordinates to map coordinates (CRITICAL for click accuracy)
            getMapCoord(clientX, clientY) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = CFG.mapW / rect.width;
                const scaleY = CFG.mapH / rect.height;

                return Vec2(
                    (clientX - rect.left) * scaleX,
                    (clientY - rect.top) * scaleY
                );
            },

            loadLevel(idx) {
                this.levelIdx = idx;
                if(idx >= this.levels.length) { 
                    this.showModal("MISSION ACCOMPLIE", "Toutes les cibles sont neutralisées et les civils évacués. Excellent travail, commandant.", () => location.reload()); 
                    return; 
                }
                
                // Clean up entities
                this.walls=[]; this.doors=[]; this.ops=[]; this.enemies=[]; this.hostages=[]; this.corpses=[]; this.bullets=[]; this.particles=[];
                
                // Use fixed map size for setup
                this.levels[idx].setup(CFG.mapW, CFG.mapH);
                
                this.state = 'PLANNING';
                this.selected = null;
                this.updateUIPhase();
                this.showModal(this.levels[idx].name, this.levels[idx].desc, () => document.getElementById('modal-overlay').classList.add('hidden'));
            },

            resetLevel() {
                this.loadLevel(this.levelIdx);
            },

            toggleState() {
                if(this.state === 'PLANNING') { 
                    // Validate paths (must have more than 1 point)
                    this.ops.forEach(o => {
                        if (o.path.length <= 1) o.path = [];
                    });
                    this.state = 'RUNNING'; 
                    this.selected = null; 
                }
                else if (this.state === 'RUNNING') { this.state = 'PLANNING'; }
                this.updateUIPhase();
            },

            updateUIPhase() {
                const ind = document.getElementById('phase-indicator');
                const txt = document.getElementById('phase-text');
                const btn = document.getElementById('btn-execute');
                
                document.getElementById('unit-controls').classList.add('opacity-0', 'translate-y-10');

                if(this.state === 'PLANNING') {
                    ind.className = "flex items-center gap-2 text-xs font-bold text-yellow-400 bg-yellow-900/30 px-2 py-1 rounded border border-yellow-500/30 w-max";
                    txt.innerText = "PLANIFICATION";
                    btn.innerHTML = '<span class="material-icons">play_arrow</span> ASSAUT';
                    btn.className = "btn-tac bg-blue-600 hover:bg-blue-500 text-white px-8 py-3 rounded-lg font-bold text-xl tracking-wider min-w-[160px] flex items-center gap-2 justify-center border-b-4 border-blue-800 active:border-b-0 active:translate-y-1";
                } else {
                    ind.className = "flex items-center gap-2 text-xs font-bold text-red-500 bg-red-900/30 px-2 py-1 rounded border border-red-500/30 w-max animate-pulse";
                    txt.innerText = "EN COURS";
                    btn.innerHTML = '<span class="material-icons">pause</span> PAUSE';
                    btn.className = "btn-tac bg-slate-700 hover:bg-slate-600 text-white px-8 py-3 rounded-lg font-bold text-xl tracking-wider min-w-[160px] flex items-center gap-2 justify-center border-b-4 border-slate-900 active:border-b-0 active:translate-y-1";
                }
                document.getElementById('context-layer').innerHTML = ''; // Clear context
            },

            handleInput(e) {
                if(e.target !== this.canvas) return; // Ignore clicks outside canvas
                
                if(e.type === 'touchstart' || e.type === 'touchmove') e.preventDefault();
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const pos = this.getMapCoord(clientX, clientY);

                if(e.type === 'mousedown' || e.type === 'touchstart') {
                    // Check if clicking a door in RUNNING state (Dynamic Open/Close)
                    if (this.state === 'RUNNING') {
                         const clickedDoor = this.doors.find(d => Dist(pos, d.center) < 40);
                         if (clickedDoor && this.ops.some(o => o.active && Dist(o.pos, clickedDoor.center) < 70)) {
                             clickedDoor.open = !clickedDoor.open;
                             return; // Consume input
                         }
                    }

                    // Selection Logic
                    let clickedOp = this.ops.find(o => Dist(pos, o.pos) < 30);
                    if(clickedOp) {
                        this.selected = clickedOp;
                        this.drag = clickedOp;
                        if(this.state === 'PLANNING') {
                            // Start new path if planning
                            clickedOp.path = [clickedOp.pos];
                            clickedOp.pathIdx = 0;
                        }
                    } else {
                        // Deselect if clicking empty space
                        this.selected = null;
                    }
                    this.updateUnitUI();
                }
                else if ((e.type === 'mousemove' || e.type === 'touchmove') && this.drag && this.state === 'PLANNING') {
                    // Drawing Logic
                    let last = this.drag.path[this.drag.path.length-1];
                    // Smoother drawing: Reduced distance threshold 
                    if(Dist(pos, last) > 10) {
                        if(this.checkLOS(last, pos)) {
                            this.drag.path.push(pos);
                        }
                    }
                }
            },

            // --- GAMEPLAY LOGIC ---

            // Checks for line of sight/bullet path against walls and fully closed parts of doors
            // minDoorProgress: the minimum progress (0 to 1) a door must have to NOT block LOS
            checkLOS(p1, p2, checkAllDoors=false, minDoorProgress=0.99) {
                for(let w of this.walls) {
                    const edges = [
                        [Vec2(w.x, w.y), Vec2(w.x+w.w, w.y)], [Vec2(w.x+w.w, w.y), Vec2(w.x+w.w, w.y+w.h)],
                        [Vec2(w.x+w.w, w.y+w.h), Vec2(w.x, w.y+w.h)], [Vec2(w.x, w.y+w.h), Vec2(w.x, w.y)]
                    ];
                    for(let edge of edges) if(Intersect(p1, p2, edge[0], edge[1])) return false;
                }
                
                for(let d of this.doors) {
                    if(d.progress < minDoorProgress || checkAllDoors) { // Door is not sufficiently open
                        // Simplified check: only check the central axis of the door
                        if(d.vertical) {
                            // Check the main line segment of the door slab
                            if(Intersect(p1, p2, Vec2(d.x, d.y + 10), Vec2(d.x, d.y + d.w - 10))) return false;
                        } else {
                            if(Intersect(p1, p2, Vec2(d.x + 10, d.y), Vec2(d.x + d.w - 10, d.y))) return false;
                        }
                    }
                }
                return true;
            },

            // Checks if a circle (entity) collides with any solid wall/closed door
            checkCollision(pos, radius) {
                // Check walls
                for (let w of this.walls) {
                    const closestX = Math.max(w.x, Math.min(pos.x, w.x + w.w));
                    const closestY = Math.max(w.y, Math.min(pos.y, w.y + w.h));
                    if (Dist(pos, Vec2(closestX, closestY)) < radius) return true;
                }
                
                // Check doors (if closed/closing)
                for (let d of this.doors) {
                    if (d.progress < 0.2) { // Only treat as solid if almost fully closed
                        if (d.vertical) {
                            const closestX = Math.max(d.x - 3, Math.min(pos.x, d.x + 3));
                            const closestY = Math.max(d.y, Math.min(pos.y, d.y + d.w));
                            if (Dist(pos, Vec2(closestX, closestY)) < radius) return true;
                        } else {
                            const closestX = Math.max(d.x, Math.min(pos.x, d.x + d.w));
                            const closestY = Math.max(d.y - 3, Math.min(pos.y, d.y + 3));
                            if (Dist(pos, Vec2(closestX, closestY)) < radius) return true;
                        }
                    }
                }
                
                // Check map boundaries (using inner limits for radius safety)
                if (pos.x <= 10 + radius || pos.x >= CFG.mapW - 10 - radius || pos.y <= 10 + radius || pos.y >= CFG.mapH - 10 - radius) {
                    return true;
                }
                
                return false;
            },

            shoot(shooter, target) {
                // Determine a point near the target for the bullet to aim at
                const targetPoint = target.pos;
                
                // Apply a small random spread based on shooter accuracy
                const spreadAngle = (Math.random() - 0.5) * 0.1; // +/- 0.05 radians
                const angle = AngleTo(shooter.pos, targetPoint) + spreadAngle;
                
                // Calculate end point far away for bullet vector
                const farEnd = Vec2(
                    shooter.pos.x + Math.cos(angle) * 1000,
                    shooter.pos.y + Math.sin(angle) * 1000
                );

                this.bullets.push(new Bullet(shooter.pos, farEnd, shooter));
                
                // Muzzle flash particles
                this.spawnParticles(
                    shooter.pos.x + Math.cos(shooter.angle)*20, 
                    shooter.pos.y + Math.sin(shooter.angle)*20, 
                    5, 'spark'
                );
                
                this.camera.addShake(3);
                
                // Alert nearby enemies
                Game.enemies.forEach(e => {
                    if(Dist(e.pos, shooter.pos) < 300 && e.state === 'PATROL') e.state = 'ALERT';
                });
            },

            spawnParticles(x, y, count, type) {
                for(let i=0; i<count; i++) this.particles.push(new Particle(x, y, type));
            },

            useSkill(type) {
                const u = this.selected;
                if(!u || this.state !== 'RUNNING' || u.active === false) return;
                
                if(type === 'flash' && u.flashCD <= 0) {
                    Game.spawnParticles(u.pos.x, u.pos.y, 30, 'spark');
                    u.flashCD = CFG.op.flashCD; // Cooldown
                    
                    this.enemies.forEach(e => {
                        // Stun enemies in a 200 unit radius who have LOS to the flash location
                        if(Dist(u.pos, e.pos) < 200 && this.checkLOS(u.pos, e.pos)) e.stunTimer = 180;
                    });
                } else if (type === 'reload' && u.reloadTimer <= 0) {
                    u.mag = 30; 
                    u.reloadTimer = CFG.op.reloadTime; // Reload time in frames
                }
            },

            updateUnitUI() {
                const p = document.getElementById('unit-controls');
                const btnFlash = document.getElementById('btn-flash');
                const btnReload = document.getElementById('btn-reload');
                const ctxLayer = document.getElementById('context-layer');
                ctxLayer.innerHTML = '';
                
                if(this.selected) {
                    p.classList.remove('opacity-0', 'translate-y-10');
                    
                    if(this.selected instanceof Operator) {
                        btnFlash.disabled = this.selected.flashCD > 0;
                        btnReload.disabled = this.selected.reloadTimer > 0;
                        
                        // Context buttons (Interactions)
                        this.doors.forEach(d => {
                            if(Dist(this.selected.pos, d.center) < 70) {
                                let btn = document.createElement('button');
                                btn.className = "pointer-events-auto btn-tac bg-slate-800 border border-orange-500 text-orange-500 px-4 py-2 rounded font-bold flex items-center gap-2";
                                btn.innerHTML = `<span class="material-icons">meeting_room</span> ${d.progress > 0.5 ? 'FERMER' : 'OUVRIR'}`;
                                btn.onclick = () => d.open = !d.open;
                                ctxLayer.appendChild(btn);
                            }
                        });
                        this.hostages.forEach(h => {
                             if(h.active && !h.evacuated && Dist(this.selected.pos, h.pos) < 70) {
                                let btn = document.createElement('button');
                                btn.className = "pointer-events-auto btn-tac bg-green-600 text-white px-4 py-2 rounded font-bold flex items-center gap-2";
                                btn.innerHTML = `<span class="material-icons">accessibility_new</span> ÉVACUER`;
                                btn.onclick = () => { 
                                    h.evacuated = true; 
                                    this.updateStats(); 
                                    this.updateUnitUI(); // Reclear context
                                };
                                ctxLayer.appendChild(btn);
                            }
                        });
                    }

                } else {
                    p.classList.add('opacity-0', 'translate-y-10');
                }
            },

            updateStats() {
                const activeEnemies = this.enemies.filter(e => e.active).length;
                const remainingHostages = this.hostages.filter(h => h.active && !h.evacuated).length;
                const activeOps = this.ops.filter(o => o.active).length;
                
                document.getElementById('hud-hostiles').innerText = activeEnemies;
                document.getElementById('hud-civils').innerText = remainingHostages;
                
                // Update Cooldown Visuals
                if (this.selected instanceof Operator) {
                    document.getElementById('cd-flash').style.height = `${(this.selected.flashCD / CFG.op.flashCD) * 100}%`;
                    document.getElementById('cd-reload').style.height = `${(this.selected.reloadTimer / CFG.op.reloadTime) * 100}%`;
                }

                // Check Win/Loss
                if(this.state === 'RUNNING') {
                    if(activeEnemies === 0 && remainingHostages === 0) {
                        this.state = 'COMPLETED';
                        setTimeout(() => this.loadLevel(this.levelIdx+1), 2000);
                        this.showModal("MISSION RÉUSSIE", "Toutes les menaces neutralisées, les civils sont en sécurité. Bien joué!", () => this.loadLevel(this.levelIdx+1));
                    }
                    if(activeOps === 0) {
                        this.state = 'FAILED';
                        setTimeout(() => this.loadLevel(this.levelIdx), 2000);
                        this.showModal("MISSION ÉCHOUÉE", "Tous les opérateurs sont hors de combat. Réessayez.", () => this.loadLevel(this.levelIdx));
                    }
                }
            },

            showModal(t, d, cb) {
                document.getElementById('modal-title').innerText = t;
                document.getElementById('modal-desc').innerText = d;
                const btn = document.getElementById('modal-btn');
                btn.onclick = () => { document.getElementById('modal-overlay').classList.add('hidden'); cb(); };
                document.getElementById('modal-overlay').classList.remove('hidden');
            },
            
            // Generate smoother path visualization using catmull-rom or simple cubic bezier approximation
            drawSmoothedPath(ctx, path, color, isSelected) {
                if (path.length < 2) return;

                ctx.strokeStyle = color;
                ctx.lineWidth = isSelected ? 3 : 2;
                ctx.setLineDash(isSelected ? [8, 4] : [4, 4]);
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);

                // Use simple lineTo for now, cubic is complex to implement robustly in a single file
                for(let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Waypoints
                ctx.fillStyle = isSelected ? '#fbbf24' : color;
                for(let i = 0; i < path.length; i++) { 
                    ctx.beginPath(); ctx.arc(path[i].x, path[i].y, i === 0 ? 5 : 3, 0, Math.PI*2); ctx.fill(); 
                }
            },


            // --- RENDER LOOP ---
            loop() {
                this.camera.update();
                
                // Logic
                this.doors.forEach(d => d.update());
                this.ops.forEach(o => o.update());
                this.enemies.forEach(e => e.update());
                this.particles = this.particles.filter((p, i) => { p.update(); return p.life > 0; });
                this.bullets = this.bullets.filter((b, i) => { b.update(); return b.active; });

                this.updateStats();
                this.updateUnitUI(); // Keep context actions fresh

                // DRAW WORLD
                const ctx = this.ctx;
                
                // 1. CLEAR CANVAS & APPLY SHAKE
                ctx.save();
                ctx.fillStyle = CFG.colors.floor;
                ctx.fillRect(0,0,CFG.mapW, CFG.mapH); // Clear based on fixed map size
                ctx.translate(this.camera.x, this.camera.y);

                // 2. GRID FLOOR
                ctx.strokeStyle = CFG.colors.grid; ctx.lineWidth = 1;
                ctx.beginPath();
                for(let x=0; x<CFG.mapW; x+=40) { ctx.moveTo(x,0); ctx.lineTo(x,CFG.mapH); }
                for(let y=0; y<CFG.mapH; y+=40) { ctx.moveTo(0,y); ctx.lineTo(CFG.mapW,y); }
                ctx.stroke();

                // 3. DEAD BODIES & PARTICLES (Below entities)
                this.corpses.forEach(c => {
                    ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(c.angle);
                    ctx.fillStyle = '#334155'; ctx.beginPath(); ctx.arc(0,0,14,0,Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#450a0a'; ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
                    ctx.restore();
                });
                this.particles.forEach(p => p.draw(ctx));

                // 4. PATHS (Planning)
                if(this.state === 'PLANNING' || this.selected) {
                    this.ops.forEach(o => {
                        this.drawSmoothedPath(ctx, o.path, (o === this.selected) ? '#fbbf24' : 'rgba(59, 130, 246, 0.4)', (o === this.selected));
                    });
                    
                    // Input Feedback Circle
                    if(this.drag && this.drag.path.length > 0) {
                        let last = this.drag.path[this.drag.path.length-1];
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                        ctx.beginPath(); ctx.arc(last.x, last.y, 8, 0, Math.PI*2); ctx.stroke();
                    }
                }

                // 5. ENTITIES
                this.hostages.forEach(h => h.draw(ctx));
                this.ops.forEach(o => o.draw(ctx));
                this.enemies.forEach(e => e.draw(ctx));

                // 6. BULLETS (Tracer effect)
                this.bullets.forEach(b => b.draw(ctx));

                // 7. FOG OF WAR / SHADOWS (The "Pro" Look)
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(-10, -10, CFG.mapW + 20, CFG.mapH + 20); // Draw darkness everywhere
                
                ctx.globalCompositeOperation = 'destination-out';
                
                // Operator Vision Cutout
                this.ops.forEach(o => {
                    if(!o.active) return;
                    ctx.save(); ctx.translate(o.pos.x, o.pos.y); ctx.rotate(o.angle);
                    
                    // Use a radial gradient for softer edges
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, CFG.op.view);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;

                    // Draw FOV cone
                    ctx.beginPath(); ctx.moveTo(0,0);
                    ctx.arc(0,0, CFG.op.view, -CFG.op.fov/2, CFG.op.fov/2);
                    ctx.closePath(); ctx.fill();
                    
                    // Small radius around unit for close inspection
                    ctx.beginPath(); ctx.arc(0,0, 60, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                });
                
                ctx.restore(); // Ends FOW composite operation

                // 8. Walls & Doors (On top for clear geometry)
                ctx.shadowColor = 'black'; ctx.shadowBlur = 10;
                this.walls.forEach(w => {
                    ctx.fillStyle = '#1e293b'; ctx.fillRect(w.x, w.y, w.w, w.h);
                    ctx.strokeStyle = '#334155'; ctx.strokeRect(w.x, w.y, w.w, w.h);
                });
                ctx.shadowBlur = 0;
                
                this.doors.forEach(d => d.draw(ctx));
                
                ctx.restore(); // Ends camera shake translation

                requestAnimationFrame(() => this.loop());
            }
        };

        // Boot
        window.onload = function() {
            Game.init();
        }

    </script>
</body>
</html>
