<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gilette Takedown: Black Ops Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        :root {
            --ui-color: #3b82f6;
            --danger-color: #ef4444;
            --success-color: #10b981;
            --bg-dark: #0f172a;
        }
        
        body {
            background-color: #000;
            color: #e2e8f0;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }
        
        /* --- CRT & Scanlines Effect --- */
        #game-wrapper {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #0b0f19;
            overflow: hidden;
            display: flex; /* Center canvas */
            align-items: center;
            justify-content: center;
        }

        /* Fixed canvas size constraint for better geometry predictability */
        #worldCanvas, #uiCanvas {
            max-width: 900px; 
            max-height: 900px;
            width: 100%;
            height: 100%;
            display: block;
            margin: auto;
        }

        .scanlines {
            position: absolute; inset: 0; pointer-events: none; z-index: 10;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            animation: scrollLines 10s linear infinite;
        }
        .vignette {
            position: absolute; inset: 0; pointer-events: none; z-index: 11;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
        }

        /* --- UI Elements --- */
        .hud-panel {
            backdrop-filter: blur(4px);
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid rgba(59, 130, 246, 0.3);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        
        .stencil { font-family: 'Black Ops One', cursive; }
        
        .btn-tac {
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .btn-tac:active { transform: scale(0.95); }
        .btn-tac::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 2px;
            background: rgba(255,255,255,0.3);
        }
        .btn-active {
            border-color: #fbbf24 !important;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.5) !important;
        }

        /* Animations */
        @keyframes modalPop { from { opacity: 0; transform: scale(0.9) translateY(20px); } to { opacity: 1; transform: scale(1) translateY(0); } }
        .modal-enter { animation: modalPop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }

        /* Cooldown visualization */
        .cooldown-bar {
            position: absolute; inset: 0; background: linear-gradient(to top, rgba(0,0,0,0.8), rgba(0,0,0,0.4));
            transform-origin: bottom; transition: height 0.1s linear;
        }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <!-- Canvas for the world geometry, entities, and shadows -->
        <canvas id="worldCanvas"></canvas> 
        <!-- Canvas for the high-resolution, camera-independent UI overlays (currently unused, keeping for future separation) -->
        <canvas id="uiCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas> 
        
        <div class="scanlines"></div>
        <div class="vignette"></div>

        <!-- MAIN HUD -->
        <div class="absolute inset-0 pointer-events-none p-4 flex flex-col justify-between z-20">
            
            <!-- TOP BAR -->
            <div class="flex justify-between items-start">
                <div class="flex flex-col gap-1">
                    <h1 class="stencil text-3xl text-blue-500 tracking-wider drop-shadow-lg leading-none">TAKEDOWN</h1>
                    <div id="phase-indicator" class="flex items-center gap-2 text-xs font-bold text-yellow-400 bg-yellow-900/30 px-2 py-1 rounded border border-yellow-500/30 w-max">
                        <span class="w-2 h-2 rounded-full bg-yellow-400 animate-pulse"></span>
                        <span id="phase-text">PLANIFICATION</span>
                    </div>
                </div>

                <div class="flex gap-3">
                    <div class="hud-panel px-4 py-2 rounded-lg flex flex-col items-center">
                        <span class="text-[10px] text-slate-400 tracking-widest uppercase">Hostiles</span>
                        <span id="hud-hostiles" class="text-2xl font-bold text-red-500 leading-none">0</span>
                    </div>
                    <div class="hud-panel px-4 py-2 rounded-lg flex flex-col items-center">
                        <span class="text-[10px] text-slate-400 tracking-widest uppercase">Civils</span>
                        <span id="hud-civils" class="text-2xl font-bold text-green-500 leading-none">0</span>
                    </div>
                </div>
            </div>

            <!-- CONTEXT ACTIONS (Right Side) -->
            <div id="context-layer" class="absolute right-4 bottom-32 flex flex-col gap-3 items-end pointer-events-none">
                <!-- Injected via JS (Door/Hostage interactions) -->
            </div>

            <!-- BOTTOM CONTROL BAR -->
            <div class="pointer-events-auto flex flex-col gap-3">
                
                <!-- Unit Specific Controls (Only visible when a unit is selected) -->
                <div id="unit-controls" class="flex justify-center gap-6 transition-all duration-300 opacity-0 translate-y-10">
                    
                    <button id="btn-mode-move" class="btn-tac group relative w-14 h-14 rounded-xl bg-slate-800 border border-slate-600 flex items-center justify-center hover:bg-slate-700 hover:border-blue-400 transition-colors btn-active" data-mode="MOVE">
                        <span class="material-icons text-blue-400 group-hover:scale-110 transition-transform">directions_walk</span>
                        <div class="absolute -bottom-6 text-[10px] font-bold text-slate-400 bg-slate-900 px-2 py-0.5 rounded">MOVE</div>
                    </button>
                    
                    <button id="btn-mode-flash" class="btn-tac group relative w-14 h-14 rounded-xl bg-slate-800 border border-slate-600 flex items-center justify-center hover:bg-slate-700 hover:border-yellow-400 transition-colors" data-mode="FLASH">
                        <span class="material-icons text-yellow-400 group-hover:scale-110 transition-transform">flash_on</span>
                        <div class="absolute -bottom-6 text-[10px] font-bold text-slate-400 bg-slate-900 px-2 py-0.5 rounded">FLASH</div>
                        <div id="cd-flash" class="cooldown-bar" style="height:0%"></div>
                    </button>
                    
                    <button id="btn-reload" class="btn-tac group relative w-14 h-14 rounded-xl bg-slate-800 border border-slate-600 flex items-center justify-center hover:bg-slate-700 hover:border-blue-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                        <span class="material-icons text-blue-400 group-hover:rotate-180 transition-transform duration-500">sync</span>
                        <div class="absolute -bottom-6 text-[10px] font-bold text-slate-400 bg-slate-900 px-2 py-0.5 rounded">MAG</div>
                        <div id="cd-reload" class="cooldown-bar" style="height:0%"></div>
                    </button>
                </div>

                <!-- Main Play/Pause -->
                <div class="hud-panel p-2 rounded-xl flex items-center justify-between gap-4">
                    <button onclick="Game.resetLevel()" class="btn-tac p-3 text-slate-400 hover:text-white rounded-lg hover:bg-white/5">
                        <span class="material-icons">restart_alt</span>
                    </button>

                    <div class="flex-1 flex justify-center">
                        <button id="btn-clear" class="btn-tac text-xs font-bold text-slate-400 hover:text-white uppercase tracking-widest px-4 py-2 hover:bg-white/5 rounded">
                            Réinitialiser chemins
                        </button>
                    </div>

                    <button id="btn-execute" class="btn-tac bg-blue-600 hover:bg-blue-500 text-white px-8 py-3 rounded-lg shadow-[0_0_20px_rgba(37,99,235,0.5)] flex items-center gap-2 font-bold text-xl tracking-wider min-w-[160px] justify-center border-b-4 border-blue-800 active:border-b-0 active:translate-y-1">
                        <span class="material-icons">play_arrow</span> ASSAUT
                    </button>
                </div>
            </div>
        </div>

        <!-- MODAL -->
        <div id="modal-overlay" class="absolute inset-0 bg-slate-900/95 z-50 flex items-center justify-center hidden">
            <div class="modal-enter max-w-md w-full mx-4 bg-slate-800 border border-slate-700 p-8 rounded-2xl shadow-2xl text-center relative overflow-hidden">
                <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-blue-500 to-transparent"></div>
                <h2 id="modal-title" class="stencil text-5xl text-white mb-2 uppercase drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">BRIEFING</h2>
                <div class="w-16 h-1 bg-blue-500 mx-auto mb-6"></div>
                <p id="modal-desc" class="text-lg text-slate-300 mb-8 leading-relaxed font-light"></p>
                <button id="modal-btn" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded-xl text-xl tracking-widest uppercase transition-all shadow-lg hover:shadow-blue-500/25">
                    Compris
                </button>
            </div>
        </div>
    </div>

    <script>
        /**
         * GILETTE TAKEDOWN V5 - VISUAL AND TACTICAL REFACTOR
         * * IMPROVEMENTS (05/12/2025):
         * - REDUCED ENTITY SIZE (rad 16 -> 10) for finer control and smaller hitbox.
         * - OPERATOR VISUAL: Changed to a triangle (isosceles) shape to clearly show direction/facing.
         * - ENEMY VISUAL: Retained circle but reduced size.
         * - MUZZLE FLASH: Significantly enhanced visual feedback upon firing.
         * - HIT FEEDBACK: Increased blood particle count upon damage.
         * - Fixed null check crash in loop function.
         */

        // --- UTILS & MATH ---
        const Vec2 = (x, y) => ({x, y});
        const Dist = (v1, v2) => Math.hypot(v2.x - v1.x, v2.y - v1.y);
        const AngleTo = (v1, v2) => Math.atan2(v2.y - v1.y, v2.x - v1.x);
        const Lerp = (a, b, t) => a + (b - a) * t;
        const LerpAngle = (a, b, t) => {
            let d = b - a;
            while (d > Math.PI) d -= 2*Math.PI;
            while (d < -Math.PI) d += 2*Math.PI;
            return a + d * t;
        };
        // Line-Line Intersection (Returns point or null)
        const Intersect = (p1, p2, p3, p4) => {
            const d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
            if (d === 0) return null;
            const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;
            const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) return { x: p1.x + ua * (p2.x - p1.x), y: p1.y + ua * (p2.y - p1.y) };
            return null;
        };

        // --- CONFIG ---
        const CFG = {
            colors: {
                wall: '#1e293b', floor: '#0f172a', op: '#3b82f6', enemy: '#ef4444', hostage: '#10b981',
                grid: 'rgba(59, 130, 246, 0.05)', bullet: '#fbbf24', flash: '#facc15'
            },
            // REDUCED SIZE FOR OPERATORS AND ENEMIES
            op: { speed: 2.5, rad: 10, view: 350, fov: Math.PI / 1.8, reloadTime: 120, flashCD: 300, turnPauseDuration: 15, flashRange: 200 },
            enemy: { speed: 1.2, rad: 10, view: 280, fov: Math.PI / 2.2, fireRate: 40 },
            bullet: { speed: 20, damage: 35 },
            flash: { speed: 10, rad: 5, stunDuration: 180 },
            w: 0, h: 0, // set on resize
            mapW: 800, mapH: 600 // Fixed map size for consistent geometry
        };

        // --- ENGINE CLASSES ---

        class Camera {
            constructor() { this.x = 0; this.y = 0; this.shake = 0; }
            addShake(amount) { this.shake = Math.min(this.shake + amount, 20); }
            update() {
                if(this.shake > 0) {
                    this.x = (Math.random() - 0.5) * this.shake;
                    this.y = (Math.random() - 0.5) * this.shake;
                    this.shake *= 0.8;
                    if(this.shake < 0.5) this.shake = 0;
                } else { this.x = 0; this.y = 0; }
            }
        }

        class Particle {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.life = 1.0;
                const speed = type === 'blood' ? 3 : (type === 'spark' ? 7 : 1); // Increased speed for visual feedback
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * Math.random() * speed;
                this.vy = Math.sin(angle) * Math.random() * speed;
                this.size = Math.random() * 3 + 1;
                this.decay = Math.random() * 0.03 + 0.02;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= this.decay;
                if(this.type === 'blood') { this.vx *= 0.9; this.vy *= 0.9; }
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.type === 'blood' ? '#991b1b' : (this.type === 'spark' ? CFG.colors.bullet : '#ffffff');
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class Door {
            constructor(x, y, w, vertical) {
                this.x = x; this.y = y; this.w = w; this.vertical = vertical;
                this.open = false; this.progress = 0; // 0 = closed, 1 = open
            }
            get center() { return this.vertical ? {x: this.x, y: this.y + this.w/2} : {x: this.x + this.w/2, y: this.y}; }
            update() {
                const speed = 0.05;
                if(this.open && this.progress < 1) this.progress = Math.min(1, this.progress + speed);
                else if(!this.open && this.progress > 0) this.progress = Math.max(0, this.progress - speed);
            }
            draw(ctx) {
                ctx.save();
                // Find hinge/pivot point
                const pivotX = this.vertical ? this.x : this.x + 2;
                const pivotY = this.vertical ? this.y + 2 : this.y;
                
                ctx.translate(pivotX, pivotY);

                // Rotate around the pivot point
                if(this.progress > 0) {
                    const angle = this.progress * -Math.PI/2.2;
                    if(this.vertical) {
                        ctx.translate(0, -2); // Translate to start of door segment (visual offset)
                        ctx.rotate(angle);
                        ctx.translate(0, 2);
                    } else {
                        ctx.translate(-2, 0);
                        ctx.rotate(angle);
                        ctx.translate(2, 0);
                    }
                }
                
                // Draw the door slab
                ctx.fillStyle = '#b45309'; 
                if(this.vertical) {
                    ctx.fillRect(-3, 0, 6, this.w);
                    ctx.fillStyle = '#451a03'; ctx.fillRect(-1, 2, 2, this.w-4);
                } else {
                    ctx.fillRect(0, -3, this.w, 6);
                    ctx.fillStyle = '#451a03'; ctx.fillRect(2, -1, this.w-4, 2);
                }
                ctx.restore();
            }
        }

        class Entity {
            constructor(x, y, team) {
                this.pos = Vec2(x, y); this.team = team;
                this.active = true; this.angle = 0; this.hp = 100;
                this.flashTimer = 0; this.rad = CFG.op.rad;
            }
            hit(dmg) {
                if(!this.active) return;
                this.hp -= dmg;
                // INCREASED particles for better hit feedback
                Game.spawnParticles(this.pos.x, this.pos.y, 15, 'blood'); 
                Game.camera.addShake(1);
                if(this.hp <= 0) {
                    this.active = false;
                    Game.corpses.push({x: this.pos.x, y: this.pos.y, angle: this.angle, team: this.team});
                }
            }
        }

        class Operator extends Entity {
            constructor(x, y) {
                super(x, y, 'blue');
                this.rad = CFG.op.rad;
                this.path = []; this.pathIdx = 0;
                this.flashPath = []; // New: Stores the planned flashbang trajectory
                this.mag = 30; this.reloadTimer = 0; this.cooldown = 0;
                this.flashCD = 0;
                this.turnPause = 0;
                this.flashUsed = false; // Flag to ensure flash is only launched once
            }
            update() {
                if(!this.active) return;

                // Handle status timers
                this.cooldown = Math.max(0, this.cooldown - 1);
                this.reloadTimer = Math.max(0, this.reloadTimer - 1);
                this.flashCD = Math.max(0, this.flashCD - 1);
                this.turnPause = Math.max(0, this.turnPause - 1);

                if(this.flashTimer > 0) { this.flashTimer--; return; }
                if(Game.state !== 'RUNNING') return;
                
                // ACTION 1: Launch planned flashbang if not already used
                if (this.flashPath.length > 1 && !this.flashUsed) {
                    // Launch Flashbang
                    Game.flashbangs.push(new FlashbangProjectile(this.pos, this.flashPath[this.flashPath.length - 1], this));
                    this.flashUsed = true;
                    this.flashPath = []; // Clear path once launched
                    this.flashCD = CFG.op.flashCD;
                }

                // ACTION 2: Movement
                if(this.path.length > 0 && this.pathIdx < this.path.length) {
                    let target = this.path[this.pathIdx];
                    let d = Dist(this.pos, target);
                    let targetAngle = AngleTo(this.pos, target);
                    
                    if (this.turnPause > 0) {
                        this.angle = LerpAngle(this.angle, targetAngle, 0.4);
                        return;
                    }
                    
                    this.angle = LerpAngle(this.angle, targetAngle, 0.2);
                    
                    if(d < CFG.op.speed) {
                        this.pos = target; 
                        this.pathIdx++;
                        
                        if (this.pathIdx < this.path.length) {
                             let nextTargetAngle = AngleTo(this.pos, this.path[this.pathIdx]);
                             let nextAngleDiff = Math.abs(LerpAngle(0, nextTargetAngle - this.angle, 1));
                             if (nextAngleDiff > Math.PI / 4) {
                                 this.turnPause = CFG.op.turnPauseDuration;
                             }
                        }

                    } else {
                        const newX = this.pos.x + Math.cos(this.angle) * CFG.op.speed;
                        const newY = this.pos.y + Math.sin(this.angle) * CFG.op.speed;
                        
                        if(Game.checkCollision({x: newX, y: newY}, this.rad)) {
                            this.pathIdx++; 
                        } else {
                            this.pos.x = newX;
                            this.pos.y = newY;
                        }
                    }
                }

                // ACTION 3: Combat Logic (Only fire if not reloading)
                if(this.reloadTimer > 0) return;

                // Auto-Target
                let targets = Game.enemies.filter(e => e.active && e.hp > 0);
                let bestT = null; let minD = Infinity;

                for(let t of targets) {
                    if(Dist(this.pos, t.pos) < CFG.op.view && Game.checkLOS(this.pos, t.pos, false, 0.99)) { 
                        let aToT = AngleTo(this.pos, t.pos);
                        let angleDiff = Math.abs(LerpAngle(0, aToT - this.angle, 1)); 
                        if(angleDiff < CFG.op.fov/2) {
                            if(Dist(this.pos, t.pos) < minD) { minD = Dist(this.pos, t.pos); bestT = t; }
                        }
                    }
                }

                if(bestT) {
                    this.angle = LerpAngle(this.angle, AngleTo(this.pos, bestT.pos), 0.2); // Slower turn while shooting
                    if(this.cooldown <= 0 && this.mag > 0) {
                        Game.shoot(this, bestT);
                        this.cooldown = 8; this.mag--;
                    }
                }
            }
            draw(ctx) {
                if(!this.active) return;
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                
                // Selection Circle
                if(this === Game.selected) {
                    ctx.beginPath(); ctx.strokeStyle = '#fbbf24'; ctx.lineWidth=2;
                    ctx.arc(0,0, this.rad + 6, 0, Math.PI*2); ctx.stroke();
                    
                    // Draw state text
                    ctx.fillStyle = this.reloadTimer > 0 ? '#ef4444' : '#ffffff'; 
                    ctx.font = "bold 16px 'Rajdhani'";
                    const magText = this.reloadTimer > 0 ? "RELOAD" : `${this.mag}`;
                    ctx.fillText(magText, -15, -30);
                }
                
                ctx.rotate(this.angle);
                // Body - Now a Triangle
                ctx.fillStyle = this.flashTimer > 0 ? 'rgba(255, 255, 255, 0.5)' : CFG.colors.op;
                ctx.beginPath();
                const r = this.rad;
                // Triangle points (Nose forward, base back)
                ctx.moveTo(r * 1.5, 0);
                ctx.lineTo(-r, r * 0.8);
                ctx.lineTo(-r, -r * 0.8);
                ctx.closePath();
                ctx.fill();
                
                // Arms/Gun (adjusted for new body size)
                ctx.fillStyle = '#1e293b'; ctx.fillRect(r * 0.5, -4, r * 1.5, 8);
                
                // Muzzle Flash Effect (ENHANCED VISUALLY)
                if (this.cooldown > 0 && this.cooldown < 4) {
                    const flashSize = 8 + (4 - this.cooldown) * 4;
                    ctx.fillStyle = CFG.colors.bullet;
                    ctx.beginPath(); 
                    // Draw a cone shape from the gun barrel
                    ctx.moveTo(r * 2, 0); 
                    ctx.lineTo(r * 2 + flashSize * 0.8, -flashSize * 0.5);
                    ctx.lineTo(r * 2 + flashSize, 0);
                    ctx.lineTo(r * 2 + flashSize * 0.8, flashSize * 0.5);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        class Enemy extends Entity {
            constructor(x, y, patrol) {
                super(x, y, 'red');
                this.rad = CFG.enemy.rad;
                this.patrol = patrol; this.pIdx = 0;
                this.state = 'PATROL'; // PATROL, ALERT, COMBAT, STUNNED
                this.stunTimer = 0; this.shootTimer = 0;
                if(patrol.length) this.angle = AngleTo(this.pos, patrol[0]);
            }
            update() {
                if(!this.active || Game.state !== 'RUNNING') return;
                
                // Handle status timers
                this.stunTimer = Math.max(0, this.stunTimer - 1);
                this.shootTimer = Math.max(0, this.shootTimer - 1);

                if(this.stunTimer > 0) { this.state = 'STUNNED'; return; }
                else if (this.state === 'STUNNED') { this.state = 'PATROL'; }

                // Check Vision
                let target = null;
                for(let op of Game.ops) {
                    // Enemy needs less progress on door opening to see (0.1)
                    if(op.active && Game.checkLOS(this.pos, op.pos, false, 0.1)) { 
                        if (Dist(this.pos, op.pos) < CFG.enemy.view) {
                            let a = AngleTo(this.pos, op.pos);
                            let angleDiff = Math.abs(LerpAngle(0, a - this.angle, 1));
                            // Alert state widens the FOV slightly
                            const fov = this.state === 'ALERT' ? Math.PI : CFG.enemy.fov;
                            if(angleDiff < fov/2) target = op;
                        }
                    }
                }

                if(target) {
                    this.state = 'COMBAT';
                    this.angle = LerpAngle(this.angle, AngleTo(this.pos, target.pos), 0.1);
                    if(this.shootTimer <= 0) {
                        Game.shoot(this, target);
                        this.shootTimer = CFG.enemy.fireRate;
                    }
                } else {
                    if(this.state === 'COMBAT') this.state = 'ALERT'; // Lost visual
                    
                    if(this.state === 'PATROL' && this.patrol.length > 0) {
                        let dest = this.patrol[this.pIdx];
                        let d = Dist(this.pos, dest);
                        this.angle = LerpAngle(this.angle, AngleTo(this.pos, dest), 0.1);
                        
                        if(d < 5) {
                            this.pIdx = (this.pIdx + 1) % this.patrol.length;
                        } else {
                            const speed = CFG.enemy.speed;
                            const newX = this.pos.x + Math.cos(this.angle) * speed;
                            const newY = this.pos.y + Math.sin(this.angle) * speed;

                            if(!Game.checkCollision({x: newX, y: newY}, this.rad)) {
                                this.pos.x = newX;
                                this.pos.y = newY;
                            }
                        }
                    }
                }
            }
            draw(ctx) {
                if(!this.active) return;
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = this.stunTimer > 0 ? 'rgba(128, 128, 128, 0.8)' : CFG.colors.enemy;
                ctx.beginPath(); ctx.arc(0,0, this.rad, 0, Math.PI*2); ctx.fill();
                
                // Gun/Arms (simple rectangle)
                ctx.fillStyle = '#1e293b'; ctx.fillRect(this.rad * 0.5, -4, this.rad * 1.5, 8);
                
                // Mask / Face (Visual indicator of direction/eyes)
                ctx.fillStyle = '#000'; ctx.fillRect(this.rad * 0.4, -4, 4, 8);
                
                if(this.state === 'COMBAT') {
                    ctx.fillStyle = '#fbbf24'; ctx.font="bold 20px Rajdhani"; ctx.fillText("!", -5, -20);
                } else if (this.state === 'ALERT') {
                     ctx.fillStyle = '#fef08a'; ctx.font="bold 16px Rajdhani"; ctx.fillText("?", -5, -20);
                } else if (this.stunTimer > 0) {
                    ctx.fillStyle = '#fff'; ctx.font="bold 16px Rajdhani"; ctx.fillText("Zz", -8, -20);
                }
                ctx.restore();
            }
        }

        class Hostage extends Entity {
            constructor(x, y) { super(x, y, 'civil'); this.rad = 10; this.evacuated = false; } // Reduced size
            draw(ctx) {
                if(!this.active || this.evacuated) return;
                ctx.fillStyle = CFG.colors.hostage;
                ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.rad, 0, Math.PI*2); ctx.fill();
                // Hands tied visual
                ctx.fillStyle = '#d1fae5'; ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 8, 0, Math.PI*2); ctx.stroke();
            }
        }
        
        class Bullet {
            constructor(start, end, shooter) {
                this.pos = {...start};
                this.shooter = shooter;
                this.targetPos = {...end};
                this.angle = AngleTo(start, end);
                this.vx = Math.cos(this.angle) * CFG.bullet.speed;
                this.vy = Math.sin(this.angle) * CFG.bullet.speed;
                this.active = true;
            }
            update() {
                if(!this.active) return;

                const nextX = this.pos.x + this.vx;
                const nextY = this.pos.y + this.vy;
                const nextPos = Vec2(nextX, nextY);

                // 1. Check entity collision (Only target the opposite team)
                const targets = this.shooter.team === 'blue' ? 
                                Game.enemies.filter(e => e.active) : 
                                Game.ops.filter(o => o.active);
                
                for(let t of targets) {
                    if(Dist(nextPos, t.pos) < t.rad) {
                        t.hit(CFG.bullet.damage);
                        this.active = false;
                        return;
                    }
                }

                // 2. Check wall collision (Line segment from current pos to next pos)
                if(!Game.checkLOS(this.pos, nextPos, true, 0.99)) { 
                    Game.spawnParticles(nextX, nextY, 5, 'spark');
                    Game.camera.addShake(2);
                    this.active = false;
                    return;
                }
                
                this.pos = nextPos;
                
                // 3. Cleanup if far outside map (Safety)
                if (this.pos.x < 0 || this.pos.x > CFG.mapW || this.pos.y < 0 || this.pos.y > CFG.mapH) {
                    this.active = false;
                }
            }
            draw(ctx) {
                if(!this.active) return;
                ctx.fillStyle = CFG.colors.bullet;
                ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 2, 0, Math.PI*2); ctx.fill();
            }
        }
        
        class FlashbangProjectile {
             constructor(start, end, operator) {
                this.pos = {...start};
                this.target = {...end};
                this.operator = operator;
                this.angle = AngleTo(start, end);
                const distance = Dist(start, end);
                
                // Calculate time to reach target based on distance and fixed speed
                this.totalTime = Math.max(10, distance / CFG.flash.speed);
                this.timeElapsed = 0;
                this.active = true;
            }
            update() {
                if(!this.active) return;
                this.timeElapsed++;

                // Interpolate position
                const t = this.timeElapsed / this.totalTime;
                
                if (t >= 1) {
                    this.detonate(this.target);
                    this.active = false;
                    return;
                }
                
                const nextX = Lerp(this.pos.x, this.target.x, t);
                const nextY = Lerp(this.pos.y, this.target.y, t);

                const nextPos = Vec2(nextX, nextY);
                
                // Check for wall impact (This logic needs to check the entire line segment, but simple point check will do for now)
                if(!Game.checkLOS(this.pos, nextPos, true, 0.99)) {
                    this.detonate(this.pos);
                    this.active = false;
                    return;
                }
                
                this.pos = nextPos;
            }
            detonate(position) {
                Game.spawnParticles(position.x, position.y, 50, 'spark');
                Game.camera.addShake(5);
                
                // Apply stun effect
                Game.enemies.forEach(e => {
                    const dist = Dist(position, e.pos);
                    if(dist < CFG.op.flashRange) {
                        // Check line of sight from flash point to enemy
                        if(Game.checkLOS(position, e.pos, false, 0.99)) {
                           e.stunTimer = CFG.flash.stunDuration;
                        }
                    }
                });
            }
            draw(ctx) {
                if(!this.active) return;
                ctx.fillStyle = CFG.colors.flash;
                ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, CFG.flash.rad, 0, Math.PI*2); ctx.fill();
            }
        }


        // --- GAME SYSTEM ---

        const Game = {
            canvas: document.getElementById('worldCanvas'),
            ctx: document.getElementById('worldCanvas').getContext('2d'),
            uiCanvas: document.getElementById('uiCanvas'),
            uictx: document.getElementById('uiCanvas').getContext('2d'),
            
            state: 'PLANNING',
            mode: 'MOVE', // MOVE or FLASH (Planning mode)
            levelIdx: 0,
            
            // Entities
            walls: [], doors: [], ops: [], enemies: [], hostages: [], corpses: [], particles: [], bullets: [], flashbangs: [],
            camera: new Camera(),
            selected: null,
            drag: null,
            mapOffset: Vec2(0, 0), // To center the fixed map size

            levels: [
                {
                    name: "ZONE D'ENTRAÎNEMENT",
                    desc: "Tracez un chemin (MOVE) pour votre opérateur. Utilisez FLASH pour tracer une trajectoire de grenade qui se lancera au début de l'assaut. La grenade étourdit les cibles dans la ligne de mire à l'explosion.",
                    setup: (w, h) => {
                        const cw = w/2; const ch = h/2;
                        Game.walls = [
                            // Outer box
                            {x:0, y:0, w:w, h:10}, {x:0, y:h-10, w:w, h:10}, {x:0, y:10, w:10, h:h-20}, {x:w-10, y:10, w:10, h:h-20},
                            // Central structure
                            {x:cw-10, y:ch-150, w:20, h:300}, // Center Vertical
                            {x:10, y:ch-50, w:cw-120, h:20}, // Left Horizontal 
                            {x:cw+110, y:ch-50, w:w-(cw+120), h:20} // Right Horizontal
                        ];
                        Game.doors = [new Door(cw-120, ch-50, 110, false)];
                        
                        // SAFE SPAWNS: Op starts in open area at bottom
                        Game.ops = [new Operator(cw, h - 50)];
                        // SAFE SPAWNS: Enemy starts in open area at top patroling
                        Game.enemies = [new Enemy(cw-100, 100, [Vec2(cw+100, 100), Vec2(cw-100, 100)])];
                        Game.hostages = [];
                    }
                },
                {
                    name: "EXTRACTION VIP",
                    desc: "Plusieurs pièces. Des patrouilles hostiles. Le VIP est retenu à l'arrière. Utilisez la coordination et la grenade FLASH pour neutraliser les menaces sans vous exposer.",
                    setup: (w, h) => {
                        const cw = w/2; const ch = h/2;
                        Game.walls = [
                            // Outer box
                            {x:0, y:0, w:w, h:10}, {x:0, y:h-10, w:w, h:10}, {x:0, y:10, w:10, h:h-20}, {x:w-10, y:10, w:10, h:h-20},
                            // Internal Walls
                            {x:cw-100, y:10, w:20, h:ch+50}, // Left room vertical
                            {x:cw+100, y:ch-50, w:20, h:h-ch+40}, // Right room vertical
                            {x:10, y:ch-100, w:w-20, h:20} // Long horizontal split
                        ];
                        // Doors
                        Game.doors = [
                            new Door(cw-100, ch+50, 80, true), // Door 1
                            new Door(cw-50, ch-100, 100, false) // Door 2
                        ];
                        // SAFE SPAWNS: Ops start in the large bottom-left room
                        Game.ops = [new Operator(50, h-50), new Operator(cw, h-50)]; 
                        
                        // SAFE SPAWNS: Enemies in various strategic locations
                        Game.enemies = [
                            // Patrol in bottom-left room
                            new Enemy(cw-200, h-50, [Vec2(50, h-50), Vec2(cw-150, h-50)]), 
                            // Static in upper-left room
                            new Enemy(cw-200, 50, []),
                            // Static near hostage room entrance
                            new Enemy(cw+150, ch+50, [])
                        ];
                        // SAFE SPAWNS: Hostage in the upper-right corner room
                        Game.hostages = [new Hostage(w-50, 50)];
                    }
                }
            ],

            init() {
                window.addEventListener('resize', this.resize.bind(this));
                
                // Get the maximum canvas dimensions based on fixed map size
                CFG.w = CFG.mapW; CFG.h = CFG.mapH;
                this.canvas.width = CFG.w; this.canvas.height = CFG.h;
                this.uiCanvas.width = CFG.w; this.uiCanvas.height = CFG.h;
                
                this.resize(); // Initial placement of canvas and UI

                // Input - Unified Handlers
                const tHandler = (e) => this.handleInput(e);
                
                this.canvas.addEventListener('mousedown', tHandler);
                this.canvas.addEventListener('mousemove', tHandler);
                window.addEventListener('mouseup', (e) => { this.drag = null; this.endDrag(); this.updateUnitUI(); });
                
                this.canvas.addEventListener('touchstart', tHandler, {passive: false});
                this.canvas.addEventListener('touchmove', tHandler, {passive: false});
                window.addEventListener('touchend', (e) => { this.drag = null; this.endDrag(); this.updateUnitUI(); });

                // UI binds
                document.getElementById('btn-execute').onclick = () => this.toggleState();
                document.getElementById('btn-clear').onclick = () => { if(this.state === 'PLANNING') this.ops.forEach(o => { o.path = []; o.flashPath = []; }); };
                document.getElementById('btn-reload').onclick = () => { if(this.state === 'RUNNING') this.useSkill('reload'); };
                
                document.getElementById('btn-mode-move').onclick = () => this.setMode('MOVE');
                document.getElementById('btn-mode-flash').onclick = () => this.setMode('FLASH');

                this.loadLevel(0);
                this.loop();
            },

            resize() {
                // Adjust canvas display size to fit screen while maintaining ratio and center
                const wrapper = document.getElementById('game-wrapper');
                const ratio = CFG.mapW / CFG.mapH;
                const screenW = wrapper.clientWidth;
                const screenH = wrapper.clientHeight;
                
                let canvasW, canvasH;

                if (screenW / screenH > ratio) {
                    canvasH = screenH;
                    canvasW = screenH * ratio;
                } else {
                    canvasW = screenW;
                    canvasH = screenW / ratio;
                }
                
                // Apply visual size (Canvas internal resolution remains CFG.mapW/H)
                this.canvas.style.width = `${canvasW}px`;
                this.canvas.style.height = `${canvasH}px`;
                this.uiCanvas.style.width = `${canvasW}px`;
                this.uiCanvas.style.height = `${canvasH}px`;
                
                // Calculate map offset for centering if needed
                this.mapOffset.x = (screenW - canvasW) / 2;
                this.mapOffset.y = (screenH - canvasH) / 2;
            },
            
            getMapCoord(clientX, clientY) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = CFG.mapW / rect.width;
                const scaleY = CFG.mapH / rect.height;

                return Vec2(
                    (clientX - rect.left) * scaleX,
                    (clientY - rect.top) * scaleY
                );
            },

            loadLevel(idx) {
                this.levelIdx = idx;
                if(idx >= this.levels.length) { 
                    this.showModal("MISSION ACCOMPLIE", "Toutes les cibles sont neutralisées et les civils évacués. Excellent travail, commandant.", () => location.reload()); 
                    return; 
                }
                
                // Clean up entities
                this.walls=[]; this.doors=[]; this.ops=[]; this.enemies=[]; this.hostages=[]; this.corpses=[]; this.bullets=[]; this.flashbangs=[]; this.particles=[];
                
                // Reset flags
                this.mode = 'MOVE';
                
                // Use fixed map size for setup
                this.levels[idx].setup(CFG.mapW, CFG.mapH);
                
                this.state = 'PLANNING';
                this.selected = null;
                this.updateUIPhase();
                this.showModal(this.levels[idx].name, this.levels[idx].desc, () => document.getElementById('modal-overlay').classList.add('hidden'));
            },

            resetLevel() {
                this.loadLevel(this.levelIdx);
            },

            toggleState() {
                if(this.state === 'PLANNING') { 
                    // Prepare ops for execution
                    this.ops.forEach(o => {
                        if (o.path.length <= 1) o.path = [];
                        o.flashUsed = false; // Reset flash usage flag
                    });
                    this.state = 'RUNNING'; 
                    this.selected = null; 
                }
                else if (this.state === 'RUNNING') { this.state = 'PLANNING'; }
                this.updateUIPhase();
            },
            
            setMode(newMode) {
                if (this.state !== 'PLANNING') return;
                this.mode = newMode;
                document.querySelectorAll('#unit-controls button[data-mode]').forEach(btn => {
                    btn.classList.remove('btn-active');
                });
                document.querySelector(`#unit-controls button[data-mode="${newMode}"]`).classList.add('btn-active');
            },
            
            endDrag() {
                if (this.selected && this.state === 'PLANNING' && this.mode === 'FLASH') {
                    // Finalize Flash Path: take only the first two points (start and target)
                    if (this.selected.flashPath.length > 1) {
                        this.selected.flashPath = [this.selected.pos, this.selected.flashPath[this.selected.flashPath.length - 1]];
                    } else {
                         this.selected.flashPath = []; // Invalid path
                    }
                }
            },

            updateUIPhase() {
                const ind = document.getElementById('phase-indicator');
                const txt = document.getElementById('phase-text');
                const btn = document.getElementById('btn-execute');
                
                document.getElementById('unit-controls').classList.add('opacity-0', 'translate-y-10');

                if(this.state === 'PLANNING') {
                    ind.className = "flex items-center gap-2 text-xs font-bold text-yellow-400 bg-yellow-900/30 px-2 py-1 rounded border border-yellow-500/30 w-max";
                    txt.innerText = "PLANIFICATION";
                    btn.innerHTML = '<span class="material-icons">play_arrow</span> ASSAUT';
                    btn.className = "btn-tac bg-blue-600 hover:bg-blue-500 text-white px-8 py-3 rounded-lg font-bold text-xl tracking-wider min-w-[160px] flex items-center gap-2 justify-center border-b-4 border-blue-800 active:border-b-0 active:translate-y-1";
                } else {
                    ind.className = "flex items-center gap-2 text-xs font-bold text-red-500 bg-red-900/30 px-2 py-1 rounded border border-red-500/30 w-max animate-pulse";
                    txt.innerText = "EN COURS";
                    btn.innerHTML = '<span class="material-icons">pause</span> PAUSE';
                    btn.className = "btn-tac bg-slate-700 hover:bg-slate-600 text-white px-8 py-3 rounded-lg font-bold text-xl tracking-wider min-w-[160px] flex items-center gap-2 justify-center border-b-4 border-slate-900 active:border-b-0 active:translate-y-1";
                }
                document.getElementById('context-layer').innerHTML = ''; // Clear context
            },

            handleInput(e) {
                if(e.target !== this.canvas) return;
                
                if(e.type === 'touchstart' || e.type === 'touchmove') e.preventDefault();
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const pos = this.getMapCoord(clientX, clientY);

                if(e.type === 'mousedown' || e.type === 'touchstart') {
                    // Dynamic Door Interaction (RUNNING phase)
                    if (this.state === 'RUNNING') {
                         const clickedDoor = this.doors.find(d => Dist(pos, d.center) < 40);
                         if (clickedDoor && this.ops.some(o => o.active && Dist(o.pos, clickedDoor.center) < 70)) {
                             clickedDoor.open = !clickedDoor.open;
                             return;
                         }
                    }

                    // Selection Logic (Always possible)
                    let clickedOp = this.ops.find(o => Dist(pos, o.pos) < 30);
                    if(clickedOp) {
                        this.selected = clickedOp;
                        this.drag = clickedOp;
                        if(this.state === 'PLANNING') {
                            // Start new path/flashpath depending on mode
                            if (this.mode === 'MOVE') {
                                clickedOp.path = [clickedOp.pos];
                                clickedOp.pathIdx = 0;
                            } else if (this.mode === 'FLASH') {
                                // Only allow drawing if flash is not already planned
                                if (!clickedOp.flashPath.length) {
                                    clickedOp.flashPath = [clickedOp.pos];
                                }
                            }
                        }
                    } else {
                        this.selected = null;
                        this.drag = null;
                    }
                    this.updateUnitUI();
                }
                else if ((e.type === 'mousemove' || e.type === 'touchmove') && this.drag && this.state === 'PLANNING') {
                    let last = (this.mode === 'MOVE') ? this.drag.path[this.drag.path.length-1] : this.drag.flashPath[this.drag.flashPath.length-1];

                    if(Dist(pos, last) > 10) {
                        if(this.checkLOS(last, pos)) {
                            if (this.mode === 'MOVE') {
                                this.drag.path.push(pos);
                            } else if (this.mode === 'FLASH') {
                                // Only need start and end points for flash, so update the last point
                                if (this.drag.flashPath.length === 1) {
                                    this.drag.flashPath.push(pos);
                                } else if (this.drag.flashPath.length > 1) {
                                    this.drag.flashPath[1] = pos;
                                }
                            }
                        }
                    }
                }
            },

            // --- GAMEPLAY LOGIC ---

            // Checks for line of sight/bullet path against walls and doors
            checkLOS(p1, p2, checkAllDoors=false, minDoorProgress=0.99) {
                // Check walls
                for(let w of this.walls) {
                    const edges = [
                        [Vec2(w.x, w.y), Vec2(w.x+w.w, w.y)], [Vec2(w.x+w.w, w.y), Vec2(w.x+w.w, w.y+w.h)],
                        [Vec2(w.x+w.w, w.y+w.h), Vec2(w.x, w.y+w.h)], [Vec2(w.x, w.y+w.h), Vec2(w.x, w.y)]
                    ];
                    for(let edge of edges) if(Intersect(p1, p2, edge[0], edge[1])) return false;
                }
                
                // Check doors
                for(let d of this.doors) {
                    if(d.progress < minDoorProgress || checkAllDoors) {
                        if(d.vertical) {
                            if(Intersect(p1, p2, Vec2(d.x, d.y + 10), Vec2(d.x, d.y + d.w - 10))) return false;
                        } else {
                            if(Intersect(p1, p2, Vec2(d.x + 10, d.y), Vec2(d.x + d.w - 10, d.y))) return false;
                        }
                    }
                }
                return true;
            },

            // Checks if a circle (entity) collides with any solid wall/closed door
            checkCollision(pos, radius) {
                // Check walls
                for (let w of this.walls) {
                    const closestX = Math.max(w.x, Math.min(pos.x, w.x + w.w));
                    const closestY = Math.max(w.y, Math.min(pos.y, w.y + w.h));
                    if (Dist(pos, Vec2(closestX, closestY)) < radius) return true;
                }
                
                // Check doors (if closed/closing)
                for (let d of this.doors) {
                    if (d.progress < 0.2) {
                        if (d.vertical) {
                            const closestX = Math.max(d.x - 3, Math.min(pos.x, d.x + 3));
                            const closestY = Math.max(d.y, Math.min(pos.y, d.y + d.w));
                            if (Dist(pos, Vec2(closestX, closestY)) < radius) return true;
                        } else {
                            const closestX = Math.max(d.x, Math.min(pos.x, d.x + d.w));
                            const closestY = Math.max(d.y - 3, Math.min(pos.y, d.y + 3));
                            if (Dist(pos, Vec2(closestX, closestY)) < radius) return true;
                        }
                    }
                }
                
                // Check map boundaries (using inner limits for radius safety)
                if (pos.x <= 10 + radius || pos.x >= CFG.mapW - 10 - radius || pos.y <= 10 + radius || pos.y >= CFG.mapH - 10 - radius) {
                    return true;
                }
                
                return false;
            },

            shoot(shooter, target) {
                const targetPoint = target.pos;
                const spreadAngle = (Math.random() - 0.5) * 0.1;
                const angle = AngleTo(shooter.pos, targetPoint) + spreadAngle;
                
                const farEnd = Vec2(
                    shooter.pos.x + Math.cos(angle) * 1000,
                    shooter.pos.y + Math.sin(angle) * 1000
                );

                this.bullets.push(new Bullet(shooter.pos, farEnd, shooter));
                
                this.camera.addShake(3);
                
                // Alert nearby enemies
                Game.enemies.forEach(e => {
                    if(Dist(e.pos, shooter.pos) < 300 && e.state === 'PATROL') e.state = 'ALERT';
                });
            },

            spawnParticles(x, y, count, type) {
                for(let i=0; i<count; i++) this.particles.push(new Particle(x, y, type));
            },

            useSkill(type) {
                const u = this.selected;
                if(!u || u.active === false) return;
                
                if (type === 'reload' && u.reloadTimer <= 0) {
                    u.mag = 30; 
                    u.reloadTimer = CFG.op.reloadTime;
                }
            },

            updateUnitUI() {
                const p = document.getElementById('unit-controls');
                const btnFlash = document.getElementById('btn-mode-flash');
                const btnReload = document.getElementById('btn-reload');
                const ctxLayer = document.getElementById('context-layer');
                ctxLayer.innerHTML = '';
                
                if(this.selected) {
                    p.classList.remove('opacity-0', 'translate-y-10');
                    
                    if(this.selected instanceof Operator) {
                        // Check if flash is available (planned or on cooldown)
                        const flashUnavailable = this.selected.flashCD > 0 || this.selected.flashPath.length > 1;
                        btnFlash.disabled = flashUnavailable && this.state === 'PLANNING';
                        
                        btnReload.disabled = this.selected.reloadTimer > 0;
                        
                        // Context buttons (Interactions)
                        this.doors.forEach(d => {
                            if(Dist(this.selected.pos, d.center) < 70) {
                                let btn = document.createElement('button');
                                btn.className = "pointer-events-auto btn-tac bg-slate-800 border border-orange-500 text-orange-500 px-4 py-2 rounded font-bold flex items-center gap-2";
                                btn.innerHTML = `<span class="material-icons">meeting_room</span> ${d.progress > 0.5 ? 'FERMER' : 'OUVRIR'}`;
                                btn.onclick = () => d.open = !d.open;
                                ctxLayer.appendChild(btn);
                            }
                        });
                        this.hostages.forEach(h => {
                             if(h.active && !h.evacuated && Dist(this.selected.pos, h.pos) < 70) {
                                let btn = document.createElement('button');
                                btn.className = "pointer-events-auto btn-tac bg-green-600 text-white px-4 py-2 rounded font-bold flex items-center gap-2";
                                btn.innerHTML = `<span class="material-icons">accessibility_new</span> ÉVACUER`;
                                btn.onclick = () => { 
                                    h.evacuated = true; 
                                    this.updateStats(); 
                                    this.updateUnitUI();
                                };
                                ctxLayer.appendChild(btn);
                            }
                        });
                    }
                    // Sync mode button state
                    document.querySelectorAll('#unit-controls button[data-mode]').forEach(btn => {
                        if (btn.getAttribute('data-mode') === this.mode) {
                            btn.classList.add('btn-active');
                        } else {
                            btn.classList.remove('btn-active');
                        }
                    });

                } else {
                    p.classList.add('opacity-0', 'translate-y-10');
                }
            },

            updateStats() {
                const activeEnemies = this.enemies.filter(e => e.active).length;
                const remainingHostages = this.hostages.filter(h => h.active && !h.evacuated).length;
                const activeOps = this.ops.filter(o => o.active).length;
                
                document.getElementById('hud-hostiles').innerText = activeEnemies;
                document.getElementById('hud-civils').innerText = remainingHostages;
                
                // Update Cooldown Visuals
                if (this.selected instanceof Operator) {
                    document.getElementById('cd-flash').style.height = `${(this.selected.flashCD / CFG.op.flashCD) * 100}%`;
                    document.getElementById('cd-reload').style.height = `${(this.selected.reloadTimer / CFG.op.reloadTime) * 100}%`;
                }

                // Check Win/Loss
                if(this.state === 'RUNNING') {
                    if(activeEnemies === 0 && remainingHostages === 0) {
                        this.state = 'COMPLETED';
                        setTimeout(() => this.loadLevel(this.levelIdx+1), 2000);
                        this.showModal("MISSION RÉUSSIE", "Toutes les menaces neutralisées, les civils sont en sécurité. Bien joué!", () => this.loadLevel(this.levelIdx+1));
                    }
                    if(activeOps === 0) {
                        this.state = 'FAILED';
                        setTimeout(() => this.loadLevel(this.levelIdx), 2000);
                        this.showModal("MISSION ÉCHOUÉE", "Tous les opérateurs sont hors de combat. Réessayez.", () => this.loadLevel(this.levelIdx));
                    }
                }
            },

            showModal(t, d, cb) {
                document.getElementById('modal-title').innerText = t;
                document.getElementById('modal-desc').innerText = d;
                const btn = document.getElementById('modal-btn');
                btn.onclick = () => { document.getElementById('modal-overlay').classList.add('hidden'); cb(); };
                document.getElementById('modal-overlay').classList.remove('hidden');
            },
            
            // Draw path for MOVE or FLASH
            drawPath(ctx, path, color, isSelected) {
                if (path.length < 2) return;

                ctx.strokeStyle = color;
                ctx.lineWidth = isSelected ? 3 : 2;
                ctx.setLineDash(isSelected ? [8, 4] : [4, 4]);
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);

                for(let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Waypoints
                ctx.fillStyle = isSelected ? '#fbbf24' : color;
                for(let i = 0; i < path.length; i++) { 
                    ctx.beginPath(); ctx.arc(path[i].x, path[i].y, i === 0 ? 5 : 3, 0, Math.PI*2); ctx.fill(); 
                }
            },


            // --- RENDER LOOP ---
            loop() {
                this.camera.update();
                
                // Logic
                this.doors.forEach(d => d.update());
                this.ops.forEach(o => o.update());
                this.enemies.forEach(e => e.update());
                this.particles = this.particles.filter((p, i) => { p.update(); return p.life > 0; });
                this.bullets = this.bullets.filter((b, i) => { b.update(); return b.active; });
                this.flashbangs = this.flashbangs.filter((f, i) => { f.update(); return f.active; });

                this.updateStats();
                // We call updateUnitUI inside updateStats to keep the context actions live in RUNNING mode

                // DRAW WORLD
                const ctx = this.ctx;
                
                // 1. CLEAR CANVAS & APPLY SHAKE
                ctx.save();
                ctx.fillStyle = CFG.colors.floor;
                ctx.fillRect(0,0,CFG.mapW, CFG.mapH); // Clear based on fixed map size
                ctx.translate(this.camera.x, this.camera.y);

                // 2. GRID FLOOR
                ctx.strokeStyle = CFG.colors.grid; ctx.lineWidth = 1;
                ctx.beginPath();
                for(let x=0; x<CFG.mapW; x+=40) { ctx.moveTo(x,0); ctx.lineTo(x,CFG.mapH); }
                for(let y=0; y<CFG.mapH; y+=40) { ctx.moveTo(0,y); ctx.lineTo(CFG.mapW,y); }
                ctx.stroke();

                // 3. DEAD BODIES & PARTICLES (Below entities)
                this.corpses.forEach(c => {
                    ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(c.angle);
                    ctx.fillStyle = '#334155'; ctx.beginPath(); ctx.arc(0,0,14,0,Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#450a0a'; ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
                    ctx.restore();
                });
                this.particles.forEach(p => p.draw(ctx));

                // 4. PATHS (Planning)
                if(this.state === 'PLANNING' || this.selected) {
                    this.ops.forEach(o => {
                        const isOpSelected = (o === this.selected);
                        
                        // Draw Move Path
                        this.drawPath(ctx, o.path, (isOpSelected && this.mode === 'MOVE') ? '#3b82f6' : 'rgba(59, 130, 246, 0.4)', (isOpSelected && this.mode === 'MOVE'));
                        
                        // Draw Flash Path
                        if (o.flashPath.length) {
                             this.drawPath(ctx, o.flashPath, (isOpSelected && this.mode === 'FLASH') ? CFG.colors.flash : 'rgba(250, 204, 21, 0.6)', (isOpSelected && this.mode === 'FLASH'));
                        }
                    });
                    
                    // Input Feedback Circle
                    if(this.drag && this.selected) {
                        let path;
                        if (this.mode === 'MOVE' && this.drag.path.length > 0) {
                            path = this.drag.path;
                        } else if (this.mode === 'FLASH' && this.drag.flashPath.length > 0) {
                            path = this.drag.flashPath;
                        }
                        
                        if (path) {
                            let last = path[path.length-1];
                            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                            ctx.beginPath(); ctx.arc(last.x, last.y, 8, 0, Math.PI*2); ctx.stroke();
                        }
                    }
                }

                // 5. ENTITIES
                this.hostages.forEach(h => h.draw(ctx));
                this.ops.forEach(o => o.draw(ctx));
                this.enemies.forEach(e => e.draw(ctx));

                // 6. PROJECTILES (Bullets and Flashbangs)
                this.bullets.forEach(b => b.draw(ctx));
                this.flashbangs.forEach(f => f.draw(ctx));

                // 7. FOG OF WAR / SHADOWS (The "Pro" Look)
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(-10, -10, CFG.mapW + 20, CFG.mapH + 20); // Draw darkness everywhere
                
                ctx.globalCompositeOperation = 'destination-out';
                
                // Operator Vision Cutout
                this.ops.forEach(o => {
                    if(!o.active) return;
                    ctx.save(); ctx.translate(o.pos.x, o.pos.y); ctx.rotate(o.angle);
                    
                    // Use a radial gradient for softer edges
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, CFG.op.view);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;

                    // Draw FOV cone
                    ctx.beginPath(); ctx.moveTo(0,0);
                    ctx.arc(0,0, CFG.op.view, -CFG.op.fov/2, CFG.op.fov/2);
                    ctx.closePath(); ctx.fill();
                    
                    // Small radius around unit for close inspection
                    ctx.beginPath(); ctx.arc(0,0, 60, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                });
                
                ctx.restore(); // Ends FOW composite operation

                // 8. Walls & Doors (On top for clear geometry)
                ctx.shadowColor = 'black'; ctx.shadowBlur = 10;
                this.walls.forEach(w => {
                    ctx.fillStyle = '#1e293b'; ctx.fillRect(w.x, w.y, w.w, w.h);
                    ctx.strokeStyle = '#334155'; ctx.strokeRect(w.x, w.y, w.w, w.h);
                });
                ctx.shadowBlur = 0;
                
                this.doors.forEach(d => d.draw(ctx));
                
                ctx.restore(); // Ends camera shake translation

                requestAnimationFrame(() => this.loop());
            }
        };

        // Boot
        window.onload = function() {
            Game.init();
        }

    </script>
</body>
</html>
