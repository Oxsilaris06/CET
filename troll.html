
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectral Flow v3 - Secure Lock</title>
    <style>
        :root { --bg: #020617; --primary: #06b6d4; --success: #22c55e; --error: #ef4444; }
        body { font-family: 'Inter', system-ui, sans-serif; background: var(--bg); color: #f8fafc; margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .grid-layout { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; width: 100%; max-width: 1000px; }
        .card { background: #0f172a; border-radius: 16px; padding: 20px; border: 1px solid #1e293b; position: relative; }
        
        #emitter-canvas { width: 100%; aspect-ratio: 1; background: #000; border-radius: 12px; margin-top: 15px; }
        .video-container { position: relative; width: 100%; aspect-ratio: 1; border-radius: 12px; overflow: hidden; background: #000; }
        #camera-feed { width: 100%; height: 100%; object-fit: cover; }
        
        /* Overlay de visée */
        .reticle { position: absolute; top: 10%; left: 10%; width: 80%; height: 80%; border: 2px dashed rgba(255,255,255,0.3); pointer-events: none; transition: border-color 0.3s; }
        .reticle.locked { border: 3px solid var(--success); box-shadow: 0 0 20px var(--success); }

        .status-badge { display: inline-block; padding: 4px 12px; border-radius: 99px; font-size: 0.75rem; font-weight: bold; text-transform: uppercase; margin-bottom: 10px; }
        .status-idle { background: #334155; }
        .status-sync { background: var(--primary); animation: pulse 1s infinite; }
        .status-locked { background: var(--success); }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        
        textarea { width: 100%; background: #020617; border: 1px solid #334155; color: var(--primary); border-radius: 8px; padding: 12px; box-sizing: border-box; font-family: monospace; }
        button { width: 100%; background: var(--primary); color: white; border: none; padding: 14px; border-radius: 8px; font-weight: bold; cursor: pointer; margin-top: 10px; }
        .log { height: 80px; overflow-y: auto; background: #000; color: #94a3b8; font-family: monospace; font-size: 0.7rem; padding: 10px; margin-top: 10px; border-radius: 6px; }
        .output { font-size: 1.2rem; min-height: 1.5em; color: #e2e8f0; margin: 15px 0; word-break: break-all; }
    </style>
</head>
<body>

    <h1 style="color: var(--primary); margin-bottom: 5px;">SPECTRAL FLOW <span style="font-weight: 300;">v3</span></h1>
    <p style="margin-bottom: 30px; opacity: 0.6;">Système de transmission optique avec verrouillage de signal</p>

    <div class="grid-layout">
        <!-- EMETTEUR -->
        <div class="card">
            <span class="status-badge status-idle" id="emitStatus">Prêt</span>
            <textarea id="msgInput">HELLO SPECTRAL</textarea>
            <button id="btnSend">DÉMARRER LA TRANSMISSION</button>
            <canvas id="emitter-canvas"></canvas>
            <div class="log" id="emitLog">> En attente...</div>
        </div>

        <!-- RÉCEPTEUR -->
        <div class="card">
            <span class="status-badge status-idle" id="recvStatus">Caméra Off</span>
            <div class="video-container">
                <video id="camera-feed" autoplay playsinline></video>
                <div class="reticle" id="reticle"></div>
            </div>
            <button id="btnStartCam" style="background: #334155;">ACTIVER LA RÉCEPTION</button>
            <div class="output" id="displayMsg">_</div>
            <div class="log" id="recvLog">> Prêt...</div>
        </div>
    </div>

<script>
    const GRID = 8;
    const BEACON_PATTERN = ["1", "0", "1", "0"]; // Motif de réveil (Flash Alterné)
    
    const emitterCanvas = document.getElementById('emitter-canvas');
    const eCtx = emitterCanvas.getContext('2d');
    const emitLog = document.getElementById('emitLog');
    const recvLog = document.getElementById('recvLog');
    const displayMsg = document.getElementById('displayMsg');
    const reticle = document.getElementById('reticle');
    const recvStatus = document.getElementById('recvStatus');

    let isTransmitting = false;

    // --- EMETTEUR ---
    emitterCanvas.width = 400;
    emitterCanvas.height = 400;

    const renderFrame = (bitString, isBeacon = false) => {
        const cellSize = emitterCanvas.width / GRID;
        eCtx.fillStyle = "black";
        eCtx.fillRect(0,0,400,400);

        for (let i = 0; i < GRID * GRID; i++) {
            const x = i % GRID;
            const y = Math.floor(i / GRID);
            const bit = bitString[i] || '0';
            
            // Si beacon, on flashe toute la grille
            const color = bit === '1' ? "#FFFFFF" : "#050505";
            eCtx.fillStyle = color;
            eCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
    };

    document.getElementById('btnSend').onclick = () => {
        if (isTransmitting) return;
        isTransmitting = true;
        
        const rawBin = document.getElementById('msgInput').value.split('').map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join('');
        const packets = [];

        // 1. PHASE DE RÉVEIL (BEACON) - 8 frames
        for(let i=0; i<8; i++) packets.push(i % 2 === 0 ? "1".repeat(64) : "0".repeat(64));
        
        // 2. DATA
        for (let i = 0; i < rawBin.length; i += 64) {
            packets.push(rawBin.substring(i, i + 64).padEnd(64, '0'));
        }
        
        // 3. FIN
        packets.push("0".repeat(64));

        let idx = 0;
        const speed = 150; // ms
        const timer = setInterval(() => {
            if (idx >= packets.length) {
                clearInterval(timer);
                isTransmitting = false;
                renderFrame("0".repeat(64));
                return;
            }
            renderFrame(packets[idx]);
            idx++;
        }, speed);
    };

    // --- RÉCEPTEUR ---
    const video = document.getElementById('camera-feed');
    let streamActive = false;
    let isLocked = false;

    document.getElementById('btnStartCam').onclick = async () => {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
        video.srcObject = stream;
        streamActive = true;
        recvStatus.className = "status-badge status-sync";
        recvStatus.innerText = "Recherche Signal...";
        startAnalysis();
    };

    const startAnalysis = () => {
        const pCanvas = document.createElement('canvas');
        const pCtx = pCanvas.getContext('2d', { willReadFrequently: true });
        pCanvas.width = 64;
        pCanvas.height = 64;

        let lastBits = "";
        let finalMessage = "";
        let syncBuffer = [];

        const analyze = () => {
            if (!streamActive) return;

            // Analyse de la zone centrale (80%)
            pCtx.drawImage(video, video.videoWidth*0.1, video.videoHeight*0.1, video.videoWidth*0.8, video.videoHeight*0.8, 0, 0, 64, 64);
            const data = pCtx.getImageData(0, 0, 64, 64).data;
            
            let currentBits = "";
            let globalBrightness = 0;
            let maxB = 0, minB = 255;

            // 1. Calcul de la grille
            for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                    let sum = 0;
                    for (let i=0; i<8; i++) {
                        for (let j=0; j<8; j++) {
                            const idx = ((y*8+i)*64 + (x*8+j))*4;
                            const b = (data[idx] + data[idx+1] + data[idx+2])/3;
                            sum += b;
                            if(b > maxB) maxB = b;
                            if(b < minB) minB = b;
                        }
                    }
                    const avg = sum/64;
                    globalBrightness += avg;
                    currentBits += avg > 140 ? "1" : "0";
                }
            }

            const contrast = maxB - minB;

            // 2. Logique de Verrouillage (Lock)
            if (!isLocked) {
                // On cherche le motif alterné 111... / 000...
                if (currentBits !== lastBits) {
                    if (currentBits === "1".repeat(64) || currentBits === "0".repeat(64)) {
                        syncBuffer.push(currentBits[0]);
                        if (syncBuffer.join('').includes("1010")) {
                            isLocked = true;
                            reticle.classList.add('locked');
                            recvStatus.className = "status-badge status-locked";
                            recvStatus.innerText = "Signal Verrouillé";
                            finalMessage = "";
                            displayMsg.innerText = "Chargement...";
                        }
                    }
                    lastBits = currentBits;
                }
            } else {
                // On est verrouillé : On décode
                if (currentBits !== lastBits) {
                    if (currentBits === "0".repeat(64) && contrast < 30) {
                        // Perte de signal ou fin
                        isLocked = false;
                        reticle.classList.remove('locked');
                        recvStatus.className = "status-badge status-sync";
                        recvStatus.innerText = "Signal Perdu";
                        syncBuffer = [];
                    } else {
                        // On décode les octets
                        for (let i = 0; i < currentBits.length; i += 8) {
                            const byte = currentBits.substring(i, i + 8);
                            const charCode = parseInt(byte, 2);
                            if (charCode > 31 && charCode < 127) {
                                finalMessage += String.fromCharCode(charCode);
                            }
                        }
                        displayMsg.innerText = finalMessage;
                    }
                    lastBits = currentBits;
                }
            }

            requestAnimationFrame(analyze);
        };
        analyze();
    };
</script>
</body>
</html>

