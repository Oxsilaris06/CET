
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectral Flow v5 - High Reliability</title>
    <style>
        :root { --bg: #030712; --primary: #0ea5e9; --success: #10b981; --warning: #f59e0b; }
        body { font-family: 'Inter', system-ui, sans-serif; background: var(--bg); color: #f1f5f9; margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        
        .layout { display: grid; grid-template-columns: repeat(auto-fit, minmax(380px, 1fr)); gap: 25px; width: 100%; max-width: 1100px; }
        .card { background: #0f172a; border-radius: 20px; padding: 25px; border: 1px solid #1e293b; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5); }
        
        #emitter-canvas { width: 100%; aspect-ratio: 1; background: #000; border-radius: 12px; margin-top: 15px; border: 2px solid #334155; }
        
        .camera-container { position: relative; width: 100%; aspect-ratio: 1; border-radius: 12px; overflow: hidden; background: #000; }
        #camera-feed { width: 100%; height: 100%; object-fit: cover; }
        
        .guide-frame { position: absolute; top: 10%; left: 10%; width: 80%; height: 80%; border: 2px solid rgba(255,255,255,0.05); pointer-events: none; }
        .guide-corner { position: absolute; width: 25px; height: 25px; border: 4px solid var(--primary); opacity: 0.5; }
        .tl { top: -4px; left: -4px; border-right: none; border-bottom: none; }
        .tr { top: -4px; right: -4px; border-left: none; border-bottom: none; }
        .bl { bottom: -4px; left: -4px; border-right: none; border-top: none; }
        .br { bottom: -4px; right: -4px; border-left: none; border-top: none; }

        .status-pill { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; font-weight: 700; padding: 8px 16px; border-radius: 99px; background: #1e293b; width: fit-content; margin-bottom: 15px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; background: #475569; }
        .active .dot { background: var(--success); box-shadow: 0 0 12px var(--success); }
        .syncing .dot { background: var(--warning); animation: blink 0.5s infinite; }

        @keyframes blink { 50% { opacity: 0.3; } }

        textarea { width: 100%; background: #030712; border: 1px solid #334155; color: var(--primary); border-radius: 10px; padding: 15px; font-family: monospace; box-sizing: border-box; font-size: 1rem; }
        button { width: 100%; background: var(--primary); color: white; border: none; padding: 16px; border-radius: 10px; font-weight: 800; cursor: pointer; margin-top: 15px; }
        
        .output-box { background: #030712; border-radius: 12px; padding: 15px; margin-top: 20px; border-left: 4px solid var(--success); min-height: 80px; }
        #decodedMsg { word-break: break-all; font-family: 'Courier New', monospace; line-height: 1.4; color: #fff; }
        .debug-info { font-size: 0.7rem; color: #64748b; font-family: monospace; margin-top: 10px; display: flex; justify-content: space-between; }
    </style>
</head>
<body>

    <h1 style="margin-bottom: 5px;">SPECTRAL FLOW <span style="color:var(--primary)">V5</span></h1>
    <p style="opacity: 0.5; margin-bottom: 30px;">Transmission Robuste - Analyse de Surface & Seuil Dynamique</p>

    <div class="layout">
        <div class="card">
            <div class="status-pill" id="emitStatus">
                <div class="dot"></div> PRÊT POUR ENVOI
            </div>
            <textarea id="msgInput" rows="3">MESSAGE TEST V5: STABILITE RENFORCEE</textarea>
            <button id="btnSend">TRANSMETTRE FLUX ROBUSTE</button>
            <canvas id="emitter-canvas"></canvas>
        </div>

        <div class="card">
            <div class="status-pill" id="recvStatus">
                <div class="dot"></div> ATTENTE ANCRAGE
            </div>
            <div class="camera-container">
                <video id="camera-feed" autoplay playsinline></video>
                <div class="guide-frame" id="guide">
                    <div class="guide-corner tl"></div>
                    <div class="guide-corner tr"></div>
                    <div class="guide-corner bl"></div>
                    <div class="guide-corner br"></div>
                </div>
            </div>
            <button id="btnStartCam" style="background: #334155;">ACTIVER RÉCEPTION</button>
            <div class="output-box">
                <div style="font-size: 0.7rem; opacity: 0.5; margin-bottom: 5px;">TEXTE DÉCODÉ :</div>
                <div id="decodedMsg">---</div>
            </div>
            <div class="debug-info">
                <span id="debugStability">Stabilité: 0/3</span>
                <span id="debugThreshold">Seuil: --</span>
            </div>
        </div>
    </div>

<script>
    const GRID = 8;
    const FRAME_RATE = 150; // ms
    
    const emitterCanvas = document.getElementById('emitter-canvas');
    const eCtx = emitterCanvas.getContext('2d');
    const emitStatus = document.getElementById('emitStatus');
    const recvStatus = document.getElementById('recvStatus');
    const decodedMsg = document.getElementById('decodedMsg');
    const debugStability = document.getElementById('debugStability');
    const debugThreshold = document.getElementById('debugThreshold');

    let isEmitting = false;

    // --- EMETTEUR ---
    emitterCanvas.width = 512;
    emitterCanvas.height = 512;

    const drawFrame = (dataBits) => {
        const size = emitterCanvas.width;
        const cellSize = size / (GRID + 4);
        
        eCtx.fillStyle = "black";
        eCtx.fillRect(0, 0, size, size);

        // Ancrage statique
        eCtx.fillStyle = "white";
        const anchorSize = cellSize * 1.5;
        eCtx.fillRect(0, 0, anchorSize, anchorSize);
        eCtx.fillRect(size - anchorSize, 0, anchorSize, anchorSize);
        eCtx.fillRect(0, size - anchorSize, anchorSize, anchorSize);
        eCtx.fillRect(size - anchorSize, size - anchorSize, anchorSize, anchorSize);

        // Grille centre
        const offset = cellSize * 2;
        const dataCellSize = (size - offset * 2) / GRID;

        for (let i = 0; i < GRID * GRID; i++) {
            const x = i % GRID;
            const y = Math.floor(i / GRID);
            const bit = dataBits[i] || '0';
            eCtx.fillStyle = bit === '1' ? "#FFFFFF" : "#080808";
            eCtx.fillRect(offset + x * dataCellSize + 2, offset + y * dataCellSize + 2, dataCellSize - 4, dataCellSize - 4);
        }
    };

    document.getElementById('btnSend').onclick = () => {
        if(isEmitting) return;
        isEmitting = true;
        emitStatus.classList.add('active');
        emitStatus.innerHTML = '<div class="dot"></div> TRANSMISSION EN COURS';

        const binary = document.getElementById('msgInput').value.split('').map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join('');
        let packets = [];
        for (let i = 0; i < binary.length; i += 64) {
            packets.push(binary.substring(i, i + 64).padEnd(64, '0'));
        }

        let idx = 0;
        const timer = setInterval(() => {
            if (idx >= packets.length) {
                clearInterval(timer);
                isEmitting = false;
                emitStatus.classList.remove('active');
                emitStatus.innerHTML = '<div class="dot"></div> TRANSMISSION TERMINÉE';
                drawFrame("0".repeat(64));
                return;
            }
            drawFrame(packets[idx]);
            idx++;
        }, FRAME_RATE);
    };

    drawFrame("0".repeat(64));

    // --- RECEPTEUR ---
    const video = document.getElementById('camera-feed');
    const guide = document.getElementById('guide');
    let streamActive = false;

    document.getElementById('btnStartCam').onclick = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: 640, height: 640 } });
            video.srcObject = stream;
            streamActive = true;
            processLoop();
        } catch (e) {
            alert("Erreur caméra : " + e.message);
        }
    };

    function processLoop() {
        const pCanvas = document.createElement('canvas');
        const pCtx = pCanvas.getContext('2d', { willReadFrequently: true });
        pCanvas.width = 160;
        pCanvas.height = 160;

        let stabilityCounter = 0;
        let lastStableBits = "";
        let currentCandidate = "";
        let finalMessage = "";

        const analyze = () => {
            if(!streamActive) return;

            // Capture centre (70% du flux)
            pCtx.drawImage(video, video.videoWidth*0.15, video.videoHeight*0.15, video.videoWidth*0.7, video.videoHeight*0.7, 0, 0, 160, 160);
            const pixels = pCtx.getImageData(0, 0, 160, 160).data;

            // 1. ANCRAGE & SEUIL DYNAMIQUE
            const getLum = (x, y) => {
                const idx = (y * 160 + x) * 4;
                return (pixels[idx] + pixels[idx+1] + pixels[idx+2]) / 3;
            };

            const corners = [getLum(5,5), getLum(155,5), getLum(5,155), getLum(155,155)];
            const isAnchored = corners.every(l => l > 170);

            if (!isAnchored) {
                recvStatus.className = "status-pill";
                recvStatus.innerHTML = '<div class="dot"></div> ATTENTE ANCRAGE';
                guide.style.borderColor = "rgba(255,255,255,0.05)";
                requestAnimationFrame(analyze);
                return;
            }

            // Calcul du seuil moyen (Dynamic Threshold)
            // On prend la moyenne entre le fond sombre (0) et les coins brillants (1)
            const dynamicThreshold = (Math.min(...corners) + 20) / 1.8;
            debugThreshold.innerText = "Seuil: " + Math.round(dynamicThreshold);

            // 2. ANALYSE DE GRILLE (Échantillonnage de surface)
            let frameBits = "";
            const start = 40; 
            const end = 120;
            const step = (end - start) / GRID;

            for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                    const cx = Math.floor(start + x * step + step/2);
                    const cy = Math.floor(start + y * step + step/2);
                    
                    // On moyenne sur un carré de 3x3 pixels pour chaque cellule
                    let cellSum = 0;
                    for(let dy=-1; dy<=1; dy++) {
                        for(let dx=-1; dx<=1; dx++) {
                            cellSum += getLum(cx+dx, cy+dy);
                        }
                    }
                    frameBits += (cellSum / 9) > dynamicThreshold ? "1" : "0";
                }
            }

            // 3. FILTRE DE STABILITÉ (Anti-transition)
            if (frameBits === currentCandidate && frameBits !== "0".repeat(64)) {
                stabilityCounter++;
            } else {
                currentCandidate = frameBits;
                stabilityCounter = 0;
            }

            debugStability.innerText = `Stabilité: ${stabilityCounter}/3`;

            // Validation du paquet
            if (stabilityCounter === 3 && frameBits !== lastStableBits) {
                lastStableBits = frameBits;
                recvStatus.className = "status-pill active";
                recvStatus.innerHTML = '<div class="dot"></div> RÉCEPTION...';
                guide.style.borderColor = "var(--success)";
                
                // Décodage
                for (let i = 0; i < frameBits.length; i += 8) {
                    const byte = frameBits.substring(i, i + 8);
                    const charCode = parseInt(byte, 2);
                    if (charCode >= 32 && charCode <= 126) {
                        finalMessage += String.fromCharCode(charCode);
                    }
                }
                decodedMsg.innerText = finalMessage;
            }

            requestAnimationFrame(analyze);
        };
        analyze();
    }
</script>
</body>
</html>

