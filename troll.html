
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectral Flow v2 - High Speed Optical Transfer</title>
    <style>
        :root { --bg: #0f172a; --primary: #38bdf8; --text: #f1f5f9; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; flex-direction: column; align-items: center; min-height: 100vh; overflow-x: hidden; }
        .app-container { width: 100%; max-width: 900px; padding: 20px; box-sizing: border-box; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media (max-width: 768px) { .app-container { grid-template-columns: 1fr; } }
        
        .panel { background: #1e293b; border-radius: 12px; padding: 20px; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }
        h1 { grid-column: 1 / -1; color: var(--primary); text-align: center; font-size: 1.5rem; margin-bottom: 0; }
        
        #emitter-canvas { width: 100%; aspect-ratio: 1/1; background: #000; border-radius: 8px; image-rendering: pixelated; margin-top: 15px; }
        #camera-feed { width: 100%; aspect-ratio: 1/1; background: #000; border-radius: 8px; object-fit: cover; }
        
        .controls { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        textarea { background: #0f172a; border: 1px solid #334155; color: #38bdf8; border-radius: 6px; padding: 10px; font-family: monospace; resize: none; }
        button { background: var(--primary); color: #0f172a; border: none; padding: 12px; border-radius: 6px; font-weight: bold; cursor: pointer; transition: transform 0.1s; }
        button:active { transform: scale(0.98); }
        button.secondary { background: #64748b; color: white; }

        .log { height: 100px; overflow-y: auto; background: #000; color: #4ade80; font-family: monospace; font-size: 0.75rem; padding: 10px; border-radius: 6px; margin-top: 10px; border: 1px solid #334155; }
        .received-msg { font-size: 1.2rem; font-weight: bold; color: #fbbf24; margin-top: 10px; min-height: 1.5em; border-bottom: 2px solid #334155; }
        .debug-overlay { position: relative; width: 100%; }
        .grid-mask { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 2px solid rgba(56, 189, 248, 0.5); pointer-events: none; box-sizing: border-box; display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); }
        .grid-mask div { border: 0.1px solid rgba(255,255,255,0.1); }
    </style>
</head>
<body>

    <h1>SPECTRAL FLOW v2</h1>
    <p style="font-size: 0.8rem; opacity: 0.7;">Transmission Optique Hybride - OptimisÃ© OnePlus Nord 5</p>

    <div class="app-container">
        <!-- EMETTEUR -->
        <div class="panel">
            <h2 style="margin-top:0">ðŸ“¤ Ã‰metteur</h2>
            <textarea id="msgInput" rows="3">HELLO WORLD</textarea>
            <div class="controls">
                <button id="btnSend">TRANSMETTRE LE FLUX</button>
                <div style="display:flex; gap:10px; font-size: 0.8rem;">
                    Vitesse: <input type="range" id="speedRange" min="50" max="500" value="150">
                </div>
            </div>
            <canvas id="emitter-canvas"></canvas>
            <div id="emitLog" class="log">> PrÃªt pour encodage...</div>
        </div>

        <!-- RÃ‰CEPTEUR -->
        <div class="panel">
            <h2 style="margin-top:0">ðŸ“¥ RÃ©cepteur</h2>
            <div class="debug-overlay">
                <video id="camera-feed" autoplay playsinline></video>
                <div class="grid-mask" id="gridMask"></div>
            </div>
            <div class="controls">
                <button id="btnStartCam" class="secondary">ACTIVER CAMÃ‰RA</button>
            </div>
            <div class="received-msg" id="displayMsg">...</div>
            <div id="recvLog" class="log">> En attente de signal...</div>
        </div>
    </div>

<script>
    // --- CONFIGURATION ---
    const GRID = 8; // 8x8 = 64 bits
    const SYNC_WORD = "1111111111111111"; // 16 bits de synchro (flash)
    
    const emitterCanvas = document.getElementById('emitter-canvas');
    const eCtx = emitterCanvas.getContext('2d');
    const emitLog = document.getElementById('emitLog');
    const recvLog = document.getElementById('recvLog');
    const displayMsg = document.getElementById('displayMsg');
    
    let isTransmitting = false;

    // --- OUTILS ---
    const logger = (el, msg) => {
        const time = new Date().toLocaleTimeString().split(' ')[0];
        el.innerHTML = `[${time}] ${msg}<br>` + el.innerHTML;
    };

    const strToBin = (str) => {
        return str.split('').map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join('');
    };

    // --- LOGIQUE EMETTEUR ---
    emitterCanvas.width = 256;
    emitterCanvas.height = 256;

    const drawGrid = (bitString) => {
        const cellSize = emitterCanvas.width / GRID;
        eCtx.clearRect(0, 0, emitterCanvas.width, emitterCanvas.height);
        
        for (let i = 0; i < GRID * GRID; i++) {
            const x = i % GRID;
            const y = Math.floor(i / GRID);
            const bit = bitString[i] || '0';
            
            // Modulation de luminance
            // 1 = Blanc pur, 0 = Gris sombre (pour garder une rÃ©fÃ©rence de grille)
            eCtx.fillStyle = bit === '1' ? '#FFFFFF' : '#111111';
            eCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
    };

    document.getElementById('btnSend').onclick = async () => {
        if (isTransmitting) return;
        isTransmitting = true;
        
        const rawBin = strToBin(document.getElementById('msgInput').value);
        const speed = parseInt(document.getElementById('speedRange').value);
        
        // Construction des paquets (64 bits par frame)
        let packets = [];
        // 1. SÃ©quence de Synchro (2 frames de blanc total)
        packets.push("1".repeat(64));
        packets.push("1".repeat(64));
        // 2. Data
        for (let i = 0; i < rawBin.length; i += 64) {
            packets.push(rawBin.substring(i, i + 64).padEnd(64, '0'));
        }
        // 3. Fin (Noir total)
        packets.push("0".repeat(64));

        logger(emitLog, `DÃ©but transmission : ${packets.length} frames`);
        
        let pIdx = 0;
        const timer = setInterval(() => {
            if (pIdx >= packets.length) {
                clearInterval(timer);
                isTransmitting = false;
                logger(emitLog, "TerminÃ©.");
                return;
            }
            drawGrid(packets[pIdx]);
            pIdx++;
        }, speed);
    };

    // --- LOGIQUE RÃ‰CEPTEUR ---
    const video = document.getElementById('camera-feed');
    let streamActive = false;

    document.getElementById('btnStartCam').onclick = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: "environment", width: 640, height: 640 } 
            });
            video.srcObject = stream;
            streamActive = true;
            logger(recvLog, "CamÃ©ra activÃ©e. Alignez la grille.");
            startAnalysis();
        } catch (err) {
            logger(recvLog, "ERREUR : " + err.message);
            alert("L'accÃ¨s camÃ©ra a Ã©chouÃ©. Assurez-vous d'Ãªtre en HTTPS ou localhost.");
        }
    };

    const startAnalysis = () => {
        const procCanvas = document.createElement('canvas');
        const pCtx = procCanvas.getContext('2d', { willReadFrequently: true });
        procCanvas.width = 64;
        procCanvas.height = 64;

        let lastFrameBits = "";
        let bufferBin = "";

        const loop = () => {
            if (!streamActive) return;

            // On dessine la partie centrale de la vidÃ©o sur notre petit canvas de calcul
            pCtx.drawImage(video, 80, 80, 480, 480, 0, 0, 64, 64);
            
            const imgData = pCtx.getImageData(0, 0, 64, 64).data;
            let currentBits = "";
            const cellSize = 64 / GRID;

            for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                    // Calcul de la moyenne de luminance de la cellule
                    let sum = 0;
                    let count = 0;
                    for (let cy = 0; cy < cellSize; cy++) {
                        for (let cx = 0; cx < cellSize; cx++) {
                            const idx = ((y * cellSize + cy) * 64 + (x * cellSize + cx)) * 4;
                            sum += (imgData[idx] + imgData[idx+1] + imgData[idx+2]) / 3;
                            count++;
                        }
                    }
                    const avg = sum / count;
                    currentBits += avg > 140 ? "1" : "0"; // Seuil adaptatif simplifiÃ©
                }
            }

            // DÃ©tection de changement d'Ã©tat (Edge detection temporelle)
            if (currentBits !== lastFrameBits) {
                if (currentBits === "1".repeat(64)) {
                    logger(recvLog, "SYNCHRO DÃ‰TECTÃ‰E");
                    bufferBin = ""; // Reset du buffer
                } else if (currentBits !== "0".repeat(64)) {
                    bufferBin += currentBits;
                    decodeBuffer(bufferBin);
                }
                lastFrameBits = currentBits;
            }

            requestAnimationFrame(loop);
        };
        loop();
    };

    const decodeBuffer = (bin) => {
        let text = "";
        for (let i = 0; i < bin.length; i += 8) {
            const byte = bin.substring(i, i + 8);
            if (byte.length === 8) {
                const charCode = parseInt(byte, 2);
                if (charCode > 31 && charCode < 127) {
                    text += String.fromCharCode(charCode);
                }
            }
        }
        if (text.length > 0) {
            displayMsg.innerText = text;
        }
    };

    // GÃ©nÃ©ration visuelle de la grille de masquage
    const mask = document.getElementById('gridMask');
    for(let i=0; i<64; i++) mask.appendChild(document.createElement('div'));

</script>
</body>
</html>

