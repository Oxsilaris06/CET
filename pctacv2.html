<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="icon" href="favicon.ico" sizes="any" type="image/png">
    <title>PC Tac v4.0 LIVE</title>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Oswald:wght@300;400;500&family=Saira+Stencil+One&display=swap" rel="stylesheet">
    <!-- Icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />

    <!-- Librairies Externes (PDF, QR, PeerJS) -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5-qrcode/2.3.8/html5-qrcode.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <style>
        /* --- VARIABLES & THEME --- */
        :root {
            --bg-body: #050505;
            --bg-glass: rgba(22, 22, 25, 0.8);
            --bg-glass-heavy: rgba(15, 15, 20, 0.95);
            --bg-input: rgba(0, 0, 0, 0.4);
            --border-glass: rgba(255, 255, 255, 0.1);
            
            --font-ui: 'Oswald', sans-serif;
            --font-data: 'JetBrains Mono', monospace;
            --font-title: 'Saira Stencil One', cursive;

            --accent-blue: #3b82f6;
            --accent-glow: rgba(59, 130, 246, 0.3);
            --success-green: #22c55e;
            --text-main: #e0e0e0;
            --text-muted: #94a3b8;

            --danger-red: #ef4444; 
            --civil-yellow: #eab308;
            --inter-blue: #3b82f6;
            --ao-green: #22c55e;

            --radius-md: 12px;
            --radius-sm: 6px;
        }

        body.light-mode {
            --bg-body: #f1f5f9;
            --bg-glass: rgba(255, 255, 255, 0.9);
            --bg-glass-heavy: #ffffff;
            --bg-input: rgba(255, 255, 255, 0.6);
            --border-glass: rgba(0, 0, 0, 0.1);
            --text-main: #1e293b;
            --text-muted: #64748b;
            --accent-blue: #0f4c9c;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            font-family: var(--font-ui);
            background-color: var(--bg-body);
            color: var(--text-main);
            background-image: 
                linear-gradient(rgba(59, 130, 246, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(59, 130, 246, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            min-height: 100vh;
            padding: 20px 10px 120px 10px;
            transition: background 0.3s ease;
        }

        .container { max-width: 1000px; margin: 0 auto; }

        /* --- HEADER & LIVE STATUS --- */
        header { position: relative; margin-bottom: 25px; }
        
        h1 {
            font-family: var(--font-title);
            font-size: 2.5em;
            color: var(--accent-blue);
            text-align: center;
            text-shadow: 0 0 20px var(--accent-glow);
            letter-spacing: 2px;
            margin: 0;
        }

        #live-status-badge {
            position: absolute; top: 0; right: 0;
            background: rgba(0,0,0,0.4); border: 1px solid var(--border-glass);
            padding: 5px 10px; border-radius: 20px;
            font-size: 0.75rem; font-family: var(--font-data);
            display: flex; align-items: center; gap: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        #live-status-badge.connected { border-color: var(--success-green); color: var(--success-green); background: rgba(34, 197, 94, 0.1); }
        .live-dot { width: 8px; height: 8px; border-radius: 50%; background: #666; }
        #live-status-badge.connected .live-dot { background: var(--success-green); box-shadow: 0 0 8px var(--success-green); animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        /* Input Titre Intervention */
        #intervention-title-container {
            background: var(--bg-glass); backdrop-filter: blur(10px);
            border: 1px solid var(--border-glass); border-radius: var(--radius-md);
            padding: 15px; margin-bottom: 20px;
            display: flex; align-items: center; gap: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #intervention-title-container label { margin: 0; white-space: nowrap; color: var(--accent-blue); }
        #intervention_title_input {
            border: none; background: transparent; border-bottom: 1px solid transparent;
            font-size: 1.1em; padding: 5px; color: var(--text-main);
        }
        #intervention_title_input:focus { border-bottom-color: var(--accent-blue); }

        /* --- FORMULAIRE --- */
        .log-entry-form {
            background: var(--bg-glass); backdrop-filter: blur(12px);
            border: 1px solid var(--border-glass); border-radius: var(--radius-md);
            padding: 20px; margin-bottom: 25px;
        }

        .form-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; border-bottom: 1px solid var(--border-glass); padding-bottom: 10px;
        }
        .form-header h3 { margin: 0; color: var(--text-muted); font-size: 1.2em; display: flex; align-items: center; gap: 8px; }

        #pax_mode_toggle_container { display: flex; background: rgba(0,0,0,0.2); padding: 3px; border-radius: 6px; }
        .mode-toggle-btn {
            background: transparent; border: none; color: var(--text-muted);
            padding: 6px 12px; border-radius: 4px; cursor: pointer; font-family: var(--font-ui); font-weight: 500;
        }
        .mode-toggle-btn.active { background: var(--accent-blue); color: white; }

        .form-row.main-fields { display: grid; grid-template-columns: 100px 1fr 1fr 1fr; gap: 15px; align-items: start; }
        .form-row.text-fields { margin-top: 15px; }

        label { color: var(--text-muted); font-size: 0.75em; text-transform: uppercase; font-weight: bold; margin-bottom: 5px; display: block; }
        
        input, textarea, select {
            width: 100%; background: var(--bg-input); border: 1px solid var(--border-glass);
            border-radius: var(--radius-sm); padding: 12px; color: var(--text-main);
            font-family: var(--font-data); font-size: 0.95em; transition: all 0.2s;
        }
        input:focus, textarea:focus { border-color: var(--accent-blue); }
        #heure_input { text-align: center; color: var(--accent-blue); font-weight: bold; }

        .pax-select { display: flex; gap: 8px; flex-wrap: wrap; }
        .pax-select-option {
            flex: 1; padding: 10px; background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-glass); border-radius: var(--radius-sm);
            cursor: pointer; text-align: center; font-size: 0.9em; min-width: 70px;
        }
        .pax-select-option.selected { transform: scale(1.05); border-color: transparent; opacity: 1; }
        .pax-select-option[data-pax="Adversaire"].selected { background: var(--danger-red); color: white; }
        .pax-select-option[data-pax="Otage"].selected { background: var(--civil-yellow); color: black; }
        .pax-select-option[data-pax="Inter"].selected { background: var(--inter-blue); color: white; }
        .pax-select-option[data-pax="AO"].selected { background: var(--ao-green); color: black; }

        #free_mode_options { background: rgba(255,255,255,0.03); padding: 10px; border-radius: var(--radius-sm); }
        .color-palette { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; justify-content: center; }
        .color-swatch { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; }
        .color-swatch.selected { border-color: white; transform: scale(1.2); }

        .add-log-btn {
            width: 100%; margin-top: 20px; padding: 14px;
            background: var(--accent-blue); color: white; border: none; border-radius: var(--radius-sm);
            font-size: 1.1em; text-transform: uppercase; letter-spacing: 1px; font-weight: bold;
            cursor: pointer; display: flex; justify-content: center; align-items: center; gap: 8px;
            box-shadow: 0 4px 12px var(--accent-glow);
        }

        /* --- TABLEAU --- */
        #logTableContainer {
            background: var(--bg-glass); border: 1px solid var(--border-glass);
            border-radius: var(--radius-md); overflow: hidden; margin-top: 20px;
        }
        .sort-button {
            width: 100%; padding: 10px; background: rgba(0,0,0,0.2); color: var(--text-muted);
            border: none; border-bottom: 1px solid var(--border-glass); cursor: pointer;
            display: flex; justify-content: center; gap: 5px; font-size: 0.8em; text-transform: uppercase;
        }
        table { width: 100%; border-collapse: collapse; }
        th { text-align: left; padding: 15px; color: var(--text-muted); font-size: 0.75em; text-transform: uppercase; background: rgba(0,0,0,0.2); }
        td { padding: 12px 15px; border-bottom: 1px solid var(--border-glass); vertical-align: middle; }
        
        .heure-cell-text { font-family: var(--font-data); color: var(--accent-blue); font-weight: bold; }
        .pax-cell { padding: 4px 10px; border-radius: 4px; font-size: 0.85em; font-weight: bold; text-transform: uppercase; }
        .delete-btn { background: none; border: none; color: var(--text-muted); cursor: pointer; opacity: 0.6; }
        .delete-btn:hover { color: var(--danger-red); opacity: 1; }

        /* Animation nouvelle entrée */
        @keyframes highlightRow { 0% { background: var(--accent-glow); } 100% { background: transparent; } }
        tr.just-added { animation: highlightRow 2s ease-out; }

        /* --- DOCK MENU --- */
        .dock-menu {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--bg-glass-heavy); backdrop-filter: blur(15px);
            border: 1px solid var(--border-glass); border-radius: 30px;
            padding: 8px 15px; display: flex; align-items: center; gap: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6); z-index: 1000;
            transition: all 0.3s; width: auto; max-width: 95vw; overflow-x: auto;
        }
        .dock-menu.collapsed { width: 50px; height: 50px; padding: 0; justify-content: center; overflow: hidden; border-radius: 50%; }
        .dock-menu.collapsed .dock-menu-item:not(#dockToggleBtn) { display: none; }
        .dock-menu-item {
            width: 42px; height: 42px; border-radius: 50%; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
            color: var(--text-muted); cursor: pointer; transition: all 0.2s;
        }
        .dock-menu-item:hover { color: var(--text-main); background: rgba(255,255,255,0.1); }
        #networkDockBtn { color: var(--text-main); position: relative; }
        #networkDockBtn.active { color: var(--success-green); background: rgba(34, 197, 94, 0.1); }

        /* --- MODALES --- */
        .custom-modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 2000; display: none; backdrop-filter: blur(5px); }
        .custom-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: var(--bg-body); border: 1px solid var(--border-glass); border-radius: var(--radius-md);
            padding: 25px; width: 95%; max-width: 450px; z-index: 2001; display: none;
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            max-height: 90vh; overflow-y: auto;
        }
        .modal-buttons { display: flex; gap: 10px; margin-top: 20px; }
        .modal-buttons button { flex: 1; padding: 12px; border: none; border-radius: var(--radius-sm); cursor: pointer; font-weight: bold; }
        
        /* Network Modal Specifics */
        .net-status-box { 
            background: rgba(0,0,0,0.3); padding: 15px; border-radius: var(--radius-sm); 
            margin-bottom: 20px; text-align: center; font-family: var(--font-data);
        }
        .net-input-group { margin-bottom: 15px; }
        .btn-action { background: var(--accent-blue); color: white; width: 100%; padding: 15px; border: none; border-radius: var(--radius-sm); font-weight: bold; cursor: pointer; margin-bottom: 10px; }
        .btn-action.secondary { background: rgba(255,255,255,0.1); }
        .copy-icon { cursor: pointer; margin-left: 10px; vertical-align: middle; font-size: 1rem; }
        
        /* QR Reader inside Modal */
        #qr-reader-net, #qr-reader-import {
            width: 100%; margin: 20px auto; border: 2px solid var(--accent-blue);
            border-radius: var(--radius-sm); overflow: hidden; background: black;
        }

        /* Vue Scan Réseau */
        #net-scan-view {
            display: none; /* Caché par défaut */
            flex-direction: column;
            align-items: center;
        }

        /* Vue Transfert Import */
        .transfer-tabs { display: flex; gap: 10px; margin-bottom: 20px; }
        .transfer-tab-btn {
            flex: 1; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid var(--border-glass);
            color: var(--text-muted); cursor: pointer; border-radius: var(--radius-sm); font-family: var(--font-ui);
        }
        .transfer-tab-btn.active { background: var(--accent-blue); color: white; border-color: transparent; }
        .transfer-content { display: none; }
        .transfer-content.active { display: block; }

        #qrcode-container {
            background: white; padding: 20px; border-radius: var(--radius-sm); margin: 20px auto;
            display: inline-block; max-width: 100%;
        }
        #qr-nav-controls {
            display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 15px;
            background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px;
        }
        .qr-nav-btn {
            background: rgba(255,255,255,0.1); border: 1px solid var(--border-glass); color: var(--text-main);
            width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer;
        }
        .qr-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        /* Mobile */
        @media (max-width: 768px) {
            .form-row.main-fields { display: flex; flex-direction: column; gap: 15px; }
            .form-row.main-fields > div:nth-child(1) { display: flex; align-items: center; gap: 10px; }
            .form-row.main-fields > div:nth-child(1) input { width: 120px; }
            
            table, thead, tbody, th, td, tr { display: block; }
            thead { display: none; }
            tr { background: rgba(255,255,255,0.03); border: 1px solid var(--border-glass); border-radius: var(--radius-md); margin-bottom: 15px; padding: 15px; position: relative; }
            td { padding: 6px 0; border: none; display: flex; justify-content: space-between; align-items: center; text-align: right; }
            td:nth-of-type(1) { justify-content: flex-start; font-size: 1.1em; border-bottom: 1px solid var(--border-glass); padding-bottom: 10px; }
            td:nth-of-type(2)::before { content: "Pax"; color: var(--text-muted); font-size: 0.75em; margin-right: 10px; }
            td:nth-of-type(3)::before { content: "Lieu"; color: var(--text-muted); font-size: 0.75em; margin-right: 10px; }
            td:nth-of-type(4)::before { content: "Ouvrant"; color: var(--text-muted); font-size: 0.75em; margin-right: 10px; }
            td:nth-of-type(5) { display: block; text-align: left; background: rgba(0,0,0,0.2); padding: 10px; margin-top: 10px; border-radius: 4px; font-style: italic; color: var(--text-muted); }
            
            .mobile-delete-btn {
                position: absolute; top: 15px; right: 15px;
                background: rgba(239, 68, 68, 0.15); color: var(--danger-red);
                border: none; border-radius: 4px; padding: 6px; display: block !important;
            }
        }
        .mobile-delete-btn { display: none; }
    </style>
</head>
<body class="dark-mode">
    <input type="file" id="jsonImportInput" accept=".json" style="display: none;">
    <div class="custom-modal-backdrop" id="modalBackdrop"></div>
    
    <!-- TOAST -->
    <div id="toast-container" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%) translateY(-100px); background: var(--success-green); color: black; padding: 12px 24px; border-radius: 30px; font-family: var(--font-ui); z-index: 3000; transition: transform 0.3s; font-weight: bold; display: flex; gap: 10px;">
        <span class="material-symbols-outlined">info</span> <span id="toast-message">Info</span>
    </div>

    <!-- MODAL RESET -->
    <div class="custom-modal" id="resetModal">
        <h3 style="color: var(--accent-blue); margin-bottom: 10px;">Purge Système</h3>
        <p style="color: var(--text-main);">Supprimer définitivement le journal ?</p>
        <div class="modal-buttons">
            <button id="confirmResetBtn" style="background: var(--danger-red); color: white;">Confirmer</button>
            <button id="cancelResetBtn" style="background: rgba(255,255,255,0.1); color: white;">Annuler</button>
        </div>
    </div>
    
    <!-- MODAL IMPORT QR (MODIFIÉ POUR EXPORT/IMPORT QR LOCAUX) -->
    <div class="custom-modal" id="qrImportModal">
        <h3 style="color: var(--success-green); margin-bottom: 15px; display:flex; align-items:center; gap:10px;">
            <span class="material-symbols-outlined">sync_alt</span> Transfert de Données
        </h3>
        
        <div class="transfer-tabs">
            <button class="transfer-tab-btn active" data-tab="send" onclick="switchQrTransferTab('send')">Envoyer (QR)</button>
            <button class="transfer-tab-btn" data-tab="receive" onclick="switchQrTransferTab('receive')">Recevoir (Scan)</button>
        </div>

        <!-- Contenu Envoyer -->
        <div id="qr-transfer-send" class="transfer-content active">
            <div id="qrcode-container"></div>
            
            <div id="qr-nav-controls" style="display: none;">
                <button class="qr-nav-btn" id="prevQrBtn"><span class="material-symbols-outlined">arrow_back</span></button>
                <span id="qr-counter">1/1</span>
                <button class="qr-nav-btn" id="nextQrBtn"><span class="material-symbols-outlined">arrow_forward</span></button>
            </div>
            
            <p id="qr-status-text" style="color: var(--text-muted); font-size: 0.85em; margin-top: 10px;">Cliquez sur Envoyer pour générer les QR codes.</p>
        </div>
        
        <!-- Contenu Recevoir -->
        <div id="qr-transfer-receive" class="transfer-content">
            <div id="qr-reader-import"></div>
            <p style="color: var(--text-muted); font-size: 0.9em;">Scanner les QR codes séquentiellement pour importer l'historique.</p>
        </div>

        <div class="modal-buttons">
            <button id="closeQrImportBtn" style="background: rgba(255,255,255,0.1); color: white;">Fermer</button>
        </div>
    </div>

    <!-- MODAL RESEAU (MODIFIÉ) -->
    <div class="custom-modal" id="networkModal">
        <h3 style="color: var(--accent-blue); margin-bottom: 15px; display:flex; align-items:center; gap:10px;">
            <span class="material-symbols-outlined">hub</span> Connexion Tactique
        </h3>
        
        <div class="net-input-group">
            <label>Identifiant (Callsign)</label>
            <input type="text" id="netCallsign" placeholder="Ex: PC, ALPHA, BRAVO..." maxlength="10" style="text-align: center; font-weight: bold; letter-spacing: 1px;">
        </div>

        <!-- État: Déconnecté (Formulaire) -->
        <div id="net-disconnected-view">
            <button class="btn-action" onclick="NetManager.hostSession()">
                <span class="material-symbols-outlined" style="vertical-align: middle;">add_circle</span> Créer une Session (Hôte)
            </button>
            
            <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                <input type="text" id="netJoinId" placeholder="ID Session à rejoindre..." style="text-align: center;">
                <button onclick="NetManager.pasteID()" style="width: 50px; background: rgba(255,255,255,0.1); border: 1px solid var(--border-glass); border-radius: var(--radius-sm); color: white; cursor: pointer;">
                    <span class="material-symbols-outlined">content_paste</span>
                </button>
            </div>
            <button class="btn-action secondary" onclick="NetManager.joinSession()">
                Rejoindre
            </button>
            <button class="btn-action secondary" onclick="NetManager.scanJoinQR()">
                <span class="material-symbols-outlined" style="vertical-align: middle; margin-right: 5px;">qr_code_scanner</span> Scanner ID Session
            </button>
        </div>

        <!-- État: Déconnecté (Scan en cours) -->
        <div id="net-scan-view">
            <div id="qr-reader-net"></div>
            <p style="color: var(--text-muted); font-size: 0.9em; margin-top: -10px;">Visez le QR Code de session de l'Hôte.</p>
            <button class="btn-action secondary" id="btn-cancel-scan" onclick="NetManager.stopQrScanNet()" style="margin-top: 10px;">
                Annuler Scan
            </button>
        </div>

        <!-- État: Connecté -->
        <div id="net-connected-view" style="display: none;">
            <div class="net-status-box">
                <div style="color: var(--success-green); font-weight: bold; margin-bottom: 5px;">CONNECTÉ</div>
                <div style="font-size: 0.8rem; color: var(--text-muted);">ID SESSION</div>
                <div style="font-size: 1.2rem; font-weight: bold; color: white; margin-top: 5px;">
                    <span id="displaySessionId">...</span>
                    <span class="material-symbols-outlined copy-icon" onclick="NetManager.copyID()">content_copy</span>
                </div>
                <div id="peersCount" style="margin-top: 10px; font-size: 0.9rem;">0 Pairs connectés</div>
            </div>
            
            <div style="text-align: center; margin-bottom: 15px;">
                <div id="qr-code-net" style="background: white; padding: 10px; display: inline-block; border-radius: 8px;"></div>
                <p style="color: var(--text-muted); font-size: 0.8em; margin-top: 5px;">QR Code d'accès rapide</p>
            </div>

            <button class="btn-action" style="background: var(--danger-red);" onclick="NetManager.disconnect()">
                <span class="material-symbols-outlined" style="vertical-align: middle;">power_off</span> Déconnexion
            </button>
        </div>

        <div class="modal-buttons">
            <button onclick="NetManager.closeModal()">Fermer</button>
        </div>
    </div>
    
    <div class="container">
        <header>
            <h1>PC TAC</h1>
            <div id="live-status-badge" onclick="NetManager.openModal()">
                <div class="live-dot"></div>
                <span id="live-status-text">OFFLINE</span>
            </div>
        </header>

        <div id="intervention-title-container">
            <label for="intervention_title_input"><span class="material-symbols-outlined" style="vertical-align:bottom; font-size:1.1em; margin-right:5px;">edit_document</span>Opération :</label>
            <input type="text" id="intervention_title_input" placeholder="Nom de l'intervention..." value="">
        </div>
        
        <!-- Formulaire -->
        <form id="log-form" class="log-entry-form">
            <div class="form-header">
                <h3><span class="material-symbols-outlined">playlist_add</span> Nouvelle Entrée</h3>
                <div id="pax_mode_toggle_container">
                    <button type="button" class="mode-toggle-btn active" data-mode="standard">Standard</button>
                    <button type="button" class="mode-toggle-btn" data-mode="free">Libre</button>
                </div>
            </div>
            
            <div class="form-row main-fields">
                 <div>
                    <label for="heure_input">Heure</label>
                    <input type="time" id="heure_input" required value="">
                 </div>
                 
                 <div>
                    <label>Pax / Élément</label>
                    <div id="pax_select_wrapper_standard">
                        <div class="pax-select" id="pax_select_container">
                            <span class="pax-select-option" data-pax="Adversaire">Adversaire</span>
                            <span class="pax-select-option" data-pax="Otage">Otage</span>
                            <span class="pax-select-option" data-pax="Inter">Inter</span>
                            <span class="pax-select-option" data-pax="AO">AO</span>
                        </div>
                    </div>
                    <div id="pax_select_wrapper_free" style="display: none;">
                        <div id="free_mode_options">
                            <div class="color-palette" id="free_color_palette"></div>
                            <input type="text" id="free_pax_input" placeholder="Identifiant..." value="" />
                            <input type="hidden" id="free_color_input" value="#800000" />
                        </div>
                    </div>
                    <input type="hidden" id="pax_input" required value="Adversaire">
                    <input type="hidden" id="pax_mode_input" value="standard">
                    <input type="hidden" id="pax_custom_color_input" value="#800000">
                 </div>
                 
                 <div>
                    <label for="lieu_input">Lieu / Zone</label>
                    <input type="text" id="lieu_input" list="lieu_history" placeholder="Ex: Salon..." value="">
                    <datalist id="lieu_history"></datalist>
                 </div>

                 <div>
                    <label for="fenetre_porte_input">Ouvrant</label>
                    <input type="text" id="fenetre_porte_input" list="fp_history" placeholder="Ex: Porte N..." value="">
                    <datalist id="fp_history"></datalist>
                 </div>
            </div>
            
            <div class="form-row text-fields">
                <div style="grid-column: span 1;">
                    <label for="remarques_input">Remarques</label>
                    <textarea id="remarques_input" rows="2" placeholder="Observations..."></textarea>
                </div>
            </div>

            <button type="submit" class="add-log-btn" id="addLogBtn">
                <span class="material-symbols-outlined">send</span> Ajouter (Broadcast)
            </button>
        </form>

        <!-- Tableau -->
        <div id="logTableContainer">
            <button type="button" class="sort-button" id="sortTimeBtn">
                <span class="material-symbols-outlined">schedule</span> Trier Chronologie
            </button>
            <table id="logTable">
                <thead>
                    <tr>
                        <th style="width: 15%;">Heure</th>
                        <th style="width: 15%;">Pax</th>
                        <th style="width: 20%;">Lieu</th>
                        <th style="width: 20%;">Ouvrant</th>
                        <th style="width: 30%;">Remarques</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        
		<footer style="text-align: center; margin-top: 30px; font-size: 0.7rem; color: var(--text-muted); opacity: 0.5;">
            PC Tac v4.0 LIVE • Réseau PeerJS Intégré
        </footer>
    </div>
    
    <!-- Dock Flottant -->
    <div class="dock-menu collapsed" id="dockMenu">
        <div class="dock-menu-item" id="dockToggleBtn"><span class="material-symbols-outlined">expand_less</span></div>
        
        <!-- BOUTON RESEAU -->
        <div class="dock-menu-item" id="networkDockBtn" title="Connexion Live" onclick="NetManager.openModal()">
            <span class="material-symbols-outlined">wifi</span>
        </div>
        
        <div class="dock-menu-item" id="exportJsonDockBtn"><span class="material-symbols-outlined">save</span></div>
        <div class="dock-menu-item" id="importJsonDockBtn" onclick="openQrImportModal()"><span class="material-symbols-outlined">qr_code_scanner</span></div>
        <div class="dock-menu-item" id="darkModeToggle"><span class="material-symbols-outlined" id="darkModeIcon">nightlight</span></div>
        <div class="dock-menu-item" id="previewPdfDockBtn"><span class="material-symbols-outlined">picture_as_pdf</span></div>
        <div class="dock-menu-item" id="resetDataDockBtn"><span class="material-symbols-outlined" style="color: var(--danger-red);">delete_forever</span></div>
    </div>

    <!-- SCRIPT APPLICATION -->
    <script>
        // --- CONSTANTES ---
        const LOCAL_STORAGE_KEY = 'pcTacLogData';
        const HISTORY_STORAGE_KEY = 'pcTacHistory';
        const TITLE_STORAGE_KEY = 'pcTacTitle';
        const SESSION_STORAGE_KEY = 'pcTacLiveSession'; // Clé pour persister l'état de session
        
        const QR_BATCH_SIZE = 8; // Nombre d'entrées par QR
        
        const FREE_MODE_COLORS = [
            { hex: '#800000' }, { hex: '#B87333' }, { hex: '#FFDB58' }, { hex: '#A3D900' },      
            { hex: '#00FFFF' }, { hex: '#000080' }, { hex: '#FF69B4' }, { hex: '#FF8C00' },  
            { hex: '#8A2BE2' }, { hex: '#008080' }, { hex: '#C0C0C0' }, { hex: '#ffffff' }           
        ];
        const PDF_PAX_COLORS = {
            'Adversaire': { text: 'Adversaire', color: '#ef4444', fontColor: '#ffffff' },
            'Otage': { text: 'Civil/Otage', color: '#eab308', fontColor: '#000000' }, 
            'Inter': { text: 'Inter', color: '#3b82f6', fontColor: '#ffffff' },
            'AO': { text: 'AO', color: '#22c55e', fontColor: '#000000' }
        };

        // --- VARIABLES GLOBALES UI ---
        const logTableBody = document.querySelector('#logTable tbody');
        const heureInput = document.getElementById('heure_input');
        const paxInput = document.getElementById('pax_input');
        const paxModeInput = document.getElementById('pax_mode_input'); 
        const paxCustomColorInput = document.getElementById('pax_custom_color_input'); 
        const freePaxInput = document.getElementById('free_pax_input'); 
        const lieuInput = document.getElementById('lieu_input');
        const fenetrePorteInput = document.getElementById('fenetre_porte_input');
        const remarquesInput = document.getElementById('remarques_input');
        const paxSelectContainer = document.getElementById('pax_select_container');
        const interventionTitleInput = document.getElementById('intervention_title_input');
        const qrImportModal = document.getElementById('qrImportModal');
        const closeQrImportBtn = document.getElementById('closeQrImportBtn');
        
        let html5QrCodeScanner = null;
        let isTimeInputManuallyChanged = false;
        let paxColorMap = {}; 
        
        let qrChunks = [];
        let currentQrIndex = 0;

        // --- GESTIONNAIRE RESEAU (Inspiré de COM TAC) ---
        const NetManager = {
            peer: null,
            conn: null,
            myId: null,
            hostId: null,
            isHost: false,
            callsign: 'PC',
            connections: [], // Liste des connexions actives (pour l'hôte)
            
            // Config STUN robuste pour 4G/NAT
            config: {
                debug: 1,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun.nextcloud.com:443' }
                    ]
                }
            },
            
            qrScannerNet: null,
            retryCount: 0,
            maxRetries: 5,

            // Sauvegarde de l'état de session dans localStorage
            saveSessionState: () => {
                const state = {
                    isConnected: !!NetManager.peer,
                    myId: NetManager.myId,
                    hostId: NetManager.hostId,
                    isHost: NetManager.isHost,
                    callsign: NetManager.callsign,
                    lastAttempt: Date.now() 
                };
                localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(state));
            },

            // Charge l'état et tente la reconnexion
            checkAndReconnect: () => {
                const state = JSON.parse(localStorage.getItem(SESSION_STORAGE_KEY));
                if (state && (state.isHost || state.hostId) && state.callsign) {
                    NetManager.callsign = state.callsign;
                    NetManager.hostId = state.hostId;
                    NetManager.isHost = state.isHost;
                    
                    showToast("Tentative de reconnexion...", false);
                    if (state.isHost) {
                        NetManager.initPeer(state.myId);
                    } else {
                        NetManager.initPeer(null, true);
                    }
                }
            },

            openModal: () => {
                document.getElementById('modalBackdrop').style.display = 'block';
                document.getElementById('networkModal').style.display = 'block';
                NetManager.stopQrScanNet(); 
                // Récupérer le callsign sauvegardé
                const saved = localStorage.getItem('pcTacCallsign');
                if(saved) document.getElementById('netCallsign').value = saved;
            },
            
            closeModal: () => {
                document.getElementById('networkModal').style.display = 'none'; 
                document.getElementById('modalBackdrop').style.display = 'none';
                NetManager.stopQrScanNet();
            },

            hostSession: () => {
                // Déconnexion obligatoire avant de créer un nouveau salon
                if (NetManager.peer) {
                    NetManager.disconnect();
                }

                const cs = document.getElementById('netCallsign').value.trim();
                if(!cs) return showToast("Identifiant requis");
                NetManager.callsign = cs;
                localStorage.setItem('pcTacCallsign', cs);
                
                NetManager.isHost = true;
                NetManager.initPeer();
            },

            joinSession: () => {
                const cs = document.getElementById('netCallsign').value.trim();
                const id = document.getElementById('netJoinId').value.trim();
                if(!cs || !id) return showToast("ID et Identifiant requis");
                NetManager.callsign = cs;
                NetManager.hostId = id;
                localStorage.setItem('pcTacCallsign', cs);
                
                NetManager.isHost = false;
                NetManager.initPeer(null, true); // true = mode client
            },
            
            scanJoinQR: () => {
                // S'assurer que les autres vues sont cachées
                document.getElementById('net-disconnected-view').style.display = 'none';
                document.getElementById('net-scan-view').style.display = 'flex';
                document.getElementById('net-connected-view').style.display = 'none';

                NetManager.qrScannerNet = new Html5Qrcode("qr-reader-net");
                const config = { fps: 10, qrbox: { width: 200, height: 200 } };
                
                NetManager.qrScannerNet.start({ facingMode: "environment" }, config, 
                    (decodedText) => {
                        NetManager.stopQrScanNet();
                        document.getElementById('netJoinId').value = decodedText;
                        NetManager.joinSession();
                    }, 
                    (errorMessage) => {
                        // Ignorer les erreurs de scan
                    }
                ).catch(err => {
                    showToast("Erreur caméra (live)", true);
                    NetManager.stopQrScanNet();
                });
            },
            
            stopQrScanNet: () => {
                if(NetManager.qrScannerNet) {
                    NetManager.qrScannerNet.stop().catch(err => console.log("Stop scan failed:", err));
                    NetManager.qrScannerNet = null;
                }
                // Rétablir la vue formulaire déconnecté
                document.getElementById('net-disconnected-view').style.display = 'block';
                document.getElementById('net-scan-view').style.display = 'none';
                document.getElementById('net-connected-view').style.display = 'none';
            },

            initPeer: (forceId = null, isClient = false) => {
                // Détruire l'ancienne instance si elle existe (pour reconnexion propre)
                if (NetManager.peer) NetManager.peer.destroy();
                NetManager.retryCount = 0;

                // Cacher les autres vues pendant l'initialisation
                document.getElementById('net-disconnected-view').style.display = 'none';
                document.getElementById('net-scan-view').style.display = 'none';
                
                document.querySelector('.modal-buttons button:first-child').innerText = 'Connexion...';
                
                NetManager.peer = new Peer(forceId, NetManager.config);

                NetManager.peer.on('open', (id) => {
                    NetManager.myId = id;
                    NetManager.updateUI(true);
                    NetManager.saveSessionState();
                    
                    if(isClient) {
                        NetManager.connectToHost(NetManager.hostId);
                    } else {
                        showToast("Session créée. En attente...");
                        // Hôte envoie le titre par défaut une fois l'ID défini
                        NetManager.broadcast({ type: 'TITLE_UPDATE', title: interventionTitleInput.value.trim() });
                    }
                    document.querySelector('.modal-buttons button:first-child').innerText = 'Fermer';
                });

                peer.on('connection', (conn) => {
                    NetManager.handleConnection(conn);
                });

                NetManager.peer.on('error', (err) => {
                    console.error("PeerJS Error:", err);
                    if (err.type === 'disconnected' || err.type === 'network') {
                        NetManager.attemptReconnect(isClient);
                    } else if (err.type !== 'peer-unavailable') {
                        showToast("Erreur Réseau: " + err.type, true);
                        NetManager.disconnect();
                    }
                    document.querySelector('.modal-buttons button:first-child').innerText = 'Fermer';
                });
                
                NetManager.peer.on('disconnected', () => {
                    showToast("Déconnexion du serveur PeerJS. Tentative de reconnexion...", true);
                    NetManager.attemptReconnect(isClient);
                });
            },
            
            attemptReconnect: (isClient) => {
                if (NetManager.retryCount < NetManager.maxRetries) {
                    NetManager.retryCount++;
                    const delay = NetManager.retryCount * 2000;
                    showToast(`Réessai de connexion dans ${delay/1000}s (${NetManager.retryCount}/${NetManager.maxRetries})`, true);
                    
                    if (NetManager.peer && !NetManager.peer.destroyed) {
                        setTimeout(() => NetManager.peer.reconnect(), delay);
                    } else {
                        setTimeout(() => {
                             if (isClient) NetManager.initPeer(null, true);
                             else NetManager.initPeer(NetManager.myId); 
                        }, delay);
                    }

                } else {
                    showToast("Échec de la reconnexion automatique. Session perdue.", true);
                    NetManager.disconnect();
                }
            },

            connectToHost: (hostId) => {
                const conn = NetManager.peer.connect(hostId, {
                    metadata: { callsign: NetManager.callsign }
                });
                
                conn.on('open', () => {
                    showToast("Connecté à l'Hôte");
                    NetManager.handleConnection(conn);
                    conn.send({ type: 'SYNC_REQ' });
                });
                
                conn.on('error', (err) => showToast("Erreur connexion hôte", true));
            },

            handleConnection: (conn) => {
                if(NetManager.isHost) {
                    NetManager.connections.push(conn);
                    NetManager.updatePeersCount();
                } else {
                    NetManager.conn = conn;
                }

                conn.on('data', (data) => {
                    if(data.type === 'SYNC_REQ' && NetManager.isHost) {
                        conn.send({ type: 'SYNC_FULL', logs: getLogData(), title: interventionTitleInput.value });
                        showToast(`Sync envoyée à ${conn.metadata.callsign || 'Client'}`);
                    }
                    
                    if(data.type === 'SYNC_FULL') {
                        if(data.title) { interventionTitleInput.value = data.title; saveTitle(data.title, false); } 
                        mergeLogs(data.logs);
                        showToast("Données synchronisées");
                    }

                    if(data.type === 'LOG_ADD') {
                        addLogLocally(data.entry);
                        if(NetManager.isHost) NetManager.broadcastExcept(data, conn.peer);
                    }

                    if(data.type === 'LOG_DEL') {
                        deleteLogLocally(data.id);
                        if(NetManager.isHost) NetManager.broadcastExcept(data, conn.peer);
                    }
                    
                    if(data.type === 'TITLE_UPDATE') {
                        interventionTitleInput.value = data.title;
                        saveTitle(data.title, false); 
                        showToast(`Opération : ${data.title}`);
                    }
                });

                conn.on('close', () => {
                    if(NetManager.isHost) {
                        NetManager.connections = NetManager.connections.filter(c => c.peer !== conn.peer);
                        NetManager.updatePeersCount();
                    } else {
                        showToast("Déconnecté de l'hôte", true);
                        NetManager.attemptReconnect(false); 
                    }
                });
            },

            broadcast: (data) => {
                if(!NetManager.peer || NetManager.peer.destroyed) return;
                
                if(NetManager.isHost) {
                    NetManager.connections.forEach(c => {
                        if(c.open) c.send(data);
                    });
                } else if(NetManager.conn && NetManager.conn.open) {
                    NetManager.conn.send(data);
                }
            },

            broadcastExcept: (data, exceptId) => {
                NetManager.connections.forEach(c => {
                    if(c.open && c.peer !== exceptId) c.send(data);
                });
            },

            disconnect: () => {
                if(NetManager.peer) NetManager.peer.destroy();
                NetManager.peer = null;
                NetManager.connections = [];
                NetManager.hostId = null;
                NetManager.isHost = false;
                localStorage.removeItem(SESSION_STORAGE_KEY); 
                NetManager.updateUI(false);
                showToast("Déconnexion effectuée");
            },

            updateUI: (connected) => {
                const badge = document.getElementById('live-status-badge');
                const badgeTxt = document.getElementById('live-status-text');
                const viewOff = document.getElementById('net-disconnected-view');
                const viewScan = document.getElementById('net-scan-view');
                const viewOn = document.getElementById('net-connected-view');
                const dockBtn = document.getElementById('networkDockBtn');

                viewScan.style.display = 'none'; 
                
                if(connected) {
                    badge.classList.add('connected');
                    badgeTxt.innerText = NetManager.isHost ? "HÔTE (LIVE)" : "CLIENT (LIVE)";
                    viewOff.style.display = 'none';
                    viewOn.style.display = 'block';
                    document.getElementById('displaySessionId').innerText = NetManager.myId;
                    dockBtn.classList.add('active');
                    NetManager.saveSessionState();
                    
                    // Générer QR Code de l'ID
                    document.getElementById('qr-code-net').innerHTML = "";
                    new QRCode(document.getElementById('qr-code-net'), {
                        text: NetManager.myId,
                        width: 128, height: 128
                    });
                } else {
                    badge.classList.remove('connected');
                    badgeTxt.innerText = "OFFLINE";
                    viewOff.style.display = 'block';
                    viewOn.style.display = 'none';
                    document.querySelector('#net-disconnected-view .btn-action').innerHTML = '<span class="material-symbols-outlined" style="vertical-align: middle;">add_circle</span> Créer une Session (Hôte)';
                    dockBtn.classList.remove('active');
                }
            },

            updatePeersCount: () => {
                document.getElementById('peersCount').innerText = `${NetManager.connections.length} Pairs connectés`;
            },

            copyID: () => {
                navigator.clipboard.writeText(NetManager.myId).then(() => showToast("ID Copié"));
            },
            
            pasteID: () => {
                navigator.clipboard.readText().then(t => document.getElementById('netJoinId').value = t);
            }
        };


        // --- LOGIQUE METIER & SYNC ---

        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }
        
        // Sauvegarde locale du titre et envoi sur le réseau si sendBroadcast est true
        function saveTitle(newTitle = interventionTitleInput.value.trim(), sendBroadcast = true) { 
            localStorage.setItem(TITLE_STORAGE_KEY, newTitle);
            // Suppression de l'envoi en direct pour éviter le spam, sauf si explicitement demandé (non utilisé ici)
            // if (sendBroadcast && NetManager.peer && NetManager.myId) {
            //      NetManager.broadcast({ type: 'TITLE_UPDATE', title: newTitle });
            // }
            // Correction: Le broadcast n'est pas nécessaire ici, car l'update réseau ne doit se faire que lors du SYNC_FULL
        }
        
        // Listener pour déclencher le broadcast du titre (Désactivé pour éviter le spam de connexion)
        interventionTitleInput.oninput = () => saveTitle(interventionTitleInput.value.trim(), false); 
        // Si le titre change, il sera synchronisé lors de la prochaine connexion/reconnexion complète (SYNC_FULL)

        // Fusionne les logs reçus (ex: connexion) avec les locaux
        function mergeLogs(remoteLogs) {
            const currentLogs = getLogData();
            const currentIds = new Set(currentLogs.map(l => l.id));
            let added = false;

            remoteLogs.forEach(rLog => {
                if(!currentIds.has(rLog.id)) {
                    currentLogs.push(rLog);
                    added = true;
                    // Mise à jour palette couleurs si mode libre
                    if(rLog.paxMode === 'free' && rLog.paxColor) {
                        paxColorMap[rLog.pax] = rLog.paxColor;
                    }
                }
            });

            if(added) {
                renderLogTable(currentLogs);
                updateHistoryAndColorMap(currentLogs);
            }
        }

        // Ajoute un log unique reçu par le réseau
        function addLogLocally(entry) {
            const logs = getLogData();
            // Vérif doublon
            if(logs.some(l => l.id === entry.id)) return;
            
            logs.push(entry);
            renderLogTable(logs, entry.id);
            updateHistoryAndColorMap(logs);
            showToast(`Nouveau Log: ${entry.pax}`);
        }

        // Supprime un log reçu par le réseau
        function deleteLogLocally(id) {
            const logs = getLogData().filter(l => l.id !== id);
            renderLogTable(logs);
            showToast("Entrée supprimée");
        }
        
        // Tri du tableau (bouton dédié)
        function sortLogTableByTime() {
             const logData = getLogData();
             logData.sort((a, b) => {
                if (a.heure < b.heure) return -1;
                if (a.heure > b.heure) return 1;
                return 0; 
             });
             renderLogTable(logData);
             showToast("Journal trié");
        }
        document.getElementById('sortTimeBtn').onclick = sortLogTableByTime;


        // --- FONCTIONS UI STANDARD (Adaptées) ---

        function showToast(message, isError = false) {
            const toast = document.getElementById('toast-container');
            const icon = toast.querySelector('.material-symbols-outlined');
            document.getElementById('toast-message').textContent = message;
            
            if (isError) {
                toast.style.backgroundColor = 'var(--danger-red)';
                toast.style.color = 'white';
                icon.textContent = 'warning';
            } else {
                toast.style.backgroundColor = 'var(--success-green)';
                toast.style.color = 'black';
                icon.textContent = 'info';
            }
            
            toast.style.transform = 'translateX(-50%) translateY(0)';
            setTimeout(() => { toast.style.transform = 'translateX(-50%) translateY(-100px)'; }, 3000);
        }

        function saveLogData(logData) {
            logData.sort((a, b) => a.heure.localeCompare(b.heure));
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(logData));
        }

        function getLogData() {
            return Array.from(logTableBody.querySelectorAll('tr')).map(row => ({
                id: row.dataset.id,
                heure: row.querySelector('.heure-cell-text').textContent,
                pax: row.dataset.freepaxname || row.dataset.pax,
                paxMode: row.dataset.paxmode,
                paxColor: row.dataset.paxcolor,
                lieu: row.dataset.lieu,
                fenetrePorte: row.dataset.fenetreporte,
                remarques: row.dataset.remarques,
            }));
        }

        function renderLogTable(logData, newEntryId = null) {
            logTableBody.innerHTML = '';
            // Tri Chronologique auto
            logData.sort((a, b) => a.heure.localeCompare(b.heure));
            
            logData.forEach(entry => {
                const row = logTableBody.insertRow();
                const isFree = entry.paxMode === 'free';
                
                // Préparation Couleurs
                let color = isFree ? (entry.paxColor || '#ffffff') : (PDF_PAX_COLORS[entry.pax]?.color || '#ef4444');
                let txtColor = isFree ? '#000000' : (PDF_PAX_COLORS[entry.pax]?.fontColor || '#ffffff');
                if(isFree) {
                    // Calcul contraste simple (y a pas de fonction getHexToRgb dans cette version, on simplifie)
                    txtColor = isColorLight(color) ? '#000000' : '#ffffff';
                }

                row.dataset.id = entry.id;
                row.dataset.pax = entry.pax;
                row.dataset.paxmode = entry.paxMode;
                row.dataset.paxcolor = entry.paxColor || '';
                if(isFree) row.dataset.freepaxname = entry.pax;
                row.dataset.lieu = entry.lieu;
                row.dataset.fenetreporte = entry.fenetrePorte;
                row.dataset.remarques = entry.remarques;

                if (entry.id === newEntryId) row.classList.add('just-added');

                row.innerHTML = `
                    <td>
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span class="heure-cell-text">${entry.heure}</span>
                            <button class="delete-btn desktop-only" onclick="deleteClick('${entry.id}')">✕</button>
                        </div>
                    </td>
                    <td><span class="pax-cell" style="background:${color}; color:${txtColor};">${entry.pax}</span></td>
                    <td>${entry.lieu}</td>
                    <td>${entry.fenetrePorte}</td>
                    <td>${entry.remarques}</td>
                    <button class="mobile-delete-btn" onclick="deleteClick('${entry.id}')"><span class="material-symbols-outlined">delete</span></button>
                `;
            });
            saveLogData(logData);
        }
        
        function isColorLight(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            // HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html
            const hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));
            return hsp > 150; // Seuil
        }

        // --- GESTIONNAIRES EVÈNEMENTS ---

        function handleAddLogEntry(e) {
            e.preventDefault();
            const mode = paxModeInput.value;
            let paxName, paxColorHex;
            
            if (mode === 'standard') {
                paxName = paxInput.value;
            } else {
                paxName = freePaxInput.value.trim();
                paxColorHex = paxCustomColorInput.value;
                if (!paxName) return showToast("Nom Pax requis");
            }
            if (!heureInput.value) return showToast("Heure requise");

            const newEntry = {
                id: generateUniqueId(),
                heure: heureInput.value,
                pax: paxName,
                paxMode: mode,
                paxColor: paxColorHex,
                lieu: lieuInput.value.trim(),
                fenetrePorte: fenetrePorteInput.value.trim(),
                remarques: remarquesInput.value.trim(),
            };

            // 1. Ajout local
            addLogLocally(newEntry);
            
            // 2. Broadcast Réseau
            NetManager.broadcast({ type: 'LOG_ADD', entry: newEntry });

            // Reset UI
            isTimeInputManuallyChanged = false;
            updateTimeInput();
            lieuInput.value = ''; fenetrePorteInput.value = ''; remarquesInput.value = '';
            
            if (mode === 'free') {
                 paxColorMap[paxName] = paxColorHex; 
            }
        }

        function deleteClick(id) {
            // Remplacer alert/confirm par une action simple, car Canvas n'aime pas les modales natives
            if(confirm("Confirmer la suppression ?")) {
                deleteLogLocally(id);
                NetManager.broadcast({ type: 'LOG_DEL', id: id });
            }
        }

        function updateTimeInput() {
            if (!isTimeInputManuallyChanged) {
                const now = new Date();
                heureInput.value = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
            }
        }

        function setPaxMode(mode) {
            const isStandard = mode === 'standard';
            document.getElementById('pax_select_wrapper_standard').style.display = isStandard ? 'block' : 'none';
            document.getElementById('pax_select_wrapper_free').style.display = isStandard ? 'none' : 'block';
            document.querySelectorAll('.mode-toggle-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.mode === mode));
            paxModeInput.value = mode;
        }

        function initColors() {
            const palette = document.getElementById('free_color_palette');
            FREE_MODE_COLORS.forEach(c => {
                const s = document.createElement('div');
                s.className = 'color-swatch';
                s.style.backgroundColor = c.hex;
                s.onclick = () => {
                    document.querySelectorAll('.color-swatch').forEach(el => el.classList.remove('selected'));
                    s.classList.add('selected');
                    paxCustomColorInput.value = c.hex;
                };
                palette.appendChild(s);
            });
            // Selection pax standard
            document.querySelectorAll('.pax-select-option').forEach(opt => {
                opt.onclick = () => {
                    document.querySelectorAll('.pax-select-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    paxInput.value = opt.dataset.pax;
                };
            });
            document.querySelector('[data-pax="Adversaire"]').click();
        }
        
        // Load/Save functions helpers for History
        function updateHistoryAndColorMap(logData) {
            const history = JSON.parse(localStorage.getItem(HISTORY_STORAGE_KEY) || '{"lieux":[], "fp":[]}');
            const lieux = new Set(history.lieux);
            const fp = new Set(history.fp);
            
            logData.forEach(l => {
                if(l.lieu) lieux.add(l.lieu);
                if(l.fenetrePorte) fp.add(l.fenetrePorte);
            });

            const newHistory = { lieux: Array.from(lieux), fp: Array.from(fp) };
            localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(newHistory));
            
            const dlLieu = document.getElementById('lieu_history'); dlLieu.innerHTML = '';
            newHistory.lieux.forEach(l => dlLieu.innerHTML += `<option value="${l}">`);
            
            const dlFp = document.getElementById('fp_history'); dlFp.innerHTML = '';
            newHistory.fp.forEach(l => dlFp.innerHTML += `<option value="${l}">`);
        }
        
        // --- QR IMPORT/EXPORT LOGS (LOCAL) ---
        
        function chunkArray(array, size) {
            const chunks = [];
            for (let i = 0; i < array.length; i += size) {
                chunks.push(array.slice(i, i + size));
            }
            return chunks;
        }

        function openQrImportModal() {
            document.getElementById('modalBackdrop').style.display = 'block';
            qrImportModal.style.display = 'block';
            
            switchQrTransferTab('send'); // Initialise l'onglet d'envoi par défaut
        }
        
        function switchQrTransferTab(tabName) {
            document.querySelectorAll('.transfer-tab-btn').forEach(t => t.classList.toggle('active', t.dataset.tab === tabName));
            document.querySelectorAll('.transfer-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`qr-transfer-${tabName}`).classList.add('active');
            
            stopQrImportScan(); // Arrêter l'ancien scan si on change d'onglet
            
            if (tabName === 'send') {
                prepareQRPagination();
            } else {
                startQrImportScan();
            }
        }
        
        function prepareQRPagination() {
            const logs = getLogData();
            const container = document.getElementById('qrcode-container');
            const statusText = document.getElementById('qr-status-text');
            const navControls = document.getElementById('qr-nav-controls');
            
            container.innerHTML = '';
            
            if (logs.length === 0) {
                statusText.textContent = "Aucune donnée à transférer.";
                navControls.style.display = 'none';
                return;
            }

            // Format compressé: [id, heure, pax, paxMode, paxColor, lieu, fenetrePorte, remarques]
            let compressedData = logs.map(l => [l.id, l.heure, l.pax, l.paxMode, l.paxColor, l.lieu, l.fenetrePorte, l.remarques]);
            
            qrChunks = chunkArray(compressedData, QR_BATCH_SIZE);
            currentQrIndex = 0;
            
            navControls.style.display = qrChunks.length > 1 ? 'flex' : 'none';
            
            showQR(currentQrIndex);
        }

        function showQR(index) {
            const container = document.getElementById('qrcode-container');
            const statusText = document.getElementById('qr-status-text');
            const counter = document.getElementById('qr-counter');
            const prevBtn = document.getElementById('prevQrBtn');
            const nextBtn = document.getElementById('nextQrBtn');
            
            container.innerHTML = ''; // Clear previous QR
            
            // Préparer le payload pour ce chunk spécifique
            let transferPayload = { 
                t: interventionTitleInput.value, // Titre envoyé avec chaque chunk pour le sync
                d: qrChunks[index],
                c: index + 1, // Index courant
                n: qrChunks.length // Nombre total de chunks
            };
            let jsonString = JSON.stringify(transferPayload);
            
            new QRCode(container, {
                text: jsonString,
                width: 256,
                height: 256,
                colorDark : "#000000",
                colorLight : "#ffffff",
                correctLevel : QRCode.CorrectLevel.M
            });
            
            // Mise à jour UI Navigation
            statusText.textContent = `Page ${index + 1} sur ${qrChunks.length} - ${qrChunks[index].length} entrées.`;
            counter.textContent = `${index + 1} / ${qrChunks.length}`;
            prevBtn.disabled = index === 0;
            nextBtn.disabled = index === qrChunks.length - 1;
        }

        document.getElementById('prevQrBtn').addEventListener('click', () => {
            if (currentQrIndex > 0) { currentQrIndex--; showQR(currentQrIndex); }
        });
        document.getElementById('nextQrBtn').addEventListener('click', () => {
            if (currentQrIndex < qrChunks.length - 1) { currentQrIndex++; showQR(currentQrIndex); }
        });


        function startQrImportScan() {
            html5QrCodeScanner = new Html5Qrcode("qr-reader-import");
            const config = { fps: 10, qrbox: { width: 250, height: 250 } };
            
            html5QrCodeScanner.start({ facingMode: "environment" }, config, 
                (decodedText) => {
                    handleQrImportData(decodedText);
                }, 
                (errorMessage) => {
                    // Ignorer les erreurs de scan
                }
            ).catch(err => {
                showToast("Erreur caméra (import)", true);
                // Ne pas arrêter le scan ici, il doit rester actif jusqu'à ce que l'utilisateur ferme l'onglet Receive
            });
        }

        function stopQrImportScan() {
            if(html5QrCodeScanner) {
                html5QrCodeScanner.stop().catch(err => console.log("Stop scan failed:", err));
                html5QrCodeScanner = null;
            }
            // Pas de masquage de modale ici, car c'est géré par closeModal/closeQrImportBtn.onclick
        }
        
        closeQrImportBtn.onclick = stopQrImportScan;
        
        function handleQrImportData(dataString) {
            try {
                const data = JSON.parse(dataString);
                
                // Le QR code séquentiel utilise le format {t: titre, d: logs, c: current, n: total}
                if (data.t !== undefined && Array.isArray(data.d)) {
                    // C'est un chunk de log séquentiel
                    if(data.t) { interventionTitleInput.value = data.t; saveTitle(data.t, false); }
                    
                    // Format reçu: [id, heure, pax, paxMode, paxColor, lieu, fenetrePorte, remarques]
                    const logsToAdd = data.d.map(item => ({
                        id: item[0],
                        heure: item[1],
                        pax: item[2],
                        paxMode: item[3],
                        paxColor: item[4],
                        lieu: item[5],
                        fenetrePorte: item[6],
                        remarques: item[7]
                    }));
                    
                    mergeLogs(logsToAdd);
                    showToast(`Paquet reçu ${data.c}/${data.n} (${logsToAdd.length} entrées ajoutées).`);
                    
                    // Si c'est le dernier paquet (n'est pas géré ici car le scanner ne s'arrête pas)
                    if(data.c === data.n) {
                       // stopQrImportScan();
                    }
                    
                } else if (data.metadata && data.logs) {
                    // Import JSON complet (au cas où on scanne un QR généré par export JSON)
                    if(data.metadata.title) { interventionTitleInput.value = data.metadata.title; saveTitle(data.metadata.title, false); }
                    mergeLogs(data.logs);
                    showToast("Import JSON (QR) réussi");
                } else {
                    showToast("Format QR inconnu ou invalide.", true);
                }
                
            } catch(e) {
                showToast("Erreur de décodage QR pour l'import", true);
                console.error("QR Import Error:", e);
            }
        }
        
        
        // --- PDF GENERATION (FULL LOGIC) ---
        
        function getHexToRgb(hex) {
             const bigint = parseInt(hex.slice(1), 16);
             const r = (bigint >> 16) & 255;
             const g = (bigint >> 8) & 255;
             const b = bigint & 255;
             return { r: r / 255, g: g / 255, b: b / 255 };
        }
        
        function getPdfColors(isDarkMode, rgb) {
            return isDarkMode 
                ? { background: rgb(0.05, 0.05, 0.05), text: rgb(0.9, 0.9, 0.9), line: rgb(0.2, 0.2, 0.2) } 
                : { background: rgb(0.95, 0.95, 0.95), text: rgb(0.1, 0.1, 0.1), line: rgb(0.8, 0.8, 0.8) };
        }
        
        function wrapTextForPdf(font, fontSize, text, maxWidth) {
            text = String(text || ''); const token = ' \n '; const chunks = text.replace(/\r?\n/g, token).split(' ');
            let lines = []; let currentLine = '';
            for (const chunk of chunks) {
                if (chunk === '\n') { lines.push(currentLine.trim()); currentLine = ''; continue; }
                const lineWithChunk = currentLine === '' ? chunk : `${currentLine} ${chunk}`;
                if (font.widthOfTextAtSize(lineWithChunk, fontSize) > maxWidth && currentLine !== '') { 
                    lines.push(currentLine.trim()); currentLine = chunk; 
                } else { currentLine = lineWithChunk; }
            }
            lines.push(currentLine.trim()); return lines.filter(line => line.length > 0);
        }

        async function buildPdf() {
            if (typeof PDFLib === 'undefined') { throw new Error("PDFLib non chargé."); }
            const { PDFDocument, StandardFonts, rgb, PageSizes } = PDFLib;
            const pdfDoc = await PDFDocument.create();
            
            // Landscape A4 orientation
            const pageConfig = { width: PageSizes.A4[1], height: PageSizes.A4[0], margin: 30, fontSize: 10, lineHeight: 14 };
            let helveticaFont, helveticaBoldFont;
            
            try {
                helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
                helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
            } catch (e) { throw new Error("Erreur de chargement des polices PDF."); }
            
            const logData = getLogData();
            const interventionTitle = interventionTitleInput.value.trim() || "Journal d'intervention";
            const isDarkMode = document.body.classList.contains('dark-mode');
            const pdfThemeColors = getPdfColors(isDarkMode, rgb); 
            
            // Colonnes: Heure (10%), Pax (15%), Lieu (20%), Ouvrant (20%), Remarques (35%)
            const colWidthRatios = [0.10, 0.15, 0.20, 0.20, 0.35]; 
            
            const context = {
                pdfDoc, helveticaFont, helveticaBoldFont, currentPage: null, y: 0, pageNumber: 0,
                pageWidth: pageConfig.width, pageHeight: pageConfig.height, margin: pageConfig.margin,
                fontSize: pageConfig.fontSize, lineHeight: pageConfig.lineHeight,
                colors: pdfThemeColors,
                interventionTitle: interventionTitle,
                colWidthRatios: colWidthRatios
            };
            
            const drawFooter = () => {
                const footerText = `PC Tac v4.0 | ${new Date().toLocaleDateString()} | Page ${context.pageNumber}`;
                const textWidth = context.helveticaFont.widthOfTextAtSize(footerText, context.fontSize);
                context.currentPage.drawText(footerText, { x: (context.pageWidth / 2) - (textWidth / 2), y: context.margin / 2, font: context.helveticaFont, size: 8, color: context.colors.text });
            };
            
            const addNewPage = () => {
                if (context.currentPage) { drawFooter(); }
                context.currentPage = context.pdfDoc.addPage([pageConfig.width, pageConfig.height]); 
                context.pageNumber++;
                context.y = context.pageHeight - context.margin;
                // Dessiner le fond (pour le mode sombre)
                context.currentPage.drawRectangle({ x: 0, y: 0, width: context.pageWidth, height: context.pageHeight, color: context.colors.background });
                
                // Titre
                context.currentPage.drawText(context.interventionTitle, { x: context.margin, y: context.pageHeight - context.margin / 2, font: context.helveticaBoldFont, size: 14, color: context.colors.text });
                
                context.y = context.pageHeight - context.margin - 20; // 20px sous le titre
            };
            
            const checkY = (spaceNeeded) => { 
                // Vérifier si la place restante (y - marge du bas) est suffisante
                if (context.y - spaceNeeded < context.margin * 1.5) { 
                    addNewPage(); 
                    drawTableHeader(); 
                    return true; 
                } 
                return false; 
            };
            
            const drawTableHeader = () => {
                 const headers = ["Heure", "Pax", "Lieu", "Ouvrant", "Remarques"];
                 let currentX = context.margin;
                 const tableY = context.y;
                 const headerHeight = context.lineHeight + 5;
                 
                 // Ligne supérieure (séparateur)
                 context.currentPage.drawLine({ start: { x: context.margin, y: tableY - 1 }, end: { x: context.pageWidth - context.margin, y: tableY - 1 }, color: context.colors.line, thickness: 1 });
                 
                 headers.forEach((header, i) => {
                     const colWidth = context.pageWidth * context.colWidthRatios[i];
                     context.currentPage.drawText(header, { 
                         x: currentX + 2, 
                         y: tableY - headerHeight + 5, 
                         font: context.helveticaBoldFont, 
                         size: context.fontSize, 
                         color: context.colors.text 
                     });
                     currentX += colWidth;
                 });
                 context.y -= headerHeight;
            };
            
            const drawLogEntry = (entry) => {
                let paxColorHex, paxText, paxTextColor;
                const isFreeMode = entry.paxMode === 'free';
                
                if (isFreeMode) {
                    paxColorHex = entry.paxColor || '#C0C0C0'; paxText = entry.pax;
                    paxTextColor = isColorLight(paxColorHex) ? rgb(0, 0, 0) : rgb(1, 1, 1);
                } else {
                    const paxInfo = PDF_PAX_COLORS[entry.pax] || PDF_PAX_COLORS['Adversaire'];
                    paxColorHex = paxInfo.color; paxText = paxInfo.text;
                    paxTextColor = paxInfo.fontColor === '#000000' ? rgb(0, 0, 0) : rgb(1, 1, 1);
                }
                
                const { r, g, b } = getHexToRgb(paxColorHex); 
                const paxPdfColor = rgb(r, g, b); 
                
                const colWidthsPx = context.colWidthRatios.map(ratio => context.pageWidth * ratio - (context.margin / 5));
                const parts = [
                    { text: entry.heure, colIndex: 0, font: context.helveticaFont, size: context.fontSize, color: context.colors.text },
                    { text: paxText, colIndex: 1, font: context.helveticaBoldFont, size: context.fontSize, color: paxTextColor, isPax: true }, 
                    { text: entry.lieu, colIndex: 2, font: context.helveticaFont, size: context.fontSize, color: context.colors.text }, 
                    { text: entry.fenetrePorte, colIndex: 3, font: context.helveticaFont, size: context.fontSize, color: context.colors.text },
                    { text: entry.remarques, colIndex: 4, font: context.helveticaFont, size: context.fontSize, color: context.colors.text },
                ];
                
                let allLines = parts.map((part, i) => {
                    part.text = String(part.text || '').trim(); if (!part.text && i !== 4) return ['']; 
                    const maxWidth = colWidthsPx[i] - 4; // -4 pour le padding interne
                    return wrapTextForPdf(part.font, part.size, part.text, maxWidth);
                });
                
                const maxLines = allLines.reduce((max, lines) => Math.max(max, lines.length), 1);
                const rowHeight = maxLines * context.lineHeight + 5;

                // Check page break
                if (checkY(rowHeight)) { 
                    // Si on ajoute une page, on redessine l'entrée sur la nouvelle page
                    drawLogEntry(entry);
                    return; 
                }
                
                let currentX = context.margin; 
                const tableY = context.y;
                
                parts.forEach((part, i) => {
                    const colWidth = context.pageWidth * context.colWidthRatios[i];
                    const x = currentX; 
                    const textLines = allLines[i];
                    
                    if (i === 1) { // Colonne PAX (chip coloré)
                        const bgX = x + 1; 
                        const paxBlockHeight = context.lineHeight + 4; 
                        const paxBlockY = tableY - rowHeight + (rowHeight - paxBlockHeight) / 2;
                        
                        // Fond coloré
                        context.currentPage.drawRectangle({ 
                            x: bgX, y: paxBlockY, 
                            width: colWidthsPx[i] - 2, 
                            height: paxBlockHeight, 
                            color: paxPdfColor, opacity: 1, borderWidth: 0 
                        });
                        
                        // Texte centré
                        const text = textLines[0] || ''; 
                        const textWidth = part.font.widthOfTextAtSize(text, part.size);
                        const textX = bgX + (colWidthsPx[i] - textWidth) / 2; 
                        const textY = paxBlockY + (paxBlockHeight - part.size) / 2 + 1; // +1 pour ajustement visuel
                        context.currentPage.drawText(text, { x: textX, y: textY, font: part.font, size: part.size, color: part.color });
                    } else { 
                        // Autres colonnes (multi-lignes)
                        textLines.forEach((line, lineIndex) => {
                            const textY = tableY - context.lineHeight - (lineIndex * context.lineHeight) - 2;
                            if (line) { 
                                context.currentPage.drawText(line, { x: x + 2, y: textY, font: part.font, size: part.size, color: part.color }); 
                            }
                        });
                    }
                    currentX += colWidth;
                });
                
                // Ligne de séparation de ligne
                context.currentPage.drawLine({ 
                    start: { x: context.margin, y: tableY - rowHeight + 1 }, 
                    end: { x: context.pageWidth - context.margin, y: tableY - rowHeight + 1 }, 
                    color: context.colors.line, thickness: 0.5, opacity: 0.5 
                });
                context.y -= rowHeight;
            };

            addNewPage(); 
            drawTableHeader();
            logData.forEach(entry => { drawLogEntry(entry); });
            drawFooter();
            
            const pdfBytes = await pdfDoc.save();
            return pdfBytes;
        }

        async function downloadPdf() {
            try {
                // Remplacer le contenu du bouton par un indicateur de chargement si vous voulez
                // ...
                
                const pdfBytes = await buildPdf();
                if (!pdfBytes) { showToast("Échec de la génération PDF", true); return; }
                
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const today = new Date().toLocaleDateString('fr-FR').replace(/\//g, '-');
                const title = interventionTitleInput.value.trim() || "Log";
                const fileName = `PC_Tac_${title.replace(/[^a-z0-9]/gi, '_')}_${today}.pdf`;
                
                // Téléchargement
                const url = URL.createObjectURL(blob); 
                const link = document.createElement('a');
                link.href = url; link.download = fileName; 
                document.body.appendChild(link); link.click();
                setTimeout(() => { document.body.removeChild(link); URL.revokeObjectURL(url); }, 0); 
                
            } catch (error) { 
                console.error("Erreur PDF critique:", error);
                showToast(`Erreur PDF: ${error.message || 'Génération échouée'}`, true); 
            } finally {
                // Rétablir le bouton
                // ...
            }
        }


        // --- INIT ---
        document.addEventListener('DOMContentLoaded', () => {
            // Theme
            const isDark = localStorage.getItem('theme') !== 'light';
            if(!isDark) document.body.classList.replace('dark-mode', 'light-mode');
            document.getElementById('darkModeToggle').onclick = () => {
                document.body.classList.toggle('dark-mode');
                document.body.classList.toggle('light-mode');
                localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
            };

            // Load Data
            const savedLogs = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            renderLogTable(savedLogs);
            updateHistoryAndColorMap(savedLogs);
            
            // Le titre est chargé ici, mais le listener est défini dans saveTitle()
            interventionTitleInput.value = localStorage.getItem(TITLE_STORAGE_KEY) || '';

            // Tenter la reconnexion au chargement
            NetManager.checkAndReconnect();

            // Form Logic
            document.getElementById('log-form').onsubmit = handleAddLogEntry;
            document.querySelectorAll('.mode-toggle-btn').forEach(b => b.onclick = () => setPaxMode(b.dataset.mode));
            initColors();
            
            // Time Auto
            updateTimeInput();
            setInterval(updateTimeInput, 60000);
            heureInput.onchange = () => isTimeInputManuallyChanged = true;

            // Dock UI
            document.getElementById('dockToggleBtn').onclick = () => document.getElementById('dockMenu').classList.toggle('collapsed');
            document.getElementById('resetDataDockBtn').onclick = () => {
                document.getElementById('modalBackdrop').style.display='block';
                document.getElementById('resetModal').style.display='block';
            };
            document.getElementById('confirmResetBtn').onclick = () => {
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                renderLogTable([]);
                document.getElementById('resetModal').style.display='none';
                document.getElementById('modalBackdrop').style.display='none';
                showToast("Journal purgé");
                // Si connecté, on pourrait envoyer un 'RESET_ALL' mais dangereux. On reste local sur le reset.
            };
            document.getElementById('cancelResetBtn').onclick = () => {
                 document.getElementById('resetModal').style.display='none';
                 document.getElementById('modalBackdrop').style.display='none';
            };
            document.getElementById('modalBackdrop').onclick = (e) => {
                if(e.target.id === 'modalBackdrop') {
                    document.getElementById('resetModal').style.display='none';
                    NetManager.stopQrScanNet();
                    stopQrImportScan();
                    NetManager.closeModal(); // Ferme networkModal
                }
            };
            
            // Import/Export JSON
            document.getElementById('exportJsonDockBtn').onclick = () => {
                const data = { metadata: { title: interventionTitleInput.value, date: new Date(), format: "PC Tac JSON Export" }, logs: getLogData() };
                const blob = new Blob([JSON.stringify(data, null, 2)], {type : 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `PCTAC_${Date.now()}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                showToast("Export JSON réussi");
            };
            document.getElementById('importJsonDockBtn').onclick = openQrImportModal;
            
            // PDF Generation
            document.getElementById('previewPdfDockBtn').onclick = downloadPdf;
            
            // Listeners pour fermer les modales de scan
            document.getElementById('closeQrImportBtn').onclick = stopQrImportScan;
            document.getElementById('networkModal').querySelector('.modal-buttons button:first-child').onclick = NetManager.closeModal;
        });
    </script>
</body>
</html>
